# Codex自动管理子进程方案

## 问题背景

需要实现一个完全自动化的Codex服务，满足需求：
1. **对话连续性**：Codex能记住之前的对话内容
2. **纯净输出**：只返回最终结果，不包含思考过程
3. **自动管理**：Claude启动时自动拉起Codex，退出时自动清理
4. **实例隔离**：多个Claude进程的Codex互不干扰

## 方案选择：Claude子进程自动管理架构

### 核心架构
```
[Claude Code主进程]
    ├── fork() --> [Codex子进程A] <--> [自动生成SocketA] <--> [内存历史A]
    ├── fork() --> [Codex子进程B] <--> [自动生成SocketB] <--> [内存历史B]
    └── fork() --> [Codex子进程C] <--> [自动生成SocketC] <--> [内存历史C]
```

### 自动管理原则
- **子进程模式**：Codex作为Claude的子进程运行
- **自动路径**：Socket路径基于进程ID自动生成
- **生命周期绑定**：Codex随Claude启动/退出
- **异常恢复**：子进程崩溃时Claude自动重新拉起

### 技术设计

#### 1. 自动生成IPC机制
- **选择**：Unix Socket (本地性能充足)
- **路径模式**：`/tmp/codex-{claude_pid}-{uuid}.sock`
- **权限**：0600 (用户私有)
- **自动生成**：Claude启动时自动生成唯一路径

##### 自动路径生成：
```python
import os
import uuid

def generate_socket_path():
    claude_pid = os.getppid()  # Claude父进程ID
    unique_id = str(uuid.uuid4())[:8]  # 短UUID
    socket_path = f"/tmp/codex-{claude_pid}-{unique_id}.sock"
    return socket_path
```

##### 临时目录结构：
```
/tmp/
├── codex-12345-a1b2c3d4.sock      # Claude进程12345的Codex实例
├── codex-12345-e5f6g7h8.sock      # Claude进程12345的第二个实例(如果需要)
├── codex-67890-i9j0k1l2.sock      # Claude进程67890的Codex实例
└── codex-67890-m3n4o5p6.sock      # Claude进程67890的第二个实例
```

#### 2. 支持实例绑定的JSON协议

##### 请求格式（包含实例绑定字段和profile配置）：
```json
{
  "instance_id": "abc123def",
  "type": "query",
  "message": "用户的问题",
  "config": {
    "show_reasoning": false,
    "output_format": "final_only",
    "profile": "high"
  },
  "timestamp": 1734987654
}
```

##### 配置变更请求格式：
配置请求统一使用 `type=config`，通过 `action` 指定变更目标：
- `set_profile`：切换模型强度 (`profile` 取值 `high|default|low`)
- `set_reasoning`：控制是否向Claude展示推理 (`show_reasoning` 取值 `true|false`)
- `set_output_format`：控制是否仅输出最终答案 (`output_format` 取值 `final_only|final_with_details`)

```jsonc
// 切换模型强度
{
  "instance_id": "abc123def",
  "type": "config",
  "action": "set_profile",
  "profile": "low",
  "timestamp": 1734987654
}

// 切换推理展示开关
{
  "instance_id": "abc123def",
  "type": "config",
  "action": "set_reasoning",
  "show_reasoning": false,
  "timestamp": 1734987654
}

// 切换输出格式
{
  "instance_id": "abc123def",
  "type": "config",
  "action": "set_output_format",
  "output_format": "final_only",
  "timestamp": 1734987654
}
```

##### 响应格式（包含当前profile信息）：
```json
{
  "instance_id": "abc123def",
  "type": "response",
  "message": "Codex的回答",
  "status": "success",
  "metadata": {
    "context_length": 15,
    "processing_time": 0.5,
    "active_profile": "high",
    "show_reasoning": false,
    "output_format": "final_only"
  }
}
```

##### 配置变更响应格式：
```json
{
  "instance_id": "abc123def",
  "type": "config_response",
  "action": "set_profile",
  "profile": "low",
  "status": "success",
  "message": "Profile已更新为low"
}

{
  "instance_id": "abc123def",
  "type": "config_response",
  "action": "set_reasoning",
  "show_reasoning": false,
  "status": "success",
  "message": "Show Reasoning 已关闭"
}

{
  "instance_id": "abc123def",
  "type": "config_response",
  "action": "set_output_format",
  "output_format": "final_only",
  "status": "success",
  "message": "Output Format 已切换为 final_only"
}
```

##### 错误格式：
```json
{
  "instance_id": "abc123def",
  "type": "error",
  "message": "错误信息",
  "status": "error",
  "error_code": "CONNECTION_FAILED"
}
```

##### Codex子进程核心逻辑（节选）：
```python
import json
import os
import socket
import time


class CodexProcess:
    def __init__(self, socket_path, instance_id):
        self.socket_path = socket_path
        self.instance_id = instance_id
        self.conversation_history = []
        self.current_profile = "default"
        self.show_reasoning = False
        self.output_format = "final_only"

    def _validate_schema(self, request):
        required_fields = ["instance_id", "type", "timestamp"]
        for field in required_fields:
            if field not in request:
                raise ValueError(f"缺少必需字段: {field}")
        if request["instance_id"] != self.instance_id:
            raise ValueError("实例ID不匹配")
        request.setdefault("config", {})
        config = request["config"]
        config.setdefault("profile", self.current_profile)
        config.setdefault("show_reasoning", self.show_reasoning)
        config.setdefault("output_format", self.output_format)
        if config["profile"] not in ["high", "low", "default"]:
            config["profile"] = self.current_profile
        return request

    def handle_request(self, request):
        validated = self._validate_schema(request)
        kind = validated["type"]
        if kind == "config":
            return self._handle_config_request(validated)
        if kind == "query":
            return self._process_query(validated)
        if kind == "restore_history":
            return self._handle_restore_history(validated)
        return {
            "instance_id": self.instance_id,
            "type": "error",
            "message": f"未知请求类型: {kind}",
            "status": "error",
            "error_code": "UNKNOWN_REQUEST_TYPE"
        }

    def _handle_config_request(self, request):
        action = request.get("action")
        if action == "set_profile":
            profile = request.get("profile", "default")
            if profile in ["high", "low", "default"]:
                old = self.current_profile
                self.current_profile = profile
                self._log_config_change("profile", old, profile)
                return {
                    "instance_id": self.instance_id,
                    "type": "config_response",
                    "action": action,
                    "profile": profile,
                    "status": "success",
                    "message": f"Profile已更新为{profile}"
                }
            return {
                "instance_id": self.instance_id,
                "type": "error",
                "message": f"无效的profile: {profile}",
                "status": "error",
                "error_code": "INVALID_PROFILE"
            }
        if action == "set_reasoning":
            new_state = bool(request.get("show_reasoning", False))
            old = self.show_reasoning
            self.show_reasoning = new_state
            self._log_config_change("show_reasoning", old, new_state)
            return {
                "instance_id": self.instance_id,
                "type": "config_response",
                "action": action,
                "show_reasoning": new_state,
                "status": "success",
                "message": f"Show Reasoning 已{ '开启' if new_state else '关闭'}"
            }
        if action == "set_output_format":
            new_format = request.get("output_format", "final_only")
            if new_format not in ["final_only", "final_with_details"]:
                return {
                    "instance_id": self.instance_id,
                    "type": "error",
                    "message": f"无效的输出格式: {new_format}",
                    "status": "error",
                    "error_code": "INVALID_OUTPUT_FORMAT"
                }
            old = self.output_format
            self.output_format = new_format
            self._log_config_change("output_format", old, new_format)
            return {
                "instance_id": self.instance_id,
                "type": "config_response",
                "action": action,
                "output_format": new_format,
                "status": "success",
                "message": f"Output Format 已切换为 {new_format}"
            }
        return {
            "instance_id": self.instance_id,
            "type": "error",
            "message": f"未知配置操作: {action}",
            "status": "error",
            "error_code": "UNKNOWN_CONFIG_ACTION"
        }

    def _process_query(self, request):
        profile = request["config"]["profile"]
        params = self._get_model_params_for_profile(profile)
        self.conversation_history.append({
            "role": "user",
            "content": request["message"],
            "timestamp": request["timestamp"],
            "profile": profile
        })
        response_text = self._call_codex_with_params(request["message"], params)
        self.conversation_history.append({
            "role": "assistant",
            "content": response_text,
            "timestamp": int(time.time()),
            "profile": profile
        })
        if len(self.conversation_history) > 200:
            self.conversation_history = self.conversation_history[-200:]
        return {
            "instance_id": self.instance_id,
            "type": "response",
            "message": response_text,
            "status": "success",
            "metadata": {
                "context_length": len(self.conversation_history),
                "active_profile": profile,
                "show_reasoning": self.show_reasoning,
                "output_format": self.output_format
            }
        }

    def _handle_restore_history(self, request):
        history = request.get("history", [])
        self.conversation_history = history
        profile = request.get("profile", self.current_profile)
        if profile in ["high", "low", "default"]:
            self.current_profile = profile
        self.show_reasoning = bool(request.get("show_reasoning", self.show_reasoning))
        output = request.get("output_format", self.output_format)
        if output in ["final_only", "final_with_details"]:
            self.output_format = output
        return {
            "instance_id": self.instance_id,
            "type": "restore_response",
            "message": f"已恢复 {len(history)} 条历史，当前profile: {self.current_profile}",
            "status": "success"
        }

    def _log_config_change(self, config_type, old, new):
        print(f"[Codex Config] {config_type}: {old} -> {new}")

    def _get_model_params_for_profile(self, profile):
        mapping = {
            "high": {"temperature": 0.1, "max_tokens": 4000, "top_p": 0.95},
            "low": {"temperature": 0.3, "max_tokens": 1000, "top_p": 0.9},
            "default": {"temperature": 0.2, "max_tokens": 2000, "top_p": 0.92}
        }
        return mapping.get(profile, mapping["default"])

    def _call_codex_with_params(self, message, params):
        # 真实实现中会调用模型推理，这里仅为示意
        depth = params.get("max_tokens")
        return f"模拟回答({depth} tokens): {message}"

    def _save_history(self):
        history_file = self.socket_path.replace('.sock', '-history.json')
        data = {
            "instance_id": self.instance_id,
            "conversation_history": self.conversation_history,
            "current_profile": self.current_profile,
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "saved_at": int(time.time())
        }
        with open(history_file, 'w') as f:
            json.dump(data, f, indent=2)
        os.chmod(history_file, 0o600)

    def _load_history_securely(self):
        history_file = self.socket_path.replace('.sock', '-history.json')
        if not os.path.exists(history_file):
            return
        with open(history_file, 'r') as f:
            data = json.load(f)
        if data.get("instance_id") != self.instance_id:
            return
        self.conversation_history = data.get("conversation_history", [])
        profile = data.get("current_profile", "default")
        if profile in ["high", "low", "default"]:
            self.current_profile = profile
        self.show_reasoning = bool(data.get("show_reasoning", False))
        output = data.get("output_format", "final_only")
        if output in ["final_only", "final_with_details"]:
            self.output_format = output
```
#### 3. Claude内部子进程架构
- **激活触发**：Claude内部检测到首次Codex命令时自动激活
- **进程生成**：Claude主进程fork()生成Codex子进程
- **实例绑定**：生成唯一instance_id，绑定socket路径和子进程PID
- **生命周期管理**：Claude完全控制Codex的启动、监控、停止和清理

##### Claude主导的生命周期管理：
```python
import json
import os
import socket
import time


class ClaudeCodexManager:
    def __init__(self):
        self.instance_id = None
        self.socket_path = None
        self.codex_pid = None
        self.history_file = None
        self.codex_active = False
        self.current_profile = "default"  # 添加profile状态
        self.show_reasoning = False       # 是否在Claude侧展示推理
        self.output_format = "final_only" # 输出模式: final_only/final_with_details

    def auto_activate_on_first_use(self):
        """首次使用时自动激活"""
        if not self.codex_active:
            self.instance_id = self._generate_instance_id()
            self.socket_path = f"/tmp/codex-{os.getppid()}-{self.instance_id}.sock"
            self.history_file = self.socket_path.replace('.sock', '-history.json')

            # fork()创建子进程
            self.codex_pid = os.fork()
            if self.codex_pid == 0:  # 子进程
                self._run_codex_child_process()
                os._exit(0)
            else:  # Claude父进程
                self.codex_active = True
                self._setup_child_monitor()

    def send_to_codex(self, message):
        """向Codex实例发送查询"""
        if not self.codex_active:
            self.auto_activate_on_first_use()

        request = {
            "instance_id": self.instance_id,
            "type": "query",
            "message": message,
            "config": {
                "profile": self.current_profile,
                "show_reasoning": self.show_reasoning,
                "output_format": self.output_format
            },
            "timestamp": int(time.time())
        }

        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.send(json.dumps(request).encode())
            response = json.loads(sock.recv(4096).decode())
            sock.close()
            if response.get("instance_id") != self.instance_id:
                raise RuntimeError("实例ID不匹配")
            return response
        except Exception as exc:
            raise RuntimeError(f"与Codex通信失败: {exc}")


    def _run_codex_child_process(self):
        """子进程中运行Codex服务"""
        # 启动Codex守护进程，监听专用socket
        from codex_process import CodexProcess
        codex = CodexProcess(self.socket_path, self.instance_id)
        codex.run()

    def _setup_child_monitor(self):
        """设置子进程监控"""
        import threading
        import os

        def monitor_child():
            while self.codex_active:
                try:
                    # 检查子进程状态
                    os.waitpid(self.codex_pid, os.WNOHANG)
                except OSError:
                    # 子进程异常退出，Claude重新拉起
                    print("Codex进程异常退出，正在重新启动...")
                    self._restart_codex_process()
                    break
                time.sleep(2)

        monitor_thread = threading.Thread(target=monitor_child, daemon=True)
        monitor_thread.start()

    def claude_cleanup_on_exit(self):
        """Claude退出时统一回收资源"""
        if self.codex_active and self.codex_pid:
            try:
                # 发送SIGTERM信号让Codex优雅退出
                os.kill(self.codex_pid, signal.SIGTERM)
                os.waitpid(self.codex_pid, 0)  # 等待子进程退出

                # 清理文件资源
                if os.path.exists(self.socket_path):
                    os.unlink(self.socket_path)
                if os.path.exists(self.history_file):
                    # 保留历史文件供下次启动使用
                    pass

                self.codex_active = False
            except:
                pass  # 退出时忽略清理错误
```

#### 4. Claude主导的持久化和恢复逻辑

##### 持久化策略：
- **Claude触发保存**：Claude退出时通知Codex保存对话历史
- **信号处理保存**：Codex收到SIGTERM时自动保存
- **内存限制管理**：超出100轮对话时删除最旧记录
- **实例关联存储**：历史文件包含instance_id，确保恢复正确性

##### Claude主导的恢复逻辑：
```python
class ClaudeCodexManager:
    def _restart_codex_process(self):
        """Claude重新拉起异常退出的Codex进程"""
        print(f"正在重启Codex实例 {self.instance_id}...")

        # 保存旧进程的状态（包括对话历史和profile）
        old_state = {}
        if os.path.exists(self.history_file):
            try:
                with open(self.history_file, 'r') as f:
                    old_data = json.load(f)
                    if old_data.get("instance_id") == self.instance_id:
                        old_state = {
                            "conversation_history": old_data.get("conversation_history", []),
                            "current_profile": old_data.get("current_profile", "default"),
                            "show_reasoning": old_data.get("show_reasoning", False),
                            "output_format": old_data.get("output_format", "final_only")
                        }
                        # 恢复Claude端状态
                        self.current_profile = old_state["current_profile"]
                        self.show_reasoning = old_state["show_reasoning"]
                        self.output_format = old_state["output_format"]
            except:
                pass

        # 重新fork子进程
        self.codex_pid = os.fork()
        if self.codex_pid == 0:  # 新子进程
            self._run_codex_child_process()
            os._exit(0)
        else:  # Claude父进程
            self._setup_child_monitor()

        # 等待新进程启动并恢复状态
        time.sleep(1)
        self._restore_conversation_state(old_state)

    def _restore_conversation_state(self, state):
        """恢复对话状态（历史+profile）"""
        if not state:
            return

        try:
            restore_request = {
                "instance_id": self.instance_id,
                "type": "restore_history",
                "history": state.get("conversation_history", []),
                "profile": state.get("current_profile", "default"),
                "show_reasoning": state.get("show_reasoning", False),
                "output_format": state.get("output_format", "final_only"),
                "timestamp": int(time.time())
            }

            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.send(json.dumps(restore_request).encode())
            response = json.loads(sock.recv(4096).decode())
            sock.close()

            if response.get("status") == "success":
                history_count = len(state.get("conversation_history", []))
                profile = state.get("current_profile", "default")
                reasoning = state.get("show_reasoning", False)
                output_format = state.get("output_format", "final_only")
                print(f"已恢复 {history_count} 条对话历史，Profile: {profile}, ShowReasoning: {reasoning}, OutputFormat: {output_format}")
            else:
                print("状态恢复失败")
        except Exception as e:
            print(f"恢复状态时出错: {e}")

    def get_detailed_status(self):
        """获取详细状态信息"""
        if not self.codex_active:
            return {}

        uptime = int(time.time()) - getattr(self, 'start_time', time.time())
        conversation_count = len(self._load_conversation_count())

        return {
            "instance_id": self.instance_id,
            "current_profile": self.current_profile,
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "conversation_count": conversation_count,
            "uptime": uptime,
            "socket_path": self.socket_path,
            "codex_pid": self.codex_pid
        }

    def get_current_config(self):
        """获取当前配置"""
        return {
            "profile": self.current_profile,
            "instance_id": self.instance_id,
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "conversation_count": len(self._load_conversation_count())
        }

    def _load_conversation_count(self):
        """加载对话计数"""
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    data = json.load(f)
                    return data.get("conversation_history", [])
        except:
            pass
        return []

    def _send_config_command(self, payload):
        """统一发送配置指令"""
        if not self.codex_active:
            return {"status": "error", "message": "Codex未激活"}

        command = {
            "instance_id": self.instance_id,
            "type": "config",
            "timestamp": int(time.time())
        }
        command.update(payload)

        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.send(json.dumps(command).encode())
            response = json.loads(sock.recv(4096).decode())
            sock.close()
            return response
        except Exception as exc:
            return {"status": "error", "message": str(exc)}

    def set_profile(self, new_profile):
        """切换模型强度"""
        normalized = new_profile.lower()
        aliases = {"high": "high", "default": "default", "low": "low"}
        if normalized not in aliases:
            return "❌ 无效参数，请使用: high、default、low"

        if not self.codex_active:
            return "❌ Codex服务未激活，请先运行 /codex-start"

        response = self._send_config_command(
            {"action": "set_profile", "profile": aliases[normalized]}
        )
        if response.get("status") == "success":
            self.current_profile = aliases[normalized]
            return f"✅ Profile已更新为: {self.current_profile}"
        return f"❌ Profile更新失败: {response.get('message', '未知错误')}"

    def update_show_reasoning(self, state_token):
        """控制推理展示开关（on/off）"""
        if state_token not in ["on", "off"]:
            return "❌ 参数错误，使用 on 或 off"

        if not self.codex_active:
            return "❌ Codex服务未激活，请先运行 /codex-start"

        target = state_token == "on"
        response = self._send_config_command(
            {"action": "set_reasoning", "show_reasoning": target}
        )
        if response.get("status") == "success":
            self.show_reasoning = target
            label = "on" if target else "off"
            return f"✅ Show Reasoning 已设置为 {label}"
        return f"❌ 设置失败: {response.get('message', '未知错误')}"

    def update_output_format(self, state_token):
        """控制是否仅输出最终答案（on/off）"""
        if state_token not in ["on", "off"]:
            return "❌ 参数错误，使用 on 或 off"

        if not self.codex_active:
            return "❌ Codex服务未激活，请先运行 /codex-start"

        target = "final_only" if state_token == "on" else "final_with_details"
        response = self._send_config_command(
            {"action": "set_output_format", "output_format": target}
        )
        if response.get("status") == "success":
            self.output_format = target
            return f"✅ Output Format 已切换为 {target}"
        return f"❌ 设置失败: {response.get('message', '未知错误')}"

    def show_config(self):
        """以文本格式展示当前配置"""
        cfg = self.get_current_config()
        reasoning_flag = "on" if cfg["show_reasoning"] else "off"
        output_flag = cfg["output_format"]
        output_desc = "final_only" if output_flag == "final_only" else "final_with_details"
        return (
            "📋 当前配置:\n"
            f"• Profile: {cfg['profile']} ({self._describe_profile(cfg['profile'])})\n"
            f"• Instance ID: {cfg.get('instance_id') or '尚未创建（服务未激活）'}\n"
            f"• Show Reasoning: {reasoning_flag}  (on=输出推理摘要；off=仅内部使用)\n"
            f"• Output Format: {output_desc}  (final_only=只输出最终答案)\n"
            f"• 历史轮次: {cfg['conversation_count']}"
        )

    def show_status(self):
        """以文本格式展示运行状态"""
        if not self.codex_active:
            return "❌ Codex服务未运行"

        status = self.get_detailed_status()
        return (
            "✅ Codex服务运行中:\n"
            f"• 实例ID: {status['instance_id']}\n"
            f"• 当前Profile: {status['current_profile']}\n"
            f"• Show Reasoning: {'on' if status['show_reasoning'] else 'off'}\n"
            f"• Output Format: {status['output_format']}\n"
            f"• 对话轮次: {status['conversation_count']}\n"
            f"• 进程PID: {status['codex_pid']}\n"
            f"• Socket: {status['socket_path']}"
        )

    def _describe_profile(self, profile):
        mapping = {
            "high": "深度分析",
            "default": "平衡模式",
            "low": "简洁快速"
        }
        return mapping.get(profile, "平衡模式")
```

##### Codex子进程的持久化处理：
```python
class CodexProcess:
    def __init__(self, socket_path, instance_id):
        self.socket_path = socket_path
        self.instance_id = instance_id
        self.conversation_history = []

        # 注册信号处理器
        signal.signal(signal.SIGTERM, self._graceful_shutdown)

    def _graceful_shutdown(self, signum, frame):
        """Claude发起的优雅退出，保存数据"""
        self._save_history()
        exit(0)

    def _save_history(self):
        """保存包含实例ID和profile状态的对话历史"""
        history_file = self.socket_path.replace('.sock', '-history.json')
        history_data = {
            "instance_id": self.instance_id,
            "conversation_history": self.conversation_history,
            "current_profile": self.current_profile,  # 保存当前profile
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "saved_at": int(time.time()),
            "version": "1.0"
        }

        with open(history_file, 'w') as f:
            json.dump(history_data, f, indent=2)

        # 设置文件权限为用户私有
        os.chmod(history_file, 0o600)

    def _load_history_securely(self):
        """安全加载历史记录，包括profile状态"""
        history_file = self.socket_path.replace('.sock', '-history.json')

        if os.path.exists(history_file):
            # 验证文件权限
            file_stat = os.stat(history_file)
            if file_stat.st_uid != os.getuid():
                print("警告：历史文件所有者不正确，跳过加载")
                return

            if file_stat.st_mode & 0o077 != 0:
                print("警告：历史文件权限过于开放，跳过加载")
                return

            try:
                with open(history_file, 'r') as f:
                    data = json.load(f)

                # 验证数据包含正确的instance_id
                if data.get("instance_id") == self.instance_id:
                    self.conversation_history = data.get("conversation_history", [])
                    # 恢复profile状态
                    saved_profile = data.get("current_profile", "default")
                    if saved_profile in ["high", "low", "default"]:
                        self.current_profile = saved_profile
                        print(f"已恢复profile: {saved_profile}")
                    # 恢复推理与输出开关
                    self.show_reasoning = bool(data.get("show_reasoning", False))
                    saved_format = data.get("output_format", "final_only")
                    if saved_format in ["final_only", "final_with_details"]:
                        self.output_format = saved_format
                else:
                    print("警告：历史文件instance_id不匹配，跳过加载")

            except Exception as e:
                print(f"警告：加载历史文件失败: {e}")

    def _handle_restore_history(self, request):
        """处理历史恢复请求"""
        history = request.get("history", [])
        self.conversation_history = history

        requested_profile = request.get("profile")
        if requested_profile in ["high", "low", "default"]:
            self.current_profile = requested_profile
        elif history:
            for entry in reversed(history[-10:]):
                if entry.get("role") == "assistant" and entry.get("profile") in ["high", "low", "default"]:
                    self.current_profile = entry["profile"]
                    break

        self.show_reasoning = bool(request.get("show_reasoning", self.show_reasoning))
        requested_output = request.get("output_format", self.output_format)
        if requested_output in ["final_only", "final_with_details"]:
            self.output_format = requested_output

        return {
            "instance_id": self.instance_id,
            "type": "restore_response",
            "message": f"已恢复 {len(history)} 条历史，当前profile: {self.current_profile}",
            "status": "success"
        }

    def handle_request(self, request):
        """处理请求，支持历史恢复"""
        if request.get("type") == "restore_history":
            # Claude重启时恢复对话历史
            self.conversation_history = request.get("history", [])
            return {
                "instance_id": self.instance_id,
                "type": "restore_response",
                "message": f"已恢复 {len(self.conversation_history)} 条历史",
                "status": "success"
            }

        elif request.get("type") == "query":
            # 正常对话请求
            self.conversation_history.append({
                "role": "user",
                "content": request["message"],
                "timestamp": request["timestamp"]
            })

            # 处理并获得响应
            response_text = self._process_query(request["message"])

            self.conversation_history.append({
                "role": "assistant",
                "content": response_text,
                "timestamp": int(time.time())
            })

            # 内存管理：保持最新100轮对话
            if len(self.conversation_history) > 200:  # 100轮对话 = 200条消息
                self.conversation_history = self.conversation_history[-200:]

            return {
                "instance_id": self.instance_id,
                "type": "response",
                "message": response_text,
                "status": "success",
                "metadata": {
                    "context_length": len(self.conversation_history)
                }
            }
```

## 实现组件

### 1. Claude Codex管理器 (集成在Claude中)
```python
# codex_manager.py (Claude内部模块)
import os
import uuid
import signal
import subprocess
import socket
import json

#### 3. Claude内部子进程架构
- **激活触发**：Claude内部检测到首次Codex命令时自动激活
- **进程生成**：Claude主进程fork()生成Codex子进程
- **实例绑定**：生成唯一instance_id，绑定socket路径和子进程PID
- **生命周期管理**：Claude完全控制Codex的启动、监控、停止和清理

##### Claude主导的生命周期管理：
```python
class ClaudeCodexManager:
    def __init__(self):
        self.instance_id = None
        self.socket_path = None
        self.codex_pid = None
        self.history_file = None
        self.codex_active = False
        self.current_profile = "default"  # 添加profile状态
        self.show_reasoning = False       # 是否在Claude侧展示推理
        self.output_format = "final_only" # 输出模式: final_only/final_with_details

    def auto_activate_on_first_use(self):
        """首次使用时自动激活"""
        if not self.codex_active:
            self.instance_id = self._generate_instance_id()
            self.socket_path = f"/tmp/codex-{os.getppid()}-{self.instance_id}.sock"
            self.history_file = self.socket_path.replace('.sock', '-history.json')

            # fork()创建子进程
            self.codex_pid = os.fork()
            if self.codex_pid == 0:  # 子进程
                self._run_codex_child_process()
                os._exit(0)
            else:  # Claude父进程
                self.codex_active = True
                self._setup_child_monitor()

    def _run_codex_child_process(self):
        """子进程中运行Codex服务"""
        # 启动Codex守护进程，监听专用socket
        from codex_process import CodexProcess
        codex = CodexProcess(self.socket_path, self.instance_id)
        codex.run()

    def _setup_child_monitor(self):
        """设置子进程监控"""
        import threading
        import os

        def monitor_child():
            while self.codex_active:
                try:
                    # 检查子进程状态
                    os.waitpid(self.codex_pid, os.WNOHANG)
                except OSError:
                    # 子进程异常退出，Claude重新拉起
                    print("Codex进程异常退出，正在重新启动...")
                    self._restart_codex_process()
                    break
                time.sleep(2)

        monitor_thread = threading.Thread(target=monitor_child, daemon=True)
        monitor_thread.start()

    def claude_cleanup_on_exit(self):
        """Claude退出时统一回收资源"""
        if self.codex_active and self.codex_pid:
            try:
                # 发送SIGTERM信号让Codex优雅退出
                os.kill(self.codex_pid, signal.SIGTERM)
                os.waitpid(self.codex_pid, 0)  # 等待子进程退出

                # 清理文件资源
                if os.path.exists(self.socket_path):
                    os.unlink(self.socket_path)
                if os.path.exists(self.history_file):
                    # 保留历史文件供下次启动使用
                    pass

                self.codex_active = False
            except:
                pass  # 退出时忽略清理错误
```

#### 4. Claude主导的持久化和恢复逻辑

##### 持久化策略：
- **Claude触发保存**：Claude退出时通知Codex保存对话历史
- **信号处理保存**：Codex收到SIGTERM时自动保存
- **内存限制管理**：超出100轮对话时删除最旧记录
- **实例关联存储**：历史文件包含instance_id，确保恢复正确性

##### Claude主导的恢复逻辑：
```python
class ClaudeCodexManager:
    def _restart_codex_process(self):
        """Claude重新拉起异常退出的Codex进程"""
        print(f"正在重启Codex实例 {self.instance_id}...")

        # 保存旧进程的状态（包括对话历史和profile）
        old_state = {}
        if os.path.exists(self.history_file):
            try:
                with open(self.history_file, 'r') as f:
                    old_data = json.load(f)
                    if old_data.get("instance_id") == self.instance_id:
                        old_state = {
                            "conversation_history": old_data.get("conversation_history", []),
                            "current_profile": old_data.get("current_profile", "default"),
                            "show_reasoning": old_data.get("show_reasoning", False),
                            "output_format": old_data.get("output_format", "final_only")
                        }
                        # 恢复Claude端状态
                        self.current_profile = old_state["current_profile"]
                        self.show_reasoning = old_state["show_reasoning"]
                        self.output_format = old_state["output_format"]
            except:
                pass

        # 重新fork子进程
        self.codex_pid = os.fork()
        if self.codex_pid == 0:  # 新子进程
            self._run_codex_child_process()
            os._exit(0)
        else:  # Claude父进程
            self._setup_child_monitor()

        # 等待新进程启动并恢复状态
        time.sleep(1)
        self._restore_conversation_state(old_state)

    def _restore_conversation_state(self, state):
        """恢复对话状态（历史+profile）"""
        if not state:
            return

        try:
            restore_request = {
                "instance_id": self.instance_id,
                "type": "restore_history",
                "history": state.get("conversation_history", []),
                "profile": state.get("current_profile", "default"),
                "timestamp": int(time.time())
            }

            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.send(json.dumps(restore_request).encode())
            response = json.loads(sock.recv(4096).decode())
            sock.close()

            if response.get("status") == "success":
                history_count = len(state.get("conversation_history", []))
                profile = state.get("current_profile", "default")
                print(f"已恢复 {history_count} 条对话历史，Profile: {profile}")
            else:
                print("状态恢复失败")
        except Exception as e:
            print(f"恢复状态时出错: {e}")

    def get_detailed_status(self):
        """获取详细状态信息"""
        if not self.codex_active:
            return {}

        uptime = int(time.time()) - getattr(self, 'start_time', time.time())
        conversation_count = len(self._load_conversation_count())

        return {
            "instance_id": self.instance_id,
            "current_profile": self.current_profile,
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "conversation_count": conversation_count,
            "uptime": uptime,
            "socket_path": self.socket_path,
            "codex_pid": self.codex_pid
        }

    def get_current_config(self):
        """获取当前配置"""
        return {
            "profile": self.current_profile,
            "instance_id": self.instance_id,
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "conversation_count": len(self._load_conversation_count())
        }

    def _load_conversation_count(self):
        """加载对话计数"""
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    data = json.load(f)
                    return data.get("conversation_history", [])
        except:
            pass
        return []

    def _send_config_command(self, payload):
        """统一发送配置指令"""
        if not self.codex_active:
            return {"status": "error", "message": "Codex未激活"}

        command = {
            "instance_id": self.instance_id,
            "type": "config",
            "timestamp": int(time.time())
        }
        command.update(payload)

        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.send(json.dumps(command).encode())
            response = json.loads(sock.recv(4096).decode())
            sock.close()
            return response
        except Exception as exc:
            return {"status": "error", "message": str(exc)}

    def set_profile(self, new_profile):
        """切换模型强度"""
        normalized = new_profile.lower()
        aliases = {"high": "high", "default": "default", "low": "low"}
        if normalized not in aliases:
            return "❌ 无效参数，请使用: high、default、low"

        if not self.codex_active:
            return "❌ Codex服务未激活，请先运行 /codex-start"

        response = self._send_config_command(
            {"action": "set_profile", "profile": aliases[normalized]}
        )
        if response.get("status") == "success":
            self.current_profile = aliases[normalized]
            return f"✅ Profile已更新为: {self.current_profile}"
        return f"❌ Profile更新失败: {response.get('message', '未知错误')}"

    def update_show_reasoning(self, state_token):
        """控制推理展示开关（on/off）"""
        if state_token not in ["on", "off"]:
            return "❌ 参数错误，使用 on 或 off"

        if not self.codex_active:
            return "❌ Codex服务未激活，请先运行 /codex-start"

        target = state_token == "on"
        response = self._send_config_command(
            {"action": "set_reasoning", "show_reasoning": target}
        )
        if response.get("status") == "success":
            self.show_reasoning = target
            label = "on" if target else "off"
            return f"✅ Show Reasoning 已设置为 {label}"
        return f"❌ 设置失败: {response.get('message', '未知错误')}"

    def update_output_format(self, state_token):
        """控制是否仅输出最终答案（on/off）"""
        if state_token not in ["on", "off"]:
            return "❌ 参数错误，使用 on 或 off"

        if not self.codex_active:
            return "❌ Codex服务未激活，请先运行 /codex-start"

        target = "final_only" if state_token == "on" else "final_with_details"
        response = self._send_config_command(
            {"action": "set_output_format", "output_format": target}
        )
        if response.get("status") == "success":
            self.output_format = target
            return f"✅ Output Format 已切换为 {target}"
        return f"❌ 设置失败: {response.get('message', '未知错误')}"

    def show_config(self):
        """以文本格式展示当前配置"""
        cfg = self.get_current_config()
        reasoning_flag = "on" if cfg["show_reasoning"] else "off"
        output_flag = cfg["output_format"]
        output_desc = "final_only" if output_flag == "final_only" else "final_with_details"
        return (
            "📋 当前配置:\n"
            f"• Profile: {cfg['profile']} ({self._describe_profile(cfg['profile'])})\n"
            f"• Instance ID: {cfg.get('instance_id') or '尚未创建（服务未激活）'}\n"
            f"• Show Reasoning: {reasoning_flag}  (on=输出推理摘要；off=仅内部使用)\n"
            f"• Output Format: {output_desc}  (final_only=只输出最终答案)\n"
            f"• 历史轮次: {cfg['conversation_count']}"
        )

    def show_status(self):
        """以文本格式展示运行状态"""
        if not self.codex_active:
            return "❌ Codex服务未运行"

        status = self.get_detailed_status()
        return (
            "✅ Codex服务运行中:\n"
            f"• 实例ID: {status['instance_id']}\n"
            f"• 当前Profile: {status['current_profile']}\n"
            f"• Show Reasoning: {'on' if status['show_reasoning'] else 'off'}\n"
            f"• Output Format: {status['output_format']}\n"
            f"• 对话轮次: {status['conversation_count']}\n"
            f"• 进程PID: {status['codex_pid']}\n"
            f"• Socket: {status['socket_path']}"
        )

    def _describe_profile(self, profile):
        mapping = {
            "high": "深度分析",
            "default": "平衡模式",
            "low": "简洁快速"
        }
        return mapping.get(profile, "平衡模式")

    def _restore_conversation_history(self, history):
        """恢复对话历史到新进程"""
        if history:
            restore_request = {
                "instance_id": self.instance_id,
                "type": "restore_history",
                "history": history,
                "timestamp": int(time.time())
            }

            try:
                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                sock.connect(self.socket_path)
                sock.send(json.dumps(restore_request).encode())
                sock.close()
                print(f"已恢复 {len(history)} 条对话历史")
            except:
                print("恢复对话历史失败")
```

##### Codex子进程的持久化处理：
```python
class CodexProcess:
    def __init__(self, socket_path, instance_id):
        self.socket_path = socket_path
        self.instance_id = instance_id
        self.conversation_history = []

        # 注册信号处理器
        signal.signal(signal.SIGTERM, self._graceful_shutdown)

    def _graceful_shutdown(self, signum, frame):
        """Claude发起的优雅退出，保存数据"""
        self._save_history()
        exit(0)

    def _save_history(self):
        """保存包含实例ID和profile状态的对话历史"""
        history_file = self.socket_path.replace('.sock', '-history.json')
        history_data = {
            "instance_id": self.instance_id,
            "conversation_history": self.conversation_history,
            "current_profile": self.current_profile,  # 保存当前profile
            "saved_at": int(time.time()),
            "version": "1.0"
        }

        with open(history_file, 'w') as f:
            json.dump(history_data, f, indent=2)

        # 设置文件权限为用户私有
        os.chmod(history_file, 0o600)

    def _load_history_securely(self):
        """安全加载历史记录，包括profile状态"""
        history_file = self.socket_path.replace('.sock', '-history.json')

        if os.path.exists(history_file):
            # 验证文件权限
            file_stat = os.stat(history_file)
            if file_stat.st_uid != os.getuid():
                print("警告：历史文件所有者不正确，跳过加载")
                return

            if file_stat.st_mode & 0o077 != 0:
                print("警告：历史文件权限过于开放，跳过加载")
                return

            try:
                with open(history_file, 'r') as f:
                    data = json.load(f)

                # 验证数据包含正确的instance_id
                if data.get("instance_id") == self.instance_id:
                    self.conversation_history = data.get("conversation_history", [])
                    # 恢复profile状态
                    saved_profile = data.get("current_profile", "default")
                    if saved_profile in ["high", "low", "default"]:
                        self.current_profile = saved_profile
                        print(f"已恢复profile: {saved_profile}")
                else:
                    print("警告：历史文件instance_id不匹配，跳过加载")

            except Exception as e:
                print(f"警告：加载历史文件失败: {e}")

    def _handle_restore_history(self, request):
        """处理历史恢复请求"""
        # Claude重启时恢复对话历史和profile
        history = request.get("history", [])
        self.conversation_history = history

        # 尝试从历史中恢复最后的profile状态
        if history:
            # 从最后几条对话中恢复profile
            for entry in reversed(history[-10:]):  # 查看最后10条记录
                if entry.get("role") == "assistant" and "profile" in entry:
                    self.current_profile = entry["profile"]
                    break

        return {
            "instance_id": self.instance_id,
            "type": "restore_response",
            "message": f"已恢复 {len(history)} 条历史，当前profile: {self.current_profile}",
            "status": "success"
        }

    def handle_request(self, request):
        """处理请求，支持历史恢复"""
        if request.get("type") == "restore_history":
            # Claude重启时恢复对话历史
            self.conversation_history = request.get("history", [])
            return {
                "instance_id": self.instance_id,
                "type": "restore_response",
                "message": f"已恢复 {len(self.conversation_history)} 条历史",
                "status": "success"
            }

        elif request.get("type") == "query":
            # 正常对话请求
            self.conversation_history.append({
                "role": "user",
                "content": request["message"],
                "timestamp": request["timestamp"]
            })

            # 处理并获得响应
            response_text = self._process_query(request["message"])

            self.conversation_history.append({
                "role": "assistant",
                "content": response_text,
                "timestamp": int(time.time())
            })

            # 内存管理：保持最新100轮对话
            if len(self.conversation_history) > 200:  # 100轮对话 = 200条消息
                self.conversation_history = self.conversation_history[-200:]

            return {
                "instance_id": self.instance_id,
                "type": "response",
                "message": response_text,
                "status": "success",
                "metadata": {
                    "context_length": len(self.conversation_history)
                }
            }
```

## 实现组件

### 1. Claude Codex管理器 (集成在Claude中)
```python
# codex_manager.py (Claude内部模块)
import os
import uuid
import signal
import subprocess
import socket
import json

### 2. Codex子进程 (codex_process.py)
```python
#!/usr/bin/env python3
import socket
import json
import os
import signal
import sys

class CodexProcess:
    def __init__(self, socket_path, instance_id):
        self.socket_path = socket_path
        self.instance_id = instance_id
        self.conversation_history = []
        self.current_profile = "default"  # Codex维护当前profile状态
        self.running = True

        # 注册信号处理器
        signal.signal(signal.SIGTERM, self.signal_handler)

    def signal_handler(self, signum, frame):
        """优雅退出"""
        self.save_history()
        exit(0)

    def run(self):
        """主循环"""
        # 加载历史记录
        self.load_history()

        # 创建Socket
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(self.socket_path)
        sock.listen(1)
        os.chmod(self.socket_path, 0o600)  # 用户私有权限

        # 处理请求
        while self.running:
            try:
                conn, addr = sock.accept()
                data = conn.recv(4096).decode()
                if data:
                    response = self.handle_request(json.loads(data))
                    conn.send(json.dumps(response).encode())
                conn.close()
            except:
                break

        sock.close()

    def handle_request(self, request):
        """处理请求，支持配置管理和profile"""
        try:
            # Schema校验和默认值设置
            validated_request = self._validate_schema(request)
        except ValueError as e:
            return {
                "instance_id": self.instance_id,
                "type": "error",
                "message": str(e),
                "status": "error",
                "error_code": "VALIDATION_ERROR"
            }

        # 处理不同类型的请求
        if validated_request["type"] == "config":
            return self._handle_config_request(validated_request)
        elif validated_request["type"] == "query":
            return self._process_query(validated_request)
        elif validated_request["type"] == "restore_history":
            return self._handle_restore_history(validated_request)
        else:
            return {
                "instance_id": self.instance_id,
                "type": "error",
                "message": f"未知请求类型: {validated_request['type']}",
                "status": "error",
                "error_code": "UNKNOWN_REQUEST_TYPE"
            }

    def _validate_schema(self, request):
        """Schema校验与默认值设置"""
        required_fields = ["instance_id", "type", "timestamp"]
        for field in required_fields:
            if field not in request:
                raise ValueError(f"缺少必需字段: {field}")

        # 验证instance_id
        if request["instance_id"] != self.instance_id:
            raise ValueError("实例ID不匹配")

        # 设置config默认值
        if "config" not in request:
            request["config"] = {}

        config_defaults = {
            "show_reasoning": False,
            "output_format": "final_only",
            "profile": "default"
        }

        for key, default_value in config_defaults.items():
            if key not in request["config"]:
                request["config"][key] = default_value

        # 验证profile值
        valid_profiles = ["high", "low", "default"]
        if request["config"]["profile"] not in valid_profiles:
            request["config"]["profile"] = "default"

        return request

    def _handle_config_request(self, request):
        """处理配置变更请求"""
        action = request.get("action")

        if action == "set_profile":
            new_profile = request.get("profile", "default")
            if new_profile in ["high", "low", "default"]:
                old_profile = self.current_profile
                self.current_profile = new_profile

                # 记录配置变更日志
                self._log_config_change("profile", old_profile, new_profile)

                return {
                    "instance_id": self.instance_id,
                    "type": "config_response",
                    "action": "set_profile",
                    "profile": new_profile,
                    "status": "success",
                    "message": f"Profile已更新为{new_profile}"
                }
            else:
                return {
                    "instance_id": self.instance_id,
                    "type": "error",
                    "message": f"无效的profile: {new_profile}",
                    "status": "error",
                    "error_code": "INVALID_PROFILE"
                }
        else:
            return {
                "instance_id": self.instance_id,
                "type": "error",
                "message": f"未知配置操作: {action}",
                "status": "error",
                "error_code": "UNKNOWN_CONFIG_ACTION"
            }

    def _log_config_change(self, config_type, old_value, new_value):
        """记录配置变更日志"""
        print(f"[Codex Config] {config_type}: {old_value} -> {new_value}")

    def _process_query(self, request):
        """处理查询请求，考虑当前profile"""
        config = request["config"]
        profile = config.get("profile", self.current_profile)

        # 根据profile调整模型参数
        model_params = self._get_model_params_for_profile(profile)

        # 添加到对话历史
        self.conversation_history.append({
            "role": "user",
            "content": request["message"],
            "timestamp": request["timestamp"],
            "profile": profile
        })

        # 处理并获得响应（使用profile对应的参数）
        response_text = self._call_codex_with_params(request["message"], model_params)

        self.conversation_history.append({
            "role": "assistant",
            "content": response_text,
            "timestamp": int(time.time()),
            "profile": profile
        })

        # 内存管理：保持最新100轮对话
        if len(self.conversation_history) > 200:
            self.conversation_history = self.conversation_history[-200:]

        return {
            "instance_id": self.instance_id,
            "type": "response",
            "message": response_text,
            "status": "success",
            "metadata": {
                "context_length": len(self.conversation_history),
                "active_profile": profile
            }
        }

    def _get_model_params_for_profile(self, profile):
        """根据profile获取模型参数"""
        profile_params = {
            "high": {
                "temperature": 0.1,
                "max_tokens": 4000,
                "top_p": 0.95,
                "reasoning_depth": "deep"
            },
            "low": {
                "temperature": 0.3,
                "max_tokens": 1000,
                "top_p": 0.9,
                "reasoning_depth": "shallow"
            },
            "default": {
                "temperature": 0.2,
                "max_tokens": 2000,
                "top_p": 0.92,
                "reasoning_depth": "medium"
            }
        }

        return profile_params.get(profile, profile_params["default"])

    def _call_codex_with_params(self, message, params):
        """使用指定参数调用Codex"""
        # 这里调用真正的Codex API，使用params中的参数
        # response = call_codex_api(message, **params)

        # 模拟响应，根据profile调整回答长度和详细程度
        profile = params.get("reasoning_depth", "medium")
        if profile == "deep":
            return f"详细的深度回答: {message} (使用high profile参数)"
        elif profile == "shallow":
            return f"简洁回答: {message} (使用low profile参数)"
        else:
            return f"平衡回答: {message} (使用default profile参数)"

    def _handle_restore_history(self, request):
        """处理历史恢复请求"""
        # Claude重启时恢复对话历史和profile
        history = request.get("history", [])
        profile = request.get("profile", "default")
        self.conversation_history = history
        self.current_profile = profile

        return {
            "instance_id": self.instance_id,
            "type": "restore_response",
            "message": f"已恢复 {len(history)} 条历史，当前profile: {self.current_profile}",
            "status": "success"
        }

    def load_history(self):
        """加载历史"""
        history_file = self.socket_path.replace('.sock', '-history.json')
        if os.path.exists(history_file):
            try:
                with open(history_file, 'r') as f:
                    self.conversation_history = json.load(f)
            except:
                pass

    def save_history(self):
        """保存历史"""
        history_file = self.socket_path.replace('.sock', '-history.json')
        with open(history_file, 'w') as f:
            json.dump(self.conversation_history, f)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        sys.exit(1)

    # 参数: socket_path
    socket_path = sys.argv[1]
    # 从socket_path中提取instance_id
    instance_id = socket_path.split('/')[-1].replace('.sock', '').split('-')[-1]

    codex = CodexProcess(socket_path, instance_id)
    codex.run()
```

### 3. 简化诊断工具（仅用于问题排查）
```bash
#!/bin/bash
# codex-status - 系统级诊断工具

show_codex_status() {
    echo "=== Codex服务状态 ==="

    # 查找所有Codex相关进程
    codex_processes=$(ps aux | grep codex_process | grep -v grep)
    if [ -n "$codex_processes" ]; then
        echo "运行中的Codex进程："
        echo "$codex_processes"
    else
        echo "无运行中的Codex进程"
    fi

    # 查找Socket文件
    echo -e "\n=== Socket文件 ==="
    socket_files=$(ls -la /tmp/codex-*.sock 2>/dev/null)
    if [ -n "$socket_files" ]; then
        echo "$socket_files"
    else
        echo "无Socket文件"
    fi

    # 查找历史文件
    echo -e "\n=== 历史文件 ==="
    history_files=$(ls -la /tmp/codex-*-history.json 2>/dev/null)
    if [ -n "$history_files" ]; then
        echo "$history_files"
    else
        echo "无历史文件"
    fi

    # 显示当前Claude进程信息
    echo -e "\n=== 当前进程信息 ==="
    echo "Claude PID: $$"
    echo "父进程 PID: $(ps -o ppid= -p $$)"
}

show_codex_status
```

## Claude内部集成方案

### 完整的Claude内部集成
```python
# claude_codex_integration.py
import os
import atexit
import signal

class ClaudeCodexIntegration:
    def __init__(self):
        self.codex_manager = None
        self.codex_active = False

        # 注册退出清理函数
        atexit.register(self._cleanup_on_exit)
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)

    def _signal_handler(self, signum, frame):
        """处理退出信号"""
        self._cleanup_on_exit()
        exit(0)

    def _cleanup_on_exit(self):
        """Claude退出时自动清理"""
        if self.codex_active:
            self.codex_manager.cleanup()
            self.codex_active = False

    def handle_command(self, command):
        """统一命令处理入口，支持配置管理"""
        # 自动激活逻辑
        keyword = command.strip().split()[0] if command.strip() else command
        if keyword.startswith("/codex-") and not self.codex_active:
            allowed_when_inactive = {"/codex-start", "/codex-help", "/codex-config"}
            if keyword not in allowed_when_inactive:
                return "❌ Codex服务未激活，请先运行 /codex-start 或输入 /codex-help 查看指引"

        # 命令路由
        if command == "/codex-start":
            return self._start_codex()
        elif command.startswith("/codex-ask"):
            return self._ask_codex(command)
        elif command == "/codex-stop":
            return self._stop_codex()
        elif command == "/codex-status":
            return self._get_status()
        elif command.startswith("/codex-config"):
            return self._handle_config_command(command)
        elif command.startswith("/codex-reasoning"):
            return self._toggle_reasoning(command)
        elif command.startswith("/codex-final_only"):
            return self._toggle_final_only(command)
        elif command == "/codex-help":
            return self._show_help()
        else:
            return f"❌ 未知命令: {command}"

    def _start_codex(self):
        """启动Codex服务"""
        if not self.codex_active:
            try:
                self.codex_manager = ClaudeCodexManager()
                self.codex_manager.start_codex_process()
                self.codex_active = True
                return f"✅ Codex服务已启动 (实例ID: {self.codex_manager.instance_id}, 默认Profile: default)"
            except Exception as e:
                return f"❌ 启动失败: {str(e)}"
        else:
            return f"ℹ️ Codex服务已在运行 (Profile: {self.codex_manager.current_profile})"

    def _ask_codex(self, command):
        """向Codex提问"""
        if not self.codex_active:
            return "❌ 请先运行 /codex-start 启动服务，或输入 /codex-help 查看指引"

        if command == "/codex-ask":
            return "❌ 请提供要询问的问题，用法: /codex-ask <你的问题>"

        question = command.replace("/codex-ask ", "").strip()
        if not question:
            return "❌ 问题内容不能为空"

        try:
            response = self.codex_manager.send_to_codex(question)
            profile = response.get("metadata", {}).get("active_profile", "default")
            return f"🤖 [Profile: {profile}]\n{response['message']}"
        except Exception as e:
            return f"❌ 请求失败: {str(e)}"

    def _stop_codex(self):
        """停止Codex服务"""
        if self.codex_active:
            instance_id = self.codex_manager.instance_id
            self.codex_manager.cleanup()
            self.codex_active = False
            return f"✅ Codex服务已停止 (实例ID: {instance_id})"
        else:
            return "ℹ️ Codex服务未运行"

    def _get_status(self):
        """获取服务状态"""
        if not self.codex_active:
            return "❌ Codex服务未运行"

        return f"""✅ Codex服务运行中:
• 实例ID: {self.codex_manager.instance_id}
• 当前Profile: {self.codex_manager.current_profile}
• 进程PID: {self.codex_manager.codex_pid}
• Socket: {self.codex_manager.socket_path}"""

    def _handle_config_command(self, command):
        """展示或更新核心配置（模型强度 + 输出格式）"""
        parts = command.strip().split()
        if len(parts) == 1:
            return self._show_config()

        if len(parts) != 2:
            return """❌ 参数错误
用法:
• /codex-config            # 查看当前配置
• /codex-config <high|default|low>  # 切换模型强度"""

        if not self.codex_active:
            return "❌ Codex服务未激活，请先运行 /codex-start，或输入 /codex-help 查看指引"

        target = parts[1].lower()
        aliases = {
            "high": "high",
            "low": "low",
            "default": "default",
            "medium": "default",
            "mid": "default",
            "normal": "default",
            "balanced": "default",
        }

        if target not in aliases:
            return "❌ 无效参数，请使用: high、default、low"

        resolved = aliases[target]

        try:
            result = self.codex_manager.set_profile(resolved)
            return f"""{result}

📋 模型强度说明:
• high: {self._get_profile_desc('high')} (温度 {self._get_profile_temp('high')} / 最大长度 {self._get_profile_tokens('high')})
• default: {self._get_profile_desc('default')} (温度 {self._get_profile_temp('default')} / 最大长度 {self._get_profile_tokens('default')})
• low: {self._get_profile_desc('low')} (温度 {self._get_profile_temp('low')} / 最大长度 {self._get_profile_tokens('low')})"""
        except Exception as e:
            return f"❌ 模型强度切换失败: {str(e)}"

    def _show_config(self):
        """显示当前配置"""
        manager = self.codex_manager
        profile = manager.current_profile if (manager and self.codex_active) else "default"
        reasoning = "on" if (manager and manager.show_reasoning) else "off"
        final_flag = manager.output_format if manager else "final_only"

        lines = [
            "📋 当前配置:",
            f"• Profile: {profile} ({self._get_profile_desc(profile)})",
        ]

        if manager and self.codex_active:
            lines.extend(
                [
                    f"• Instance ID: {manager.instance_id}",
                    f"• Socket: {manager.socket_path}",
                ]
            )
        else:
            lines.append("• Instance ID: 尚未创建（服务未激活）")

        lines.extend(
            [
                f"• Show Reasoning: {reasoning}  (on=输出推理摘要；off=仅内部使用)",
                f"• Output Format: {final_flag}  (final_only=只输出最终答案)",
            ]
        )

        return "\n".join(lines)

    def _toggle_reasoning(self, command):
        """开关推理可见性（不影响内部推理流程）"""
        parts = command.strip().split()
        if len(parts) != 2 or parts[1] not in ["on", "off"]:
            return """❌ 参数错误
用法: /codex-reasoning <on|off>
• on: 在Claude中展示推理摘要（可能暴露细节）
• off: 仅展示最终答案（推荐）"""

        if not self.codex_active:
            return "❌ Codex服务未激活，请先运行 /codex-start，或输入 /codex-help 查看指引"

        state_token = parts[1]
        self.codex_manager.update_show_reasoning(state_token)
        state = state_token == "on"
        label = state_token
        advice = "（建议关闭以保持输出纯净）" if state else "（已关闭推理展示）"
        return f"✅ Show Reasoning 已设置为 {label} {advice}"

    def _toggle_final_only(self, command):
        """控制是否仅输出最终答案"""
        parts = command.strip().split()
        if len(parts) != 2 or parts[1] not in ["on", "off"]:
            return """❌ 参数错误
用法: /codex-final_only <on|off>
• on: 仅返回最终答案（推荐）
• off: 返回最终答案及额外细节（用于调试）"""

        if not self.codex_active:
            return "❌ Codex服务未激活，请先运行 /codex-start，或输入 /codex-help 查看指引"

        state_token = parts[1]
        self.codex_manager.update_output_format(state_token)
        state = state_token == "on"
        label = "final_only" if state else "final_with_details"
        advice = "（推荐开启以避免额外噪音）" if state else "（将返回额外细节信息）"
        return f"✅ Output Format 已切换为 {label} {advice}"

    def _show_help(self):
        """显示命令帮助"""
        return (
            "📖 Codex命令帮助（Claude内置）\n"
            "• /codex-start\n"
            "  - 说明: 启动或重新连接Codex进程，自动生成专属socket和实例ID\n"
            "  - 使用: 首次对话前执行一次即可，如已运行会返回当前档位\n"
            "• /codex-ask <问题>\n"
            "  - 说明: 向当前Codex实例发起提问，自动携带当前模型强度/输出配置\n"
            "  - 使用: `/codex-ask 解释一下数据库分片`\n"
            "• /codex-config [high|default|low]\n"
            "  - 说明: 不带参数查看档位和开关；附带参数可切换模型强度\n"
            "  - 建议: 详细模式用 high，快速问答用 low，default 保持平衡\n"
            "• /codex-reasoning <on|off>\n"
            "  - 说明: 控制是否在Claude侧展示推理摘要，on 仅影响展示不影响真实推理\n"
            "  - 建议: 默认为 off 以保持回答纯净，除非调试需要\n"
            "• /codex-final_only <on|off>\n"
            "  - 说明: on 时仅返回最终答案；off 时附带额外细节或中间说明\n"
            "  - 建议: 生产使用保持 on，调试场景可临时关闭\n"
            "• /codex-status\n"
            "  - 说明: 查看实例ID、当前profile、推理/输出开关、进程PID等运行信息\n"
            "• /codex-stop\n"
            "  - 说明: 手动停止当前Codex子进程并清理socket，Claude退出时会自动调用\n"
            "• /codex-help\n"
            "  - 说明: 显示本帮助信息\n"
            "\n"
            "⚙️ 维护建议:\n"
            "1. 需要撤回最近一轮或清理上下文时，可结合 /codex-rewind 或 /codex-clear（若已实现）。\n"
            "2. 切换档位后如遇回答异常，优先执行 `/codex-config` 查看当前状态。\n"
            "3. 若长时间未用，建议 `/codex-stop` 后再 `/codex-start` 以释放资源。"
        )

    def _get_profile_desc(self, profile):
        descs = {"high": "深度分析", "low": "简洁快速", "default": "平衡模式"}
        return descs.get(profile, "标准")

    def _get_profile_temp(self, profile):
        temps = {"high": "0.1", "low": "0.3", "default": "0.2"}
        return temps.get(profile, "0.2")

    def _get_profile_tokens(self, profile):
        tokens = {"high": "4000", "low": "1000", "default": "2000"}
        return tokens.get(profile, "2000")
```

## 方案评估

### ✅ Claude内部触发优势
1. **一次性激活**：用户只需运行一次 /codex-start
2. **自动化配置**：路径、PID等全部自动生成
3. **生命周期绑定**：与Claude进程完全绑定
4. **内置恢复**：异常时自动重新启动
5. **简洁诊断**：仅保留必要的状态查看功能

### ✅ 用户体验优化
- **零学习成本**：通过 /codex-help 一键查看全部命令
- **透明运行**：启动后完全无感知使用
- **自动清理**：退出时无需手动操作
- **状态反馈**：清晰的服务状态提示

### 🔧 实现复杂度（最终版）
- **等级**：初级
- **核心代码**：约180行Python代码
- **依赖**：Python标准库
- **开发时间**：30分钟
- **测试时间**：20分钟

## 使用流程（Claude内部触发）

### 1. Claude内部激活流程
```python
# Claude Code内部逻辑
class ClaudeCode:
    def __init__(self):
        self.codex_manager = None
        self.codex_active = False

    def activate_codex(self):
        """用户首次使用时激活Codex"""
        if not self.codex_active:
            print("正在启动Codex服务...")
            self.codex_manager = ClaudeCodexManager()
            self.codex_manager.start_codex_process()
            self.codex_active = True
            print("Codex服务已启动，可以开始对话")

    def handle_user_command(self, command):
        # 首次使用 /codex- 系列命令时自动激活
        if command.startswith("/codex-"):
            if not self.codex_active:
                self.activate_codex()

        if command == "/codex-start":
            self.activate_codex()
            return "Codex服务已启动"

        elif command.startswith("/codex-ask"):
            if not self.codex_active:
                return "请先运行 /codex-start 启动服务，或输入 /codex-help 查看指引"
            question = command.replace("/codex-ask ", "")
            response = self.codex_manager.send_to_codex(question)
            return response["message"]

        elif command.startswith("/codex-config"):
            parts = command.split()
            if len(parts) == 1:
                return self.codex_manager.show_config()
            elif len(parts) == 2:
                return self.codex_manager.set_profile(parts[1])
            else:
                return "用法: /codex-config [high|default|low]"

        elif command.startswith("/codex-reasoning"):
            parts = command.split()
            if len(parts) != 2:
                return "用法: /codex-reasoning <on|off>"
            return self.codex_manager.update_show_reasoning(parts[1])

        elif command.startswith("/codex-final_only"):
            parts = command.split()
            if len(parts) != 2:
                return "用法: /codex-final_only <on|off>"
            return self.codex_manager.update_output_format(parts[1])

        elif command == "/codex-status":
            return self.codex_manager.show_status()

        elif command == "/codex-help":
            return self.codex_manager.show_help()

        elif command == "/codex-stop":
            if self.codex_active:
                self.codex_manager.cleanup()
                self.codex_active = False
                return "Codex服务已停止"
            else:
                return "Codex服务未运行"

        # 其他命令处理...
```

### 2. Claude内部命令处理（自动激活）
```python
class ClaudeCode:
    def __init__(self):
        self.codex_manager = ClaudeCodexManager()
        # 注册退出清理
        import atexit
        atexit.register(self.codex_manager.claude_cleanup_on_exit)

    def handle_command(self, command):
        # Claude内部统一命令处理，自动激活
        if command.startswith("/codex-"):
            # 首次使用时自动激活
            if not self.codex_manager.codex_active:
                self.codex_manager.auto_activate_on_first_use()
                print("正在启动Codex服务...")

        if command == "/codex-start":
            if not self.codex_manager.codex_active:
                self.codex_manager.auto_activate_on_first_use()
                return "✅ Codex服务已启动"
            else:
                return "ℹ️ Codex服务已在运行"

        elif command.startswith("/codex-ask"):
            if not self.codex_manager.codex_active:
                return "❌ 请先运行 /codex-start 启动服务，或输入 /codex-help 查看指引"

            question = command.replace("/codex-ask ", "")
            response = self.codex_manager.send_to_codex(question)
            return response["message"]

        elif command == "/codex-stop":
            if self.codex_manager.codex_active:
                self.codex_manager.claude_cleanup_on_exit()
                return "✅ Codex服务已停止"
            else:
                return "ℹ️ Codex服务未运行"

        elif command == "/codex-status":
            if self.codex_manager.codex_active:
                return f"✅ Codex运行中 (实例ID: {self.codex_manager.instance_id}, Profile: {self.codex_manager.current_profile})"
            else:
                return "❌ Codex服务未运行"

        elif command.startswith("/codex-config"):
            parts = command.split()
            if len(parts) == 1:
                return self.codex_manager.show_config()
            elif len(parts) == 2:
                return self.codex_manager.set_profile(parts[1])
            else:
                return "用法: /codex-config [high|default|low]"

        elif command.startswith("/codex-reasoning"):
            parts = command.split()
            if len(parts) != 2:
                return "用法: /codex-reasoning <on|off>"
            return self.codex_manager.update_show_reasoning(parts[1])

        elif command.startswith("/codex-final_only"):
            parts = command.split()
            if len(parts) != 2:
                return "用法: /codex-final_only <on|off>"
            return self.codex_manager.update_output_format(parts[1])

        elif command == "/codex-help":
            return self.codex_manager.show_help()
```

### 3. 简化诊断工具（仅供问题排查）
```bash
#!/bin/bash
# codex-diagnose - 系统级诊断工具，不用于日常管理

show_codex_diagnosis() {
    echo "=== Codex系统诊断 ==="

    # 显示当前用户的Claude进程
    echo "当前用户的Claude进程："
    ps aux | grep -E "(claude|Claude)" | grep -v grep || echo "未找到Claude进程"

    # 查找Codex子进程
    echo -e "\nCodex子进程："
    ps aux | grep codex_process | grep -v grep || echo "未找到Codex进程"

    # 查找Socket文件
    echo -e "\n活跃的Socket文件："
    find /tmp -name "codex-*.sock" -user $(whoami) 2>/dev/null | while read sock; do
        echo "Socket: $sock"
        echo "权限: $(ls -l $sock)"
        # 尝试获取关联的进程信息
        pid=$(lsof -t "$sock" 2>/dev/null)
        if [ -n "$pid" ]; then
            echo "关联进程: $pid"
        fi
        echo "---"
    done

    # 查找历史文件
    echo -e "\n历史文件："
    find /tmp -name "codex-*-history.json" -user $(whoami) 2>/dev/null | while read hist; do
        echo "历史: $hist"
        echo "大小: $(du -h $hist | cut -f1)"
        echo "修改时间: $(stat -c %y $hist)"
        echo "---"
    done
}

show_codex_diagnosis
```

### 3. 自动生命周期管理
```python
class ClaudeCodexManager:
    def __init__(self):
        self.socket_path = None
        self.codex_pid = None
        self.history_file = None

    def start_codex_process(self):
        """启动Codex子进程"""
        import os
        import uuid

        # 基于Claude进程ID生成路径
        claude_pid = os.getppid()
        unique_id = str(uuid.uuid4())[:8]
        self.socket_path = f"/tmp/codex-{claude_pid}-{unique_id}.sock"
        self.history_file = self.socket_path.replace('.sock', '-history.json')

        # fork子进程
        pid = os.fork()
        if pid == 0:  # 子进程
            self._run_codex_daemon()
            os._exit(0)
        else:  # 父进程
            self.codex_pid = pid
            self._monitor_child_process()

    def _monitor_child_process(self):
        """监控子进程状态"""
        import threading
        import time
        import os
        import signal

        def monitor():
            while True:
                try:
                    # 检查子进程是否还在运行
                    os.waitpid(self.codex_pid, os.WNOHANG)
                except OSError:
                    # 子进程已退出，重新启动
                    print("检测到Codex进程异常，正在重新启动...")
                    self.start_codex_process()
                    break
                time.sleep(1)

        monitor_thread = threading.Thread(target=monitor, daemon=True)
        monitor_thread.start()

    def cleanup(self):
        """清理Codex进程"""
        if self.codex_pid:
            try:
                os.kill(self.codex_pid, signal.SIGTERM)
                os.waitpid(self.codex_pid, 0)
                os.unlink(self.socket_path)
            except:
                pass
```

## 安全隔离和权限控制

### 1. 每实例独立Socket目录和权限
- **专用Socket路径**：`/tmp/codex-{claude_pid}-{instance_id}.sock`
- **自动权限设置**：Socket文件自动设置0600权限（仅用户可读写）
- **用户隔离**：不同用户的Socket文件完全隔离
- **进程隔离**：通过文件系统权限天然隔离不同实例

##### 安全路径生成和权限设置：
```python
class ClaudeCodexManager:
    def _generate_secure_socket_path(self):
        """生成安全的Socket路径"""
        claude_pid = os.getppid()
        instance_id = self._generate_instance_id()

        # 生成用户专用的Socket路径
        socket_path = f"/tmp/codex-{claude_pid}-{instance_id}.sock"

        # 确保在用户可写的目录中
        if not os.path.exists("/tmp"):
            raise Exception("/tmp目录不可访问")

        return socket_path

    def _setup_socket_permissions(self, socket_path):
        """设置Socket文件权限"""
        # 设置文件权限为仅用户可读写
        os.chmod(socket_path, 0o600)

        # 验证权限设置成功
        file_stat = os.stat(socket_path)
        if file_stat.st_mode & 0o777 != 0o600:
            raise Exception("Socket权限设置失败")
```

##### Codex子进程的安全启动：
```python
class CodexProcess:
    def run(self):
        """安全启动Codex服务"""
        # 加载历史记录
        self._load_history_securely()

        # 创建Socket并设置安全权限
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

        # 确保文件不存在，避免权限问题
        if os.path.exists(self.socket_path):
            os.unlink(self.socket_path)

        sock.bind(self.socket_path)

        # 立即设置权限
        os.chmod(self.socket_path, 0o600)

        # 验证权限
        self._verify_socket_permissions()

        sock.listen(1)
        self.running = True

        # 处理请求
        while self.running:
            try:
                conn, addr = sock.accept()
                # 验证连接权限（Unix Socket天然有文件系统保护）
                self._handle_connection(conn)
            except:
                break

        sock.close()

    def _verify_socket_permissions(self):
        """验证Socket文件权限"""
        file_stat = os.stat(self.socket_path)
        file_mode = file_stat.st_mode & 0o777

        if file_mode != 0o600:
            # 权限不正确，重新设置
            os.chmod(self.socket_path, 0o600)

        # 验证所有者
        if file_stat.st_uid != os.getuid():
            raise Exception("Socket文件所有者不正确")

    def _load_history_securely(self):
        """安全加载历史记录"""
        history_file = self.socket_path.replace('.sock', '-history.json')

        if os.path.exists(history_file):
            # 验证文件权限
            file_stat = os.stat(history_file)
            if file_stat.st_uid != os.getuid():
                # 不是所有者的文件，拒绝加载
                print("警告：历史文件所有者不正确，跳过加载")
                return

            if file_stat.st_mode & 0o077 != 0:
                # 文件权限过于开放，拒绝加载
                print("警告：历史文件权限过于开放，跳过加载")
                return

            try:
                with open(history_file, 'r') as f:
                    data = json.load(f)

                # 验证数据包含正确的instance_id
                if data.get("instance_id") == self.instance_id:
                    self.conversation_history = data.get("conversation_history", [])
                else:
                    print("警告：历史文件instance_id不匹配，跳过加载")

            except Exception as e:
                print(f"警告：加载历史文件失败: {e}")
```

### 2. 进程级安全隔离
- **父进程监控**：只有Claude父进程能管理Codex子进程
- **信号控制**：只有父进程能向子进程发送信号
- **进程树隔离**：不同Claude进程的Codex子进程完全隔离
- **用户级隔离**：不同用户的进程天然隔离

### 3. 异常情况的安全处理
- **权限验证失败**：拒绝启动并记录错误
- **文件权限错误**：自动修复或拒绝使用
- **进程异常退出**：Claude重新拉起，保持安全配置
- **未授权访问**：Unix Socket的文件系统权限天然防护

### 4. 资源清理安全策略
- **优雅退出**：SIGTERM信号确保数据保存
- **强制清理**：退出时删除所有相关文件
- **权限验证**：清理前验证文件所有权
- **残留检测**：启动时检查并清理历史残留

## 使用流程和配置管理（完整版）

### 1. 配置与模型强度使用流程

#### 基本使用示例：
```bash
# 步骤1：启动服务
用户: /codex-start
Claude: ✅ Codex服务已启动 (实例ID: abc123def, 默认Profile: default)

# 步骤2：查看当前配置
用户: /codex-config
Claude: 📋 当前配置:
• Profile: default (平衡模式)
• Instance ID: abc123def
• Socket: /tmp/codex-12345-abc123def.sock
• Show Reasoning: off  (on=输出推理摘要；off=仅内部使用)
• Output Format: final_only  (final_only=只输出最终答案)

# 步骤3：切换到高强度模型
用户: /codex-config high
Claude: ✅ Profile已更新为: high

📋 模型强度说明:
• high: 深度分析 (温度 0.1 / 最大长度 4000)
• default: 平衡模式 (温度 0.2 / 最大长度 2000)
• low: 简洁快速 (温度 0.3 / 最大长度 1000)

# 步骤4：使用高强度模式对话
用户: /codex-ask 解释量子计算的基本原理
Claude: 🤖 [Profile: high]
量子计算是一种革命性的计算范式...
[详细的深度解释，包含数学公式和应用场景]

# 步骤5：调整输出行为（仅最终答案）
用户: /codex-final_only on
Claude: ✅ Output Format 已切换为 final_only （推荐保持开启以避免额外噪音）

# 步骤6：关闭推理展示
用户: /codex-reasoning off
Claude: ✅ Show Reasoning 已设置为 off （已关闭推理展示）

# 步骤7：切换到低强度模型
用户: /codex-config low
Claude: ✅ Profile已更新为: low

# 步骤8：使用低强度模式对话
用户: /codex-ask 什么是量子计算？
Claude: 🤖 [Profile: low]
量子计算是利用量子力学原理进行信息处理的新型计算技术。

# 步骤9：查看服务状态
用户: /codex-status
Claude: ✅ Codex服务运行中:
• 实例ID: abc123def
• 当前Profile: low
• Show Reasoning: off
• Output Format: final_only
• 进程PID: 54321
• Socket: /tmp/codex-12345-abc123def.sock
```

#### 配置行为说明：
- **模型强度**：`/codex-config <high|default|low>` 即时生效，不影响现有历史
- **推理展示**：`/codex-reasoning on/off` 仅控制是否向Claude回显推理，推荐保持 off
- **输出格式**：`/codex-final_only on/off` 决定是否仅返回最终答案，推荐保持 on

### 2. 错误处理和异常情况

#### 常见错误场景：
```bash
# 场景1：服务未激活时尝试配置
用户: /codex-config high
Claude: ❌ Codex服务未激活，请先运行 /codex-start，或输入 /codex-help 查看指引

# 场景2：无效的模型强度
用户: /codex-config ultra
Claude: ❌ 无效参数，请使用: high、default、low

# 场景3：缺少开关参数
用户: /codex-reasoning
Claude: ❌ 参数错误
用法: /codex-reasoning <on|off>

# 场景4：推理展示参数错误
用户: /codex-reasoning maybe
Claude: ❌ 参数错误
用法: /codex-reasoning <on|off>

# 场景5：Output Format 参数错误
用户: /codex-final_only maybe
Claude: ❌ 参数错误
用法: /codex-final_only <on|off>

# 场景6：Codex进程异常重启
系统: Codex进程异常退出，正在重新启动...
系统: 已恢复 15 条对话历史，Profile: high

# 场景7：网络连接问题
用户: /codex-ask 测试问题
Claude: ❌ 请求失败: 连接Codex服务失败，正在重新连接...
Claude: 🤖 [Profile: high] 连接已恢复，这是你的回答...
```

#### 恢复机制：
1. **自动重连**：连接失败时自动尝试重新连接
2. **状态恢复**：进程重启后自动恢复profile、推理开关与对话历史
3. **降级处理**：严重错误时降级到default profile
4. **用户通知**：所有异常和恢复过程都有明确提示

### 3. 配置持久化和日志记录

#### 状态持久化：
```json
// 历史文件结构 (codex-12345-abc123def-history.json)
{
  "instance_id": "abc123def",
  "current_profile": "high",
  "conversation_history": [
    {
      "role": "user",
      "content": "解释量子计算",
      "timestamp": 1734987654,
      "profile": "high"
    },
    {
      "role": "assistant",
      "content": "量子计算是...",
      "timestamp": 1734987655,
      "profile": "high"
    }
  ],
  "saved_at": 1734987656,
  "version": "1.0"
}
```

#### 配置变更日志：
```
[Codex Config] profile: default -> high     (用户切换到详细模式)
[Codex Config] profile: high -> low       (用户切换到简洁模式)
[Codex Config] profile: low -> default     (系统重启恢复默认值)
```

### 4. 安全限制和注意事项

#### 安全约束：
- **参数验证**：严格验证所有profile参数，防止注入攻击
- **权限控制**：配置变更仅限当前用户实例
- **状态隔离**：不同Claude实例的配置完全隔离
- **审计日志**：记录所有配置变更便于审计

#### 使用注意事项：
1. **Profile选择**：
   - `high`：适合需要深度分析、详细解释的场景
   - `low`：适合快速问答、简洁响应的场景
   - `default`：平衡模式，适合一般对话

2. **性能影响**：
   - `high` profile响应时间较长，但质量更高
   - `low` profile响应快速，适合高频交互
   - 切换profile不会影响已有对话历史

3. **资源管理**：
   - 对话历史自动限制在100轮以内
   - 配置变更会立即持久化到本地文件
   - 异常退出时自动恢复最后状态

4. **故障处理**：
   - 配置变更失败时回退到之前的profile
   - 进程崩溃时自动重启并恢复配置
   - 网络问题时有重试机制

---

## 总结

这个**Claude内部触发的子进程方案**完美平衡了自动化和用户控制：

### ✅ 核心设计理念
1. **一次性激活**：用户只需在Claude内运行一次 /codex-start
2. **内部自动化**：所有配置、路径、进程管理完全自动
3. **生命周期绑定**：Codex与Claude进程完全同步
4. **透明使用**：激活后日常只需使用 /codex-ask 对话
5. **自动清理**：Claude退出时自动清理所有资源

### ✅ 关键技术特点
- **内部触发**：激活由Claude环境内部触发，而非外部命令
- **自动路径**：`/tmp/codex-{claude_pid}-{uuid}.sock`自动生成
- **子进程监控**：实时监控，异常时自动重新启动
- **信号处理**：优雅退出和数据持久化
- **简化诊断**：仅保留系统级状态查看工具

### ✅ 用户工作流程
```bash
# 1. 启动Claude（无变化）
# 2. 在Claude中激活（一次性）
用户: /codex-start
Claude: ✅ Codex服务已启动，可以开始对话

# 3. 查看帮助与命令说明
用户: /codex-help
Claude: 📖 Codex命令帮助（Claude内置）
• /codex-start  启动或重新连接Codex子进程
• /codex-ask <问题>  发起提问
• /codex-config [high|default|low]  查看或切换模型强度
• /codex-reasoning <on|off>  控制推理摘要展示
• /codex-final_only <on|off>  控制是否仅返回最终答案
• /codex-status  查看实例/开关/进程信息
• /codex-stop  停止当前Codex
• /codex-help  显示帮助
⚙️ 建议: 需要重置对话时，可使用 Claude 自带的 /rewind 或 /clear。

# 4. 查看当前配置
用户: /codex-config
Claude: 📋 当前配置:
• Profile: default
• Instance ID: abc123def
• Socket: /tmp/codex-12345-abc123def.sock
• Show Reasoning: false
• Output Format: final_only

# 5. 切换模型强度
用户: /codex-config high
Claude: ✅ Profile已更新为: high

📋 模型强度说明:
• high: 深度分析 (温度 0.1 / 最大长度 4000)
• default: 平衡模式 (温度 0.2 / 最大长度 2000)
• low: 简洁快速 (温度 0.3 / 最大长度 1000)

# 6. 控制输出行为
用户: /codex-reasoning off
Claude: ✅ Show Reasoning 已设置为 off （已关闭推理展示）

用户: /codex-final_only on
Claude: ✅ Output Format 已切换为 final_only （推荐保持开启以避免额外噪音）

# 7. 正常对话（自动保持上下文）
用户: /codex-ask 解释一下Python的装饰器
Claude: [Codex的回答] 装饰器是Python的一种设计模式...

# 8. 查看状态
用户: /codex-status
Claude: ✅ Codex服务运行中:
• 实例ID: abc123def
• 当前Profile: high
• 进程PID: 54321
• Socket: /tmp/codex-12345-abc123def.sock

# 9. 继续提问（可选多轮）
用户: /codex-ask 给个具体的代码例子
Claude: [Codex的回答] 这是一个装饰器的实现示例...

# 10. 可选停止
用户: /codex-stop
Claude: ✅ Codex服务已停止

# 11. Claude退出时自动清理（无需用户操作）
```

### ✅ 适用场景
- **本机开发环境**：单个开发者使用
- **项目隔离**：不同项目的Claude进程完全独立
- **简单可靠**：最小化复杂度和故障点
- **资源清洁**：退出时完全清理，不留垃圾文件

*本方案实现了"一次激活，持续使用，自动清理"的理想用户体验，完全贴合本机少实例的使用场景。*
