#!/usr/bin/env python3
"""
claude-codex - Claude Code with integrated Codex AI assistant
åœ¨å¯åŠ¨Claude Codeçš„åŒæ—¶è‡ªåŠ¨å¯åŠ¨Codexå®ˆæŠ¤è¿›ç¨‹
"""

import sys
import os
import json
import subprocess
import signal
import time
import argparse
import atexit
import uuid
import getpass
from pathlib import Path

class ClaudeCodexWrapper:
    def __init__(self, resume=False, claude_args=None):
        self.resume_requested = resume
        self.claude_args = claude_args or []
        self.script_dir = Path(__file__).resolve().parent
        self.daemon_path = self.script_dir / "codex_daemon.py"

        runtime_root = self._select_runtime_root()
        default_socket = runtime_root / "codex-daemon.sock"
        default_pid = runtime_root / "codex-daemon.pid"

        self.socket_path = os.environ.get("CODEX_DAEMON_SOCKET", str(default_socket))
        self.pid_file = os.environ.get("CODEX_DAEMON_PID", str(default_pid))
        self.daemon_process = None
        self.claude_process = None
        self.runtime_root = runtime_root
        self.active_client_file = self.runtime_root / "active_client_id"
        self.project_client_file = self._detect_project_client_file()
        env_client_id = os.environ.get("CODEX_CLIENT_ID")
        file_client_id = self._load_project_client_id() if (resume and not env_client_id) else None
        if env_client_id:
            self.client_id = env_client_id
        elif file_client_id:
            self.client_id = file_client_id
        else:
            self.client_id = f"codex-client-{uuid.uuid4().hex[:10]}"

    def _select_runtime_root(self):
        candidates = []

        env_runtime = os.environ.get("CODEX_RUNTIME_DIR")
        if env_runtime:
            candidates.append(Path(env_runtime).expanduser())

        candidates.append(Path("/tmp") / f"codex-{getpass.getuser()}")
        candidates.append(Path.home() / ".codex_runtime")

        uid = os.getuid()
        for candidate in candidates:
            try:
                candidate.mkdir(parents=True, exist_ok=True)
                stat_info = candidate.stat()
                if stat_info.st_uid != uid:
                    print(f"âš ï¸ è¿è¡Œç›®å½• {candidate} æ‰€æœ‰è€…ä¸æ˜¯å½“å‰ç”¨æˆ·ï¼Œè·³è¿‡")
                    continue
                test_path = candidate / f".write_test-{uuid.uuid4().hex}"
                try:
                    with open(test_path, 'w') as fp:
                        fp.write('ok')
                finally:
                    try:
                        test_path.unlink()
                    except FileNotFoundError:
                        pass
                candidate.chmod(0o700)
                return candidate
            except PermissionError:
                continue
            except Exception as exc:
                print(f"âš ï¸ åˆ›å»ºè¿è¡Œç›®å½• {candidate} å¤±è´¥: {exc}")
                continue

        print("âŒ æ— æ³•åˆ›å»º Codex è¿è¡Œç›®å½•ï¼Œè¯·æ£€æŸ¥æƒé™")
        sys.exit(1)

    def _detect_project_client_file(self):
        try:
            project_dir = Path.cwd()
        except Exception:
            return None
        return project_dir / ".codex_client_id"

    def _load_project_client_id(self):
        if not self.project_client_file:
            return None
        try:
            content = self.project_client_file.read_text(encoding="utf-8").strip()
            return content or None
        except OSError:
            return None

    def _store_project_client_id(self):
        if not self.project_client_file:
            return
        try:
            self.project_client_file.write_text(self.client_id, encoding="utf-8")
        except OSError:
            pass

    def check_daemon_running(self):
        """æ£€æŸ¥å®ˆæŠ¤è¿›ç¨‹æ˜¯å¦å·²è¿è¡Œ"""
        if not os.path.exists(self.socket_path):
            return False

        try:
            # å°è¯•è¿æ¥socketéªŒè¯æœåŠ¡å¯ç”¨æ€§
            import socket
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.settimeout(2)  # ç¨å¾®å¢åŠ è¶…æ—¶æ—¶é—´
            sock.connect(self.socket_path)
            sock.close()
            return True
        except socket.timeout:
            print("âš ï¸ æ£€æµ‹å®ˆæŠ¤è¿›ç¨‹è¶…æ—¶")
            return False
        except socket.error as exc:
            print(f"âš ï¸ æ£€æµ‹å®ˆæŠ¤è¿›ç¨‹å¤±è´¥: {exc}")
            return False
        except Exception as exc:
            print(f"âš ï¸ æ£€æµ‹å®ˆæŠ¤è¿›ç¨‹å¼‚å¸¸: {exc}")
            return False

    def start_daemon(self):
        """å¯åŠ¨Codexå®ˆæŠ¤è¿›ç¨‹"""
        if self.check_daemon_running():
            print("ğŸ¤– Codexå®ˆæŠ¤è¿›ç¨‹å·²åœ¨è¿è¡Œ")
            return True

        print("ğŸš€ å¯åŠ¨Codexå®ˆæŠ¤è¿›ç¨‹...")

        try:
            # åå°å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹
            env = os.environ.copy()
            env.setdefault("CODEX_DAEMON_MODE", "1")
            env.setdefault("CODEX_RUNTIME_DIR", str(self.runtime_root))

            cmd = [
                "python3", str(self.daemon_path),
                "--socket", self.socket_path
            ]

            self.daemon_process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE,
                start_new_session=True,  # åˆ›å»ºæ–°çš„è¿›ç¨‹ç»„
                env=env,
            )

            # ç­‰å¾…å®ˆæŠ¤è¿›ç¨‹å¯åŠ¨
            max_wait = 10  # æœ€å¤šç­‰å¾…10ç§’
            for i in range(max_wait):
                if self.check_daemon_running():
                    print(f"âœ… Codexå®ˆæŠ¤è¿›ç¨‹å·²å¯åŠ¨ (PID: {self.daemon_process.pid})")
                    return True
                time.sleep(1)
                if i == 3:  # 3ç§’åæç¤ºç”¨æˆ·
                    print("â³ ç­‰å¾…CodexæœåŠ¡å¯åŠ¨...")

            if self.daemon_process and self.daemon_process.poll() is None and os.path.exists(self.socket_path):
                print("âš ï¸ å®ˆæŠ¤è¿›ç¨‹å“åº”ç¼“æ…¢ï¼Œä½†Socketå·²åˆ›å»ºï¼Œç»§ç»­å¯åŠ¨")
                return True

            # å¦‚æœå­˜åœ¨stderrè¾“å‡ºï¼Œå¸®åŠ©è¯Šæ–­
            if self.daemon_process and self.daemon_process.stderr:
                try:
                    err_output = self.daemon_process.stderr.read().strip()
                    if err_output:
                        print(f"â— å®ˆæŠ¤è¿›ç¨‹è¾“å‡º: {err_output}")
                except Exception:
                    pass

            print("âŒ Codexå®ˆæŠ¤è¿›ç¨‹å¯åŠ¨è¶…æ—¶")
            return False

        except Exception as e:
            print(f"âŒ å¯åŠ¨Codexå®ˆæŠ¤è¿›ç¨‹å¤±è´¥: {e}")
            return False

    def stop_daemon(self):
        """åœæ­¢Codexå®ˆæŠ¤è¿›ç¨‹"""
        stopped = False

        # é¦–å…ˆå°è¯•é€šè¿‡socketå‘é€ä¼˜é›…åœæ­¢å‘½ä»¤
        if os.path.exists(self.socket_path):
            try:
                import socket
                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                sock.settimeout(3)
                sock.connect(self.socket_path)

                # å‘é€å…³é—­å‘½ä»¤
                stop_request = {"command": "/codex-shutdown"}
                request_json = json.dumps(stop_request, ensure_ascii=False)
                sock.send(request_json.encode('utf-8') + b'\n')

                # ç­‰å¾…å“åº”
                response = sock.recv(1024)
                sock.close()
                print("âœ… å‘é€åœæ­¢å‘½ä»¤åˆ°å®ˆæŠ¤è¿›ç¨‹")
                time.sleep(1)  # ç»™å®ˆæŠ¤è¿›ç¨‹æ—¶é—´æ¸…ç†
                stopped = True
            except Exception:
                pass  # Socketé€šä¿¡å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨å…¶ä»–æ–¹æ³•

        # å¦‚æœsocketåœæ­¢å¤±è´¥ï¼Œå°è¯•ä»PIDæ–‡ä»¶è¯»å–çœŸå®çš„å®ˆæŠ¤è¿›ç¨‹PID
        if not stopped and os.path.exists(self.pid_file):
            try:
                with open(self.pid_file, 'r') as f:
                    daemon_pid = int(f.read().strip())

                # æ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜åœ¨
                os.kill(daemon_pid, 0)  # å¦‚æœè¿›ç¨‹ä¸å­˜åœ¨ä¼šæŠ›å‡ºOSError

                print(f"ğŸ›‘ åœæ­¢Codexå®ˆæŠ¤è¿›ç¨‹ (PID: {daemon_pid})...")
                os.kill(daemon_pid, 15)  # å‘é€TERMä¿¡å·
                stopped = True

                # ç­‰å¾…è¿›ç¨‹é€€å‡º
                for _ in range(5):  # æœ€å¤šç­‰å¾…5ç§’
                    try:
                        os.kill(daemon_pid, 0)
                        time.sleep(1)
                    except OSError:
                        break  # è¿›ç¨‹å·²é€€å‡º
                else:
                    # å¦‚æœè¿›ç¨‹ä»åœ¨è¿è¡Œï¼Œå¼ºåˆ¶æ€æ­»
                    print("å¼ºåˆ¶ç»ˆæ­¢å®ˆæŠ¤è¿›ç¨‹...")
                    os.kill(daemon_pid, 9)

            except (OSError, ValueError, ProcessLookupError):
                pass  # PIDæ–‡ä»¶æ— æ•ˆæˆ–è¿›ç¨‹å·²ä¸å­˜åœ¨

        # å¤‡ç”¨æ–¹æ¡ˆï¼šå°è¯•åœæ­¢å­˜å‚¨çš„è¿›ç¨‹ï¼ˆå¯èƒ½å·²ä¸å‡†ç¡®ï¼‰
        if not stopped and self.daemon_process and self.daemon_process.poll() is None:
            print("ğŸ›‘ åœæ­¢Codexå®ˆæŠ¤è¿›ç¨‹...")
            self.daemon_process.terminate()
            try:
                self.daemon_process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                self.daemon_process.kill()

        # æ¸…ç†socketå’ŒPIDæ–‡ä»¶
        for path in [self.socket_path, self.pid_file]:
            if os.path.exists(path):
                try:
                    os.unlink(path)
                except:
                    pass

    def start_claude(self, args):
        """å¯åŠ¨Claude Code"""
        print("ğŸš€ å¯åŠ¨Claude Code...")

        # æ„å»ºClaude Codeå‘½ä»¤
        claude_cmd = ["claude"] + args

        env = os.environ.copy()
        env["CODEX_CLIENT_ID"] = self.client_id
        env["CODEX_DAEMON_SOCKET"] = str(self.socket_path)
        env["CODEX_DAEMON_PID"] = str(self.pid_file)
        if self.resume_requested:
            env["CODEX_FORCE_RESUME"] = "1"

        try:
            self._store_project_client_id()
            try:
                self.active_client_file.write_text(self.client_id, encoding="utf-8")
            except Exception:
                pass

            print(f"æ‰§è¡Œ: {' '.join(claude_cmd)}")
            # å¯¹äºäº¤äº’æ¨¡å¼ï¼Œéœ€è¦ç»§æ‰¿stdin/stdout/stderr
            self.claude_process = subprocess.run(
                claude_cmd,
                check=False,  # ä¸å¼ºåˆ¶è¦æ±‚æˆåŠŸé€€å‡º
                stdin=sys.stdin,  # ç»§æ‰¿æ ‡å‡†è¾“å…¥
                stdout=sys.stdout,  # ç»§æ‰¿æ ‡å‡†è¾“å‡º
                stderr=sys.stderr,   # ç»§æ‰¿æ ‡å‡†é”™è¯¯
                env=env
            )
            return self.claude_process.returncode
        except KeyboardInterrupt:
            print("\nâš ï¸ ç”¨æˆ·ä¸­æ–­")
            return 130
        except Exception as e:
            print(f"âŒ å¯åŠ¨Claude Codeå¤±è´¥: {e}")
            return 1

    def cleanup(self):
        """æ¸…ç†èµ„æº"""
        print("\nğŸ§¹ æ¸…ç†èµ„æº...")
        self.stop_daemon()
        if self.active_client_file.exists():
            try:
                self.active_client_file.unlink()
            except Exception:
                pass
        print("âœ… æ¸…ç†å®Œæˆ")

    def run(self):
        """ä¸»è¿è¡Œæµç¨‹"""
        # æ³¨å†Œæ¸…ç†å‡½æ•°
        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)

        # å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹ï¼ˆå¦‚æœæœªè¿è¡Œï¼‰
        if not self.start_daemon():
            print("âŒ Codexå®ˆæŠ¤è¿›ç¨‹å¯åŠ¨å¤±è´¥ï¼Œæ— æ³•ç»§ç»­")
            return 1

        try:
            # å¯åŠ¨Claude Code
            return self.start_claude(self.claude_args)
        finally:
            self.cleanup()

    def _signal_handler(self, signum, frame):
        """ä¿¡å·å¤„ç†å™¨"""
        print(f"\næ”¶åˆ°ä¿¡å· {signum}ï¼Œæ­£åœ¨é€€å‡º...")
        self.cleanup()
        sys.exit(0)

def show_help():
    """æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"""
    help_text = """
claude-codex - Claude Code with integrated Codex AI assistant

ç”¨æ³•:
    claude-codex [-C] [OPTIONS] [COMMAND] [ARGS]...

åŠŸèƒ½:
    ğŸ¤– è‡ªåŠ¨å¯åŠ¨Codexå®ˆæŠ¤è¿›ç¨‹
    ğŸ”— ä¸Claude Codeå®Œå…¨é›†æˆ
    ğŸ“ æ”¯æŒæ‰€æœ‰åŸå§‹claude-codeå‚æ•°

ç¤ºä¾‹:
    claude-codex                           # å¯åŠ¨äº¤äº’æ¨¡å¼
    claude-codex -c "python3 --version"     # æ‰§è¡Œå‘½ä»¤
    claude-codex --help                     # æ˜¾ç¤ºå¸®åŠ©
    claude-codex /path/to/project           # æ‰“å¼€é¡¹ç›®

Codexå‘½ä»¤ (åœ¨Claudeä¸­ä½¿ç”¨):
    /codex-ask <é—®é¢˜>          - å‘AIæé—®
    /codex-config [profile]     - é…ç½®AIæ¨¡å‹å¼ºåº¦
    /codex-status              - æŸ¥çœ‹æœåŠ¡çŠ¶æ€
    /codex-help               - æ˜¾ç¤ºCodexå¸®åŠ©

æ›´å¤šä¿¡æ¯:
    å®Œæ•´çš„Claude Codeå‚æ•°è¯·å‚è€ƒ: claude-code --help
"""
    print(help_text)
    print("é¢å¤–é€‰é¡¹:")
    print("    -C                    æ¢å¤ä¸Šä¸€æ¬¡çš„ Codex ä¼šè¯ï¼ˆä½¿ç”¨é¡¹ç›®ç›®å½•ä¸­çš„ .codex_client_id å’Œå†å²è®°å½•ï¼‰")


def parse_codex_args(argv):
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('-C', dest='resume', action='store_true', help='æ¢å¤ä¸Šä¸€æ¬¡çš„ Codex ä¼šè¯')
    return parser.parse_known_args(argv)

def main():
    codex_args, claude_args = parse_codex_args(sys.argv[1:])

    if '--help' in claude_args or '-h' in claude_args:
        show_help()
        print("\n" + "=" * 50)
        print("åŸå§‹Claude Codeå¸®åŠ©:")
        print("=" * 50)
        try:
            subprocess.run(["claude"] + claude_args, check=False)
        except Exception:
            pass
        return 0

    wrapper = ClaudeCodexWrapper(resume=codex_args.resume, claude_args=claude_args)
    return wrapper.run()

if __name__ == "__main__":
    sys.exit(main())
