#!/usr/bin/env python3
"""
cask-w å‘½ä»¤
å°†è¾“å…¥è½¬å‘åˆ° Codex tmux ä¼šè¯ï¼Œé»˜è®¤ä½¿ç”¨ /cask-w åŒæ­¥ç­‰å¾…ã€‚
"""

from __future__ import annotations

import importlib.machinery
import importlib.util
import sys
from pathlib import Path
from typing import Tuple


def _usage() -> None:
    print("ç”¨æ³•: cask-w <åŸå§‹æŒ‡ä»¤>", file=sys.stderr)
    print('ç¤ºä¾‹: cask-w "è§£é‡Šä¸€ä¸‹å½“å‰è„šæœ¬ä½œç”¨"', file=sys.stderr)


def _load_cask_module():
    script_dir = Path(__file__).resolve().parent
    cask_path = script_dir / "cask"
    if not cask_path.exists():
        raise RuntimeError("âŒ æœªæ‰¾åˆ° cask å‘½ä»¤è„šæœ¬ï¼Œè¯·ç¡®è®¤å®‰è£…æ˜¯å¦å®Œæ•´")

    spec = importlib.util.spec_from_loader(
        "codex_cask",
        importlib.machinery.SourceFileLoader("codex_cask", str(cask_path))
    )
    if not spec or not spec.loader:
        raise RuntimeError("âŒ æ— æ³•åŠ è½½ cask æ¨¡å—")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)  # type: ignore[attr-defined]
    return module


def _prepare_payload(raw: str) -> str:
    # cask-w åº”è¯¥åŸæ ·è½¬å‘ï¼Œä¸æ·»åŠ å‰ç¼€ï¼ˆä¸ cask è¡Œä¸ºä¸€è‡´ï¼‰
    stripped = raw.strip()
    if not stripped:
        raise RuntimeError("âŒ æŒ‡ä»¤å†…å®¹ä¸èƒ½ä¸ºç©º")
    return raw


def _capture_log_state():
    """åœ¨å‘é€å‘½ä»¤å‰æ•è·æ—¥å¿—çŠ¶æ€"""
    script_dir = Path(__file__).resolve().parent
    sys.path.insert(0, str(script_dir))

    from codex_comm import CodexCommunicator
    comm = CodexCommunicator()
    return comm.log_reader.capture_state()


def _send(module, payload: str) -> Tuple[str, str]:
    session, runtime = module._resolve_tmux_session()
    module._ensure_tmux_session(session)
    module._send_via_tmux(session, payload)
    location = runtime or "tmux"
    return session, location


def _wait_for_reply(initial_state: dict, timeout: int = 0) -> tuple:
    """ç­‰å¾…å¹¶è·å–æ–°çš„ Codex å›å¤ï¼Œtimeout=0 è¡¨ç¤ºæ— é™ç­‰å¾…"""
    script_dir = Path(__file__).resolve().parent
    sys.path.insert(0, str(script_dir))

    from codex_comm import CodexCommunicator
    import time

    comm = CodexCommunicator()

    start_time = time.time()
    last_hint = 0
    while timeout == 0 or time.time() - start_time < timeout:
        message, new_state = comm.log_reader.wait_for_message(initial_state, timeout=1.0)
        if message:
            return message, new_state
        initial_state = new_state if new_state else initial_state

        elapsed = int(time.time() - start_time)
        if elapsed >= last_hint + 30:
            last_hint = elapsed
            print(f"â³ ä»åœ¨ç­‰å¾… Codex å›å¤... ({elapsed}s)")

    return None, initial_state


def _save_pending_state(state: dict) -> None:
    """ä¿å­˜è¶…æ—¶æ—¶çš„çŠ¶æ€ï¼Œä¾› cpend ç»§ç»­è¯»å–"""
    import json
    session_file = Path.cwd() / ".codex-session"
    if not session_file.exists():
        return
    try:
        with session_file.open("r", encoding="utf-8") as f:
            data = json.load(f)
        data["pending_state"] = {
            "log_path": str(state.get("log_path")) if state.get("log_path") else None,
            "offset": state.get("offset", 0),
        }
        with session_file.open("w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception:
        pass


def main(argv: list[str]) -> int:
    if len(argv) <= 1:
        _usage()
        return 1

    raw_command = " ".join(argv[1:])
    if not raw_command.strip():
        _usage()
        return 1

    try:
        initial_state = _capture_log_state()
        module = _load_cask_module()
        payload = _prepare_payload(raw_command)
        session, location = _send(module, payload)

        print("â³ ç­‰å¾… Codex å›å¤...")
        reply, final_state = _wait_for_reply(initial_state)
        if reply:
            print("\nğŸ¤– Codex å›å¤:")
            print(reply)
            return 0
        else:
            _save_pending_state(final_state)
            print("\nâ° è¶…æ—¶ï¼šæœªåœ¨é™å®šæ—¶é—´å†…æ”¶åˆ° Codex å›å¤")
            print("æç¤º: ç¨åä½¿ç”¨ cpend æŸ¥çœ‹å›å¤")
            return 0
    except Exception as exc:
        print(exc, file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
