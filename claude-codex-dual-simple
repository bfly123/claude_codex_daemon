#!/usr/bin/env python3
"""
Claude-Codex 双窗口模式 - 简化版
专注于tmux模式，避免终端兼容性问题
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import getpass
from pathlib import Path

class SimpleClaudeCodexDual:
    def __init__(self, resume=False, claude_args=None):
        self.resume = resume
        self.claude_args = claude_args or []
        self.script_dir = Path(__file__).resolve().parent

        # 会话管理
        self.session_id = f"dual-{int(time.time())}-{os.getpid()}"
        self.runtime_dir = Path("/tmp") / f"codex-{getpass.getuser()}" / self.session_id
        self.runtime_dir.mkdir(parents=True, exist_ok=True)

        # 文件路径
        self.input_fifo = self.runtime_dir / "input.fifo"
        self.output_fifo = self.runtime_dir / "output.fifo"
        self.codex_pid_file = self.runtime_dir / "codex.pid"
        self.claude_pid_file = self.runtime_dir / "claude.pid"
        self.status_file = self.runtime_dir / "status"
        self.project_session_file = Path.cwd() / ".codex-session"

        # 进程管理
        self.codex_process = None
        self.tmux_session = f"codex-{self.session_id[:8]}"

    def create_fifos(self):
        """创建FIFO管道"""
        print("🔧 创建通信管道...")

        try:
            # 创建输入管道 (Claude → Codex)
            if not self.input_fifo.exists():
                os.mkfifo(self.input_fifo)
            os.chmod(self.input_fifo, 0o600)

            # 创建输出管道 (Codex → Claude 监控)
            if not self.output_fifo.exists():
                os.mkfifo(self.output_fifo)
            os.chmod(self.output_fifo, 0o644)

            print(f"✅ 管道创建完成:")
            print(f"   输入: {self.input_fifo}")
            print(f"   输出: {self.output_fifo}")
            return True

        except Exception as e:
            print(f"❌ 创建管道失败: {e}")
            return False

    def start_tmux_codex(self):
        """使用tmux启动Codex窗口"""
        print("🚀 启动Codex窗口（tmux模式）...")

        # 创建Codex启动脚本
        codex_script = f'''#!/bin/bash
# Codex tmux会话启动脚本

SESSION_ID="{self.session_id}"
RUNTIME_DIR="{self.runtime_dir}"
PID_FILE="{self.codex_pid_file}"

echo $$ > "$PID_FILE"
echo "🤖 Codex会话启动: $SESSION_ID"
echo "📁 运行目录: $RUNTIME_DIR"
echo ""
echo "🔧 提示："
echo "- 这是Codex窗口，可以直接与Codex对话"
echo "- Claude可以通过/codex-ask命令发送问题到这里"
echo "- 输入 'exit' 退出Codex"
echo ""

# 检查codex是否可用
if ! command -v codex &> /dev/null; then
    echo "❌ 错误：找不到codex命令"
    echo "请确保已安装codex CLI工具"
    sleep 5
    exit 1
fi

# 启动codex
exec codex
'''

        # 写入脚本文件
        script_file = self.runtime_dir / "codex_tmux.sh"
        with open(script_file, 'w') as f:
            f.write(codex_script)
        os.chmod(script_file, 0o755)

        try:
            # 检查tmux是否可用
            result = subprocess.run(["tmux", "has-session"], capture_output=True)
            if result.returncode == 0 and self.tmux_session in result.stderr.decode():
                print(f"⚠️ tmux会话 {self.tmux_session} 已存在")
                return False

            # 创建新的tmux会话
            print(f"📺 创建tmux会话: {self.tmux_session}")
            cmd = [
                "tmux", "new-session", "-d", "-s", self.tmux_session,
                str(script_file)
            ]
            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode != 0:
                print(f"❌ 创建tmux会话失败: {result.stderr}")
                return False

            print(f"✅ tmux会话创建成功")
            print(f"💡 提示：使用 'tmux attach -t {self.tmux_session}' 连接到Codex窗口")
            return True

        except FileNotFoundError:
            print("❌ tmux未安装，请先安装tmux")
            print("   Ubuntu/Debian: sudo apt install tmux")
            print("   CentOS/RHEL: sudo yum install tmux")
            return False
        except Exception as e:
            print(f"❌ 启动tmux失败: {e}")
            return False

    def start_claude_window(self):
        """启动Claude窗口"""
        print("🚀 启动Claude窗口...")

        # 保存会话信息
        try:
            with open(self.project_session_file, 'w') as f:
                session_info = {
                    "session_id": self.session_id,
                    "runtime_dir": str(self.runtime_dir),
                    "tmux_session": self.tmux_session,
                    "started_at": time.strftime('%Y-%m-%d %H:%M:%S')
                }
                json.dump(session_info, f, indent=2)
            print(f"✅ 会话信息已保存: {self.project_session_file}")
        except Exception as e:
            print(f"⚠️ 保存会话信息失败: {e}")

        # 写入Claude PID
        with open(self.claude_pid_file, 'w') as f:
            f.write(str(os.getpid()))

        # 更新状态
        with open(self.status_file, 'w') as f:
            f.write("running")

        print(f"📋 会话ID: {self.session_id}")
        print(f"📺 tmux会话: {self.tmux_session}")
        print(f"📁 运行目录: {self.runtime_dir}")
        print("✅ Claude窗口就绪")
        print()
        print("🎯 可用命令:")
        print("   /codex-ask <问题>              - 异步发送问题")
        print("   /codex-ask --wait <问题>       - 同步等待回复")
        print("   /codex-status                  - 查看连接状态")
        print("   /codex-ping                    - 测试连通性")
        print()
        print(f"💡 连接到Codex窗口: tmux attach -t {self.tmux_session}")
        print()

        # 设置环境变量
        env = os.environ.copy()
        env["CODEX_SESSION_ID"] = self.session_id
        env["CODEX_RUNTIME_DIR"] = str(self.runtime_dir)
        env["CODEX_INPUT_FIFO"] = str(self.input_fifo)
        env["CODEX_OUTPUT_FIFO"] = str(self.output_fifo)
        env["CODEX_TMUX_SESSION"] = self.tmux_session

        try:
            # 启动Claude Code
            cmd = ["claude"] + self.claude_args
            print(f"执行: {' '.join(cmd)}")

            return subprocess.run(
                cmd,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                env=env
            ).returncode

        except KeyboardInterrupt:
            print("\n⚠️ 用户中断")
            return 130
        except Exception as e:
            print(f"❌ 启动Claude失败: {e}")
            return 1

    def cleanup(self):
        """清理资源"""
        print("\n🧹 清理会话资源...")

        try:
            # 杀掉tmux会话
            result = subprocess.run(
                ["tmux", "has-session", "-t", self.tmux_session],
                capture_output=True
            )
            if result.returncode == 0:
                subprocess.run([
                    "tmux", "kill-session", "-t", self.tmux_session
                ], stderr=subprocess.DEVNULL)
                print(f"✅ tmux会话已清理: {self.tmux_session}")

            # 删除运行时目录
            import shutil
            if self.runtime_dir.exists():
                shutil.rmtree(self.runtime_dir)

            # 删除项目会话文件
            if self.project_session_file.exists():
                self.project_session_file.unlink()

            print("✅ 清理完成")

        except Exception as e:
            print(f"⚠️ 清理时出现错误: {e}")

    def run(self):
        """主运行流程"""
        print(f"🚀 Claude-Codex 双窗口模式 (tmux)")
        print(f"📅 启动时间: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"🆔 会话ID: {self.session_id}")
        print("=" * 50)

        # 注册清理函数
        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, lambda s, f: (self.cleanup(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (self.cleanup(), sys.exit(0)))

        # 创建管道
        if not self.create_fifos():
            return 1

        # 启动Codex窗口
        if not self.start_tmux_codex():
            return 1

        # 等待Codex启动
        time.sleep(2)

        try:
            # 启动Claude窗口
            return self.start_claude_window()
        finally:
            self.cleanup()

def show_help():
    """显示帮助信息"""
    help_text = """
claude-codex-dual-simple - Claude-Codex 双窗口模式 (tmux版)

用法:
    claude-codex-dual-simple [OPTIONS] [COMMAND] [ARGS]...

功能:
    🚀 使用tmux启动Claude和Codex两个窗口
    🔗 建立Claude到Codex的单向控制通道
    💾 自动保存会话信息和历史记录
    🔄 支持中断恢复和错误处理

特点:
    - 使用tmux确保最佳兼容性
    - 简化的启动流程
    - 稳定的会话管理

示例:
    claude-codex-dual-simple                           # 启动双窗口模式
    claude-codex-dual-simple --resume                  # 恢复上次会话
    claude-codex-dual-simple /path/to/project          # 在项目目录启动

Claude命令 (在Claude窗口中使用):
    /codex-ask <问题>              - 异步发送问题到Codex
    /codex-ask --wait <问题>       - 同步等待Codex回复
    /codex-status                  - 查看连接状态
    /codex-ping                    - 测试连通性

tmux命令:
    tmux attach -t codex-xxxx     # 连接到Codex窗口
    tmux list-sessions            # 查看所有会话
    tmux kill-session -t codex-xxxx # 删除Codex会话
"""
    print(help_text)

def main():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--resume', action='store_true', help='恢复上次的会话')
    parser.add_argument('--help', '-h', action='store_true', help='显示帮助')

    args, claude_args = parser.parse_known_args()

    if args.help:
        show_help()
        return 0

    dual = SimpleClaudeCodexDual(resume=args.resume, claude_args=claude_args)
    return dual.run()

if __name__ == "__main__":
    sys.exit(main())