#!/usr/bin/env python3
"""
claude_ai - ç»Ÿä¸€ AI å¯åŠ¨å™¨
æ”¯æŒ Claude + Codex / Claude + Gemini / ä¸‰è€…åŒæ—¶
æ”¯æŒ tmux å’Œ WezTerm ç»ˆç«¯
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
import platform
from pathlib import Path

script_dir = Path(__file__).resolve().parent
sys.path.insert(0, str(script_dir / "lib"))
from terminal import TmuxBackend, WeztermBackend, detect_terminal


def is_wsl() -> bool:
    try:
        return "microsoft" in Path("/proc/version").read_text().lower()
    except Exception:
        return False


class AILauncher:
    def __init__(self, providers: list, resume: bool = False, auto: bool = False, no_claude: bool = False):
        self.providers = providers or ["codex"]
        self.resume = resume
        self.auto = auto
        self.no_claude = no_claude
        self.script_dir = Path(__file__).resolve().parent
        self.session_id = f"ai-{int(time.time())}-{os.getpid()}"
        self.temp_base = Path("/tmp")
        self.runtime_dir = self.temp_base / f"claude-ai-{getpass.getuser()}" / self.session_id
        self.runtime_dir.mkdir(parents=True, exist_ok=True)
        self._cleaned = False
        self.terminal_type = self._detect_terminal_type()
        self.tmux_sessions = {}
        self.wezterm_panes = {}
        self.processes = {}

    def _detect_terminal_type(self):
        # åªæœ‰åœ¨ WezTerm ç¯å¢ƒä¸­æ‰ç”¨ WezTerm åˆ†å±
        if os.environ.get("WEZTERM_PANE"):
            return "wezterm"
        # å…¶ä»–æƒ…å†µéƒ½ç”¨ tmux
        return "tmux"

    def _detect_terminal(self):
        if is_wsl():
            return "tmux"
        if platform.system() == "Darwin":
            return "tmux"
        terminals = ["gnome-terminal", "konsole", "alacritty", "xterm"]
        for term in terminals:
            if subprocess.run(["which", term], capture_output=True).returncode == 0:
                return term
        return "tmux"

    def _start_provider(self, provider: str) -> bool:
        print(f"ğŸš€ å¯åŠ¨ {provider.capitalize()} åç«¯ ({self.terminal_type})...")

        if self.terminal_type == "wezterm":
            return self._start_provider_wezterm(provider)

        tmux_session = f"{provider}-{int(time.time()) % 100000}-{os.getpid()}"
        self.tmux_sessions[provider] = tmux_session

        if provider == "codex":
            return self._start_codex(tmux_session)
        elif provider == "gemini":
            return self._start_gemini(tmux_session)
        else:
            print(f"âŒ æœªçŸ¥çš„ provider: {provider}")
            return False

    def _start_provider_wezterm(self, provider: str) -> bool:
        runtime = self.runtime_dir / provider
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = self._get_start_cmd(provider)
        direction = "right" if provider == "codex" or not self.wezterm_panes else "bottom"
        parent_pane = self.wezterm_panes.get("codex") if provider == "gemini" and self.wezterm_panes else None

        backend = WeztermBackend()
        pane_id = backend.create_pane(start_cmd, str(Path.cwd()), direction=direction, percent=50, parent_pane=parent_pane)
        self.wezterm_panes[provider] = pane_id

        if provider == "codex":
            input_fifo = runtime / "input.fifo"
            output_fifo = runtime / "output.fifo"
            if not input_fifo.exists():
                os.mkfifo(input_fifo, 0o600)
            if not output_fifo.exists():
                os.mkfifo(output_fifo, 0o644)
            self._write_codex_session(runtime, None, input_fifo, output_fifo, pane_id=pane_id)
        else:
            self._write_gemini_session(runtime, None, pane_id=pane_id)

        print(f"âœ… {provider.capitalize()} å·²å¯åŠ¨ (wezterm pane: {pane_id})")
        return True

    def _get_start_cmd(self, provider: str) -> str:
        if provider == "codex":
            cmd = "codex --full-auto" if self.auto else "codex"
            if self.resume:
                session_file = Path.cwd() / ".codex-session"
                if session_file.exists():
                    try:
                        data = json.loads(session_file.read_text())
                        session_id = data.get("codex_session_id")
                        if session_id:
                            cmd = f"codex {'--full-auto ' if self.auto else ''}resume {session_id}"
                            print(f"ğŸ” Resuming Codex session: {session_id[:8]}...")
                    except Exception:
                        pass
            return cmd
        elif provider == "gemini":
            cmd = "gemini"
            if self.resume:
                import hashlib
                project_hash = hashlib.sha256(str(Path.cwd().resolve()).encode()).hexdigest()
                gemini_chats = Path.home() / ".gemini" / "tmp" / project_hash / "chats"
                if gemini_chats.exists() and any(gemini_chats.glob("session-*.json")):
                    cmd = "gemini -r latest"
                    print("ğŸ” Resuming Gemini session...")
            if self.auto:
                cmd = cmd.replace("gemini", "gemini --yolo", 1)
            return cmd
        return ""

    def _start_codex(self, tmux_session: str) -> bool:
        runtime = self.runtime_dir / "codex"
        runtime.mkdir(parents=True, exist_ok=True)

        input_fifo = runtime / "input.fifo"
        output_fifo = runtime / "output.fifo"

        if not input_fifo.exists():
            os.mkfifo(input_fifo, 0o600)
        if not output_fifo.exists():
            os.mkfifo(output_fifo, 0o644)

        start_cmd = "codex --full-auto" if self.auto else "codex"
        codex_resumed = False
        if self.resume:
            session_file = Path.cwd() / ".codex-session"
            if session_file.exists():
                try:
                    data = json.loads(session_file.read_text())
                    session_id = data.get("codex_session_id")
                    if session_id:
                        start_cmd = f"codex {'--full-auto ' if self.auto else ''}resume {session_id}"
                        print(f"ğŸ” Resuming Codex session: {session_id[:8]}...")
                        codex_resumed = True
                except Exception:
                    pass
            if not codex_resumed:
                print("â„¹ï¸ No Codex history found, starting fresh")

        bridge_script = self.script_dir / "lib" / "codex_dual_bridge.py"
        wrapper = f'''#!/bin/bash
SESSION_ID="{self.session_id}"
RUNTIME_DIR="{runtime}"
TMUX_SESSION="{tmux_session}"
BRIDGE_SCRIPT="{bridge_script}"
PYTHON_BIN="{sys.executable}"
SCRIPT_DIR="{self.script_dir}"
WORK_DIR="{os.getcwd()}"
INPUT_FIFO="{input_fifo}"
OUTPUT_FIFO="{output_fifo}"
TMUX_LOG_FILE="{runtime}/bridge_output.log"

echo $$ > "$RUNTIME_DIR/codex.pid"
export PYTHONPATH="$SCRIPT_DIR:${{PYTHONPATH:-}}"
export CODEX_SESSION_ID="$SESSION_ID"
export CODEX_RUNTIME_DIR="$RUNTIME_DIR"
export CODEX_INPUT_FIFO="$INPUT_FIFO"
export CODEX_OUTPUT_FIFO="$OUTPUT_FIFO"
export CODEX_TMUX_SESSION="$TMUX_SESSION"
export CODEX_TMUX_LOG="$TMUX_LOG_FILE"

CODEX_START_CMD={json.dumps(start_cmd)}

if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    cd "$WORK_DIR"
    tmux new-session -d -s "$TMUX_SESSION" "$CODEX_START_CMD"
    sleep 1
fi
tmux pipe-pane -o -t "$TMUX_SESSION" "cat >> '$TMUX_LOG_FILE'"

"$PYTHON_BIN" "$BRIDGE_SCRIPT" --runtime-dir "$RUNTIME_DIR" --session-id "$SESSION_ID" >>"$RUNTIME_DIR/bridge.log" 2>&1 &
BRIDGE_PID=$!
echo $BRIDGE_PID > "$RUNTIME_DIR/bridge.pid"

trap 'kill -TERM "$BRIDGE_PID" 2>/dev/null' EXIT
exec tmux attach -t "$TMUX_SESSION"
'''
        script_file = runtime / "wrapper.sh"
        script_file.write_text(wrapper)
        os.chmod(script_file, 0o755)

        self._write_codex_session(runtime, tmux_session, input_fifo, output_fifo)

        terminal = self._detect_terminal()
        if terminal == "tmux":
            if platform.system() == "Darwin":
                # macOS: ç›´æ¥æ‰§è¡Œ wrapper.shï¼Œé¿å… launcher åµŒå¥—å¯¼è‡´æƒé™äº¤äº’å¤±è´¥
                os.execv("/bin/bash", ["/bin/bash", str(script_file)])
            else:
                subprocess.run(["tmux", "new-session", "-d", "-s", f"launcher-{tmux_session}", str(script_file)], check=True)
        else:
            subprocess.Popen([terminal, "-e", str(script_file)])

        print(f"âœ… Codex å·²å¯åŠ¨ (tmux: {tmux_session})")
        return True

    def _start_gemini(self, tmux_session: str) -> bool:
        runtime = self.runtime_dir / "gemini"
        runtime.mkdir(parents=True, exist_ok=True)

        start_cmd = "gemini"
        gemini_resumed = False
        if self.resume:
            # Check if Gemini has history in ~/.gemini/tmp/<hash>/chats/
            import hashlib
            project_hash = hashlib.sha256(str(Path.cwd().resolve()).encode()).hexdigest()
            gemini_chats = Path.home() / ".gemini" / "tmp" / project_hash / "chats"
            if gemini_chats.exists() and any(gemini_chats.glob("session-*.json")):
                start_cmd = "gemini -r latest"
                print("ğŸ” Resuming Gemini session...")
                gemini_resumed = True
            else:
                print("â„¹ï¸ No Gemini history found, starting fresh")
        if self.auto:
            start_cmd = start_cmd.replace("gemini", "gemini --yolo", 1)

        wrapper = f'''#!/bin/bash
RUNTIME_DIR="{runtime}"
TMUX_SESSION="{tmux_session}"
WORK_DIR="{os.getcwd()}"

echo $$ > "$RUNTIME_DIR/gemini.pid"
export GEMINI_RUNTIME_DIR="$RUNTIME_DIR"
export GEMINI_TMUX_SESSION="$TMUX_SESSION"

GEMINI_START_CMD={json.dumps(start_cmd)}

cd "$WORK_DIR"
if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    tmux new-session -d -s "$TMUX_SESSION" "$GEMINI_START_CMD"
    sleep 1
fi

exec tmux attach -t "$TMUX_SESSION"
'''
        script_file = runtime / "wrapper.sh"
        script_file.write_text(wrapper)
        os.chmod(script_file, 0o755)

        self._write_gemini_session(runtime, tmux_session)

        # åˆ›å»ºå¯åŠ¨è„šæœ¬
        wrapper = f'''#!/bin/bash
cd "{os.getcwd()}"
tmux new-session -d -s "{tmux_session}" 2>/dev/null || true
tmux send-keys -t "{tmux_session}" "{start_cmd}" Enter
exec tmux attach -t "{tmux_session}"
'''
        script_file.write_text(wrapper)

        terminal = self._detect_terminal()
        if terminal == "tmux":
            # çº¯ tmux æ¨¡å¼
            subprocess.run(["tmux", "new-session", "-d", "-s", tmux_session], check=True, cwd=os.getcwd())
            time.sleep(0.3)
            subprocess.run(["tmux", "send-keys", "-t", tmux_session, start_cmd, "Enter"], check=True)
        else:
            # æ‰“å¼€æ–°ç»ˆç«¯çª—å£
            subprocess.Popen([terminal, "--", str(script_file)])

        print(f"âœ… Gemini å·²å¯åŠ¨ (tmux: {tmux_session})")
        return True

    def _write_codex_session(self, runtime, tmux_session, input_fifo, output_fifo, pane_id=None):
        session_file = Path.cwd() / ".codex-session"
        data = {}
        if session_file.exists():
            try:
                data = json.loads(session_file.read_text())
            except Exception:
                pass

        data.update({
            "session_id": self.session_id,
            "runtime_dir": str(runtime),
            "input_fifo": str(input_fifo),
            "output_fifo": str(output_fifo),
            "terminal": self.terminal_type,
            "tmux_session": tmux_session,
            "pane_id": pane_id,
            "tmux_log": str(runtime / "bridge_output.log"),
            "work_dir": str(Path.cwd()),
            "active": True,
            "started_at": time.strftime("%Y-%m-%d %H:%M:%S"),
        })
        session_file.write_text(json.dumps(data, ensure_ascii=False, indent=2))

    def _write_gemini_session(self, runtime, tmux_session, pane_id=None):
        session_file = Path.cwd() / ".gemini-session"
        data = {
            "session_id": self.session_id,
            "runtime_dir": str(runtime),
            "terminal": self.terminal_type,
            "tmux_session": tmux_session,
            "pane_id": pane_id,
            "work_dir": str(Path.cwd()),
            "active": True,
            "started_at": time.strftime("%Y-%m-%d %H:%M:%S"),
        }
        session_file.write_text(json.dumps(data, ensure_ascii=False, indent=2))

    def _start_claude(self) -> int:
        print("ğŸš€ å¯åŠ¨ Claude...")

        env = os.environ.copy()
        if "codex" in self.providers:
            runtime = self.runtime_dir / "codex"
            env["CODEX_SESSION_ID"] = self.session_id
            env["CODEX_RUNTIME_DIR"] = str(runtime)
            env["CODEX_INPUT_FIFO"] = str(runtime / "input.fifo")
            env["CODEX_OUTPUT_FIFO"] = str(runtime / "output.fifo")
            env["CODEX_TERMINAL"] = self.terminal_type
            if self.terminal_type == "wezterm":
                env["CODEX_WEZTERM_PANE"] = self.wezterm_panes.get("codex", "")
            else:
                env["CODEX_TMUX_SESSION"] = self.tmux_sessions.get("codex", "")

        if "gemini" in self.providers:
            runtime = self.runtime_dir / "gemini"
            env["GEMINI_SESSION_ID"] = self.session_id
            env["GEMINI_RUNTIME_DIR"] = str(runtime)
            env["GEMINI_TERMINAL"] = self.terminal_type
            if self.terminal_type == "wezterm":
                env["GEMINI_WEZTERM_PANE"] = self.wezterm_panes.get("gemini", "")
            else:
                env["GEMINI_TMUX_SESSION"] = self.tmux_sessions.get("gemini", "")

        cmd = ["claude"]
        if self.auto:
            cmd.append("--dangerously-skip-permissions")
        if self.resume:
            # Check if Claude has conversation history in current directory
            claude_history = Path.cwd() / ".claude" / "conversation.json"
            if claude_history.exists():
                cmd.append("-c")
                print("ğŸ” Resuming Claude session...")
            else:
                print("â„¹ï¸ No Claude history found, starting fresh")

        print(f"ğŸ“‹ ä¼šè¯ID: {self.session_id}")
        print(f"ğŸ“ è¿è¡Œç›®å½•: {self.runtime_dir}")
        print(f"ğŸ”Œ æ´»è·ƒåç«¯: {', '.join(self.providers)}")
        print()
        print("ğŸ¯ å¯ç”¨å‘½ä»¤:")
        if "codex" in self.providers:
            print("   cask/cask-w/cping/cpend - Codex é€šä¿¡")
        if "gemini" in self.providers:
            print("   gask/gask-w/gping/gpend - Gemini é€šä¿¡")
        print()
        print(f"æ‰§è¡Œ: {' '.join(cmd)}")

        try:
            return subprocess.run(cmd, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr, env=env).returncode
        except KeyboardInterrupt:
            print("\nâš ï¸ ç”¨æˆ·ä¸­æ–­")
            return 130

    def cleanup(self):
        if self._cleaned:
            return
        self._cleaned = True
        print("\nğŸ§¹ æ¸…ç†ä¼šè¯èµ„æº...")

        if self.terminal_type == "wezterm":
            backend = WeztermBackend()
            for provider, pane_id in self.wezterm_panes.items():
                if pane_id:
                    backend.kill_pane(pane_id)
        else:
            for provider, tmux_session in self.tmux_sessions.items():
                subprocess.run(["tmux", "kill-session", "-t", tmux_session], stderr=subprocess.DEVNULL)
                subprocess.run(["tmux", "kill-session", "-t", f"launcher-{tmux_session}"], stderr=subprocess.DEVNULL)

        for session_file in [Path.cwd() / ".codex-session", Path.cwd() / ".gemini-session"]:
            if session_file.exists():
                try:
                    data = json.loads(session_file.read_text())
                    data["active"] = False
                    data["ended_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
                    session_file.write_text(json.dumps(data, ensure_ascii=False, indent=2))
                except Exception:
                    pass

        import shutil
        if self.runtime_dir.exists():
            shutil.rmtree(self.runtime_dir, ignore_errors=True)

        print("âœ… æ¸…ç†å®Œæˆ")

    def run_up(self) -> int:
        print(f"ğŸš€ Claude AI å¯åŠ¨å™¨")
        print(f"ğŸ“… {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"ğŸ”Œ åç«¯: {', '.join(self.providers)}")
        print("=" * 50)

        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, lambda s, f: (self.cleanup(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (self.cleanup(), sys.exit(0)))

        for provider in self.providers:
            if not self._start_provider(provider):
                return 1
            time.sleep(1)

        time.sleep(2)

        if self.no_claude:
            print("âœ… åç«¯å·²å¯åŠ¨ï¼ˆ--no-claude æ¨¡å¼ï¼‰")
            print()
            for provider in self.providers:
                if self.terminal_type == "wezterm":
                    pane = self.wezterm_panes.get(provider, "")
                    if pane:
                        print(f"   {provider}: wezterm cli activate-pane --pane-id {pane}")
                else:
                    tmux = self.tmux_sessions.get(provider, "")
                    if tmux:
                        print(f"   {provider}: tmux attach -t {tmux}")
            print()
            print(f"ç»ˆæ­¢: claude_bridge kill {' '.join(self.providers)}")
            atexit.unregister(self.cleanup)
            return 0

        try:
            return self._start_claude()
        finally:
            self.cleanup()


def cmd_up(args):
    launcher = AILauncher(
        providers=args.providers or ["codex"],
        resume=args.resume,
        auto=args.auto,
        no_claude=args.no_claude,
    )
    return launcher.run_up()


def cmd_status(args):
    providers = args.providers or ["codex", "gemini"]
    results = {}

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            results[provider] = {"status": "æœªé…ç½®", "active": False}
            continue

        try:
            data = json.loads(session_file.read_text())
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal == "wezterm" else data.get("tmux_session", "")
            active = data.get("active", False)

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                alive = backend.is_alive(pane_id)
            elif pane_id:
                result = subprocess.run(["tmux", "has-session", "-t", pane_id], capture_output=True)
                alive = result.returncode == 0
            else:
                alive = False

            results[provider] = {
                "status": "è¿è¡Œä¸­" if (active and alive) else "å·²åœæ­¢",
                "active": active and alive,
                "terminal": terminal,
                "pane_id": pane_id,
                "runtime_dir": data.get("runtime_dir", ""),
            }
        except Exception as e:
            results[provider] = {"status": f"é”™è¯¯: {e}", "active": False}

    print("ğŸ“Š AI åç«¯çŠ¶æ€:")
    for provider, info in results.items():
        icon = "âœ…" if info.get("active") else "âŒ"
        print(f"  {icon} {provider.capitalize()}: {info['status']}")
        if info.get("pane_id"):
            print(f"     {info.get('terminal', 'tmux')}: {info['pane_id']}")

    return 0


def cmd_kill(args):
    providers = args.providers or ["codex", "gemini"]

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print(f"âš ï¸ {provider}: æœªæ‰¾åˆ°ä¼šè¯æ–‡ä»¶")
            continue

        try:
            data = json.loads(session_file.read_text())
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal == "wezterm" else data.get("tmux_session", "")

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                backend.kill_pane(pane_id)
            elif pane_id:
                subprocess.run(["tmux", "kill-session", "-t", pane_id], stderr=subprocess.DEVNULL)
                subprocess.run(["tmux", "kill-session", "-t", f"launcher-{pane_id}"], stderr=subprocess.DEVNULL)

            data["active"] = False
            data["ended_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
            session_file.write_text(json.dumps(data, ensure_ascii=False, indent=2))

            print(f"âœ… {provider.capitalize()} å·²ç»ˆæ­¢")
        except Exception as e:
            print(f"âŒ {provider}: {e}")

    return 0


def cmd_restore(args):
    providers = args.providers or ["codex"]

    for provider in providers:
        session_file = Path.cwd() / f".{provider}-session"
        if not session_file.exists():
            print(f"âš ï¸ {provider}: æœªæ‰¾åˆ°ä¼šè¯æ–‡ä»¶")
            continue

        try:
            data = json.loads(session_file.read_text())
            terminal = data.get("terminal", "tmux")
            pane_id = data.get("pane_id") if terminal == "wezterm" else data.get("tmux_session", "")
            active = data.get("active", False)

            if terminal == "wezterm" and pane_id:
                backend = WeztermBackend()
                if backend.is_alive(pane_id):
                    backend.activate(pane_id)
                    return 0
            elif pane_id:
                result = subprocess.run(["tmux", "has-session", "-t", pane_id], capture_output=True)
                if result.returncode == 0:
                    subprocess.run(["tmux", "attach-session", "-t", pane_id])
                    return 0

            if not active:
                session_id = data.get("codex_session_id") if provider == "codex" else None
                if session_id:
                    print(f"â„¹ï¸ {provider}: ä¼šè¯å·²ç»“æŸï¼Œä½†å¯æ¢å¤å†å²ä¼šè¯")
                    print(f"   ä¼šè¯ID: {session_id[:8]}...")
                    print(f"   ä½¿ç”¨: claude_bridge up {provider} -r")
                else:
                    print(f"âš ï¸ {provider}: ä¼šè¯å·²ç»“æŸï¼Œæ— å¯æ¢å¤å†å²")
            else:
                print(f"âš ï¸ {provider}: ä¼šè¯å·²ä¸¢å¤±ï¼Œä½¿ç”¨ claude_bridge up {provider} -r é‡å¯")

        except Exception as e:
            print(f"âŒ {provider}: {e}")

    return 0


def cmd_update(args):
    """Update claude_bridge to latest version"""
    import shutil
    import urllib.request
    import tarfile

    install_dir = Path.home() / ".local/share/codex-dual"
    repo_url = "https://github.com/bfly123/claude_bridge"

    print("ğŸ”„ Checking for updates...")

    # Method 1: Prefer git if available
    if shutil.which("git") and (install_dir / ".git").exists():
        print("ğŸ“¦ Updating via git pull...")
        result = subprocess.run(
            ["git", "-C", str(install_dir), "pull", "--ff-only"],
            capture_output=True, text=True
        )
        if result.returncode == 0:
            print(result.stdout.strip() if result.stdout.strip() else "Already up to date.")
            print("ğŸ”§ Reinstalling...")
            subprocess.run([str(install_dir / "install.sh"), "install"])
            print("âœ… Update complete!")
            return 0
        else:
            print(f"âš ï¸ Git pull failed: {result.stderr.strip()}")
            print("Falling back to tarball download...")

    # Method 2: Download tarball
    tarball_url = f"{repo_url}/archive/refs/heads/main.tar.gz"
    tmp_dir = Path("/tmp/claude_bridge_update")

    try:
        print(f"ğŸ“¥ Downloading latest version...")
        if tmp_dir.exists():
            shutil.rmtree(tmp_dir)
        tmp_dir.mkdir(parents=True, exist_ok=True)
        tarball_path = tmp_dir / "main.tar.gz"

        urllib.request.urlretrieve(tarball_url, tarball_path)

        print("ğŸ“‚ Extracting...")
        with tarfile.open(tarball_path, "r:gz") as tar:
            tar.extractall(tmp_dir)

        extracted_dir = tmp_dir / "claude_bridge-main"

        print("ğŸ”§ Installing...")
        subprocess.run([str(extracted_dir / "install.sh"), "install"], check=True)

        print("âœ… Update complete!")
        return 0

    except Exception as e:
        print(f"âŒ Update failed: {e}")
        return 1

    finally:
        if tmp_dir.exists():
            shutil.rmtree(tmp_dir, ignore_errors=True)


def main():
    parser = argparse.ArgumentParser(description="Claude AI ç»Ÿä¸€å¯åŠ¨å™¨", add_help=True)
    subparsers = parser.add_subparsers(dest="command", help="å­å‘½ä»¤")

    # up å­å‘½ä»¤
    up_parser = subparsers.add_parser("up", help="å¯åŠ¨ AI åç«¯")
    up_parser.add_argument("providers", nargs="*", choices=["codex", "gemini"], help="è¦å¯åŠ¨çš„åç«¯")
    up_parser.add_argument("-r", "--resume", action="store_true", help="æ¢å¤ä¸Šä¸‹æ–‡")
    up_parser.add_argument("-a", "--auto", action="store_true", help="å…¨è‡ªåŠ¨æƒé™æ¨¡å¼")
    up_parser.add_argument("--no-claude", action="store_true", help="ä¸å¯åŠ¨ Claude ä¸»çª—å£")

    # status å­å‘½ä»¤
    status_parser = subparsers.add_parser("status", help="æ£€æŸ¥çŠ¶æ€")
    status_parser.add_argument("providers", nargs="*", default=[], help="è¦æ£€æŸ¥çš„åç«¯ (codex/gemini)")

    # kill å­å‘½ä»¤
    kill_parser = subparsers.add_parser("kill", help="ç»ˆæ­¢ä¼šè¯")
    kill_parser.add_argument("providers", nargs="*", default=[], help="è¦ç»ˆæ­¢çš„åç«¯ (codex/gemini)")

    # restore å­å‘½ä»¤
    restore_parser = subparsers.add_parser("restore", help="æ¢å¤/attach ä¼šè¯")
    restore_parser.add_argument("providers", nargs="*", default=[], help="è¦æ¢å¤çš„åç«¯ (codex/gemini)")

    # update å­å‘½ä»¤
    update_parser = subparsers.add_parser("update", help="Update to latest version")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 0

    if args.command == "up":
        return cmd_up(args)
    elif args.command == "status":
        return cmd_status(args)
    elif args.command == "kill":
        return cmd_kill(args)
    elif args.command == "restore":
        return cmd_restore(args)
    elif args.command == "update":
        return cmd_update(args)
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    sys.exit(main())
