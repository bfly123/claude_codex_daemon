# Codexè‡ªåŠ¨ç®¡ç†å­è¿›ç¨‹æ–¹æ¡ˆ

## é—®é¢˜èƒŒæ™¯

éœ€è¦å®ç°ä¸€ä¸ªå®Œå…¨è‡ªåŠ¨åŒ–çš„CodexæœåŠ¡ï¼Œæ»¡è¶³éœ€æ±‚ï¼š
1. **å¯¹è¯è¿ç»­æ€§**ï¼šCodexèƒ½è®°ä½ä¹‹å‰çš„å¯¹è¯å†…å®¹
2. **çº¯å‡€è¾“å‡º**ï¼šåªè¿”å›æœ€ç»ˆç»“æœï¼Œä¸åŒ…å«æ€è€ƒè¿‡ç¨‹
3. **è‡ªåŠ¨ç®¡ç†**ï¼šClaudeå¯åŠ¨æ—¶è‡ªåŠ¨æ‹‰èµ·Codexï¼Œé€€å‡ºæ—¶è‡ªåŠ¨æ¸…ç†
4. **å®ä¾‹éš”ç¦»**ï¼šå¤šä¸ªClaudeè¿›ç¨‹çš„Codexäº’ä¸å¹²æ‰°

## æ–¹æ¡ˆé€‰æ‹©ï¼šClaudeå­è¿›ç¨‹è‡ªåŠ¨ç®¡ç†æ¶æ„

### æ ¸å¿ƒæ¶æ„
```
[Claude Codeä¸»è¿›ç¨‹]
    â”œâ”€â”€ fork() --> [Codexå­è¿›ç¨‹A] <--> [è‡ªåŠ¨ç”ŸæˆSocketA] <--> [å†…å­˜å†å²A]
    â”œâ”€â”€ fork() --> [Codexå­è¿›ç¨‹B] <--> [è‡ªåŠ¨ç”ŸæˆSocketB] <--> [å†…å­˜å†å²B]
    â””â”€â”€ fork() --> [Codexå­è¿›ç¨‹C] <--> [è‡ªåŠ¨ç”ŸæˆSocketC] <--> [å†…å­˜å†å²C]
```

### è‡ªåŠ¨ç®¡ç†åŸåˆ™
- **å­è¿›ç¨‹æ¨¡å¼**ï¼šCodexä½œä¸ºClaudeçš„å­è¿›ç¨‹è¿è¡Œ
- **è‡ªåŠ¨è·¯å¾„**ï¼šSocketè·¯å¾„åŸºäºè¿›ç¨‹IDè‡ªåŠ¨ç”Ÿæˆ
- **ç”Ÿå‘½å‘¨æœŸç»‘å®š**ï¼šCodexéšClaudeå¯åŠ¨/é€€å‡º
- **å¼‚å¸¸æ¢å¤**ï¼šå­è¿›ç¨‹å´©æºƒæ—¶Claudeè‡ªåŠ¨é‡æ–°æ‹‰èµ·

### æŠ€æœ¯è®¾è®¡

#### 1. è‡ªåŠ¨ç”ŸæˆIPCæœºåˆ¶
- **é€‰æ‹©**ï¼šUnix Socket (æœ¬åœ°æ€§èƒ½å……è¶³)
- **è·¯å¾„æ¨¡å¼**ï¼š`/tmp/codex-{claude_pid}-{uuid}.sock`
- **æƒé™**ï¼š0600 (ç”¨æˆ·ç§æœ‰)
- **è‡ªåŠ¨ç”Ÿæˆ**ï¼šClaudeå¯åŠ¨æ—¶è‡ªåŠ¨ç”Ÿæˆå”¯ä¸€è·¯å¾„

##### è‡ªåŠ¨è·¯å¾„ç”Ÿæˆï¼š
```python
import os
import uuid

def generate_socket_path():
    claude_pid = os.getppid()  # Claudeçˆ¶è¿›ç¨‹ID
    unique_id = str(uuid.uuid4())[:8]  # çŸ­UUID
    socket_path = f"/tmp/codex-{claude_pid}-{unique_id}.sock"
    return socket_path
```

##### ä¸´æ—¶ç›®å½•ç»“æ„ï¼š
```
/tmp/
â”œâ”€â”€ codex-12345-a1b2c3d4.sock      # Claudeè¿›ç¨‹12345çš„Codexå®ä¾‹
â”œâ”€â”€ codex-12345-e5f6g7h8.sock      # Claudeè¿›ç¨‹12345çš„ç¬¬äºŒä¸ªå®ä¾‹(å¦‚æœéœ€è¦)
â”œâ”€â”€ codex-67890-i9j0k1l2.sock      # Claudeè¿›ç¨‹67890çš„Codexå®ä¾‹
â””â”€â”€ codex-67890-m3n4o5p6.sock      # Claudeè¿›ç¨‹67890çš„ç¬¬äºŒä¸ªå®ä¾‹
```

#### 2. æ”¯æŒå®ä¾‹ç»‘å®šçš„JSONåè®®

##### è¯·æ±‚æ ¼å¼ï¼ˆåŒ…å«å®ä¾‹ç»‘å®šå­—æ®µå’Œprofileé…ç½®ï¼‰ï¼š
```json
{
  "instance_id": "abc123def",
  "type": "query",
  "message": "ç”¨æˆ·çš„é—®é¢˜",
  "config": {
    "show_reasoning": false,
    "output_format": "final_only",
    "profile": "high"
  },
  "timestamp": 1734987654
}
```

##### é…ç½®å˜æ›´è¯·æ±‚æ ¼å¼ï¼š
é…ç½®è¯·æ±‚ç»Ÿä¸€ä½¿ç”¨ `type=config`ï¼Œé€šè¿‡ `action` æŒ‡å®šå˜æ›´ç›®æ ‡ï¼š
- `set_profile`ï¼šåˆ‡æ¢æ¨¡å‹å¼ºåº¦ (`profile` å–å€¼ `high|default|low`)
- `set_reasoning`ï¼šæ§åˆ¶æ˜¯å¦å‘Claudeå±•ç¤ºæ¨ç† (`show_reasoning` å–å€¼ `true|false`)
- `set_output_format`ï¼šæ§åˆ¶æ˜¯å¦ä»…è¾“å‡ºæœ€ç»ˆç­”æ¡ˆ (`output_format` å–å€¼ `final_only|final_with_details`)

```jsonc
// åˆ‡æ¢æ¨¡å‹å¼ºåº¦
{
  "instance_id": "abc123def",
  "type": "config",
  "action": "set_profile",
  "profile": "low",
  "timestamp": 1734987654
}

// åˆ‡æ¢æ¨ç†å±•ç¤ºå¼€å…³
{
  "instance_id": "abc123def",
  "type": "config",
  "action": "set_reasoning",
  "show_reasoning": false,
  "timestamp": 1734987654
}

// åˆ‡æ¢è¾“å‡ºæ ¼å¼
{
  "instance_id": "abc123def",
  "type": "config",
  "action": "set_output_format",
  "output_format": "final_only",
  "timestamp": 1734987654
}
```

##### å“åº”æ ¼å¼ï¼ˆåŒ…å«å½“å‰profileä¿¡æ¯ï¼‰ï¼š
```json
{
  "instance_id": "abc123def",
  "type": "response",
  "message": "Codexçš„å›ç­”",
  "status": "success",
  "metadata": {
    "context_length": 15,
    "processing_time": 0.5,
    "active_profile": "high",
    "show_reasoning": false,
    "output_format": "final_only"
  }
}
```

##### é…ç½®å˜æ›´å“åº”æ ¼å¼ï¼š
```json
{
  "instance_id": "abc123def",
  "type": "config_response",
  "action": "set_profile",
  "profile": "low",
  "status": "success",
  "message": "Profileå·²æ›´æ–°ä¸ºlow"
}

{
  "instance_id": "abc123def",
  "type": "config_response",
  "action": "set_reasoning",
  "show_reasoning": false,
  "status": "success",
  "message": "Show Reasoning å·²å…³é—­"
}

{
  "instance_id": "abc123def",
  "type": "config_response",
  "action": "set_output_format",
  "output_format": "final_only",
  "status": "success",
  "message": "Output Format å·²åˆ‡æ¢ä¸º final_only"
}
```

##### é”™è¯¯æ ¼å¼ï¼š
```json
{
  "instance_id": "abc123def",
  "type": "error",
  "message": "é”™è¯¯ä¿¡æ¯",
  "status": "error",
  "error_code": "CONNECTION_FAILED"
}
```

##### Codexå­è¿›ç¨‹æ ¸å¿ƒé€»è¾‘ï¼ˆèŠ‚é€‰ï¼‰ï¼š
```python
import json
import os
import socket
import time


class CodexProcess:
    def __init__(self, socket_path, instance_id):
        self.socket_path = socket_path
        self.instance_id = instance_id
        self.conversation_history = []
        self.current_profile = "default"
        self.show_reasoning = False
        self.output_format = "final_only"

    def _validate_schema(self, request):
        required_fields = ["instance_id", "type", "timestamp"]
        for field in required_fields:
            if field not in request:
                raise ValueError(f"ç¼ºå°‘å¿…éœ€å­—æ®µ: {field}")
        if request["instance_id"] != self.instance_id:
            raise ValueError("å®ä¾‹IDä¸åŒ¹é…")
        request.setdefault("config", {})
        config = request["config"]
        config.setdefault("profile", self.current_profile)
        config.setdefault("show_reasoning", self.show_reasoning)
        config.setdefault("output_format", self.output_format)
        if config["profile"] not in ["high", "low", "default"]:
            config["profile"] = self.current_profile
        return request

    def handle_request(self, request):
        validated = self._validate_schema(request)
        kind = validated["type"]
        if kind == "config":
            return self._handle_config_request(validated)
        if kind == "query":
            return self._process_query(validated)
        if kind == "restore_history":
            return self._handle_restore_history(validated)
        return {
            "instance_id": self.instance_id,
            "type": "error",
            "message": f"æœªçŸ¥è¯·æ±‚ç±»å‹: {kind}",
            "status": "error",
            "error_code": "UNKNOWN_REQUEST_TYPE"
        }

    def _handle_config_request(self, request):
        action = request.get("action")
        if action == "set_profile":
            profile = request.get("profile", "default")
            if profile in ["high", "low", "default"]:
                old = self.current_profile
                self.current_profile = profile
                self._log_config_change("profile", old, profile)
                return {
                    "instance_id": self.instance_id,
                    "type": "config_response",
                    "action": action,
                    "profile": profile,
                    "status": "success",
                    "message": f"Profileå·²æ›´æ–°ä¸º{profile}"
                }
            return {
                "instance_id": self.instance_id,
                "type": "error",
                "message": f"æ— æ•ˆçš„profile: {profile}",
                "status": "error",
                "error_code": "INVALID_PROFILE"
            }
        if action == "set_reasoning":
            new_state = bool(request.get("show_reasoning", False))
            old = self.show_reasoning
            self.show_reasoning = new_state
            self._log_config_change("show_reasoning", old, new_state)
            return {
                "instance_id": self.instance_id,
                "type": "config_response",
                "action": action,
                "show_reasoning": new_state,
                "status": "success",
                "message": f"Show Reasoning å·²{ 'å¼€å¯' if new_state else 'å…³é—­'}"
            }
        if action == "set_output_format":
            new_format = request.get("output_format", "final_only")
            if new_format not in ["final_only", "final_with_details"]:
                return {
                    "instance_id": self.instance_id,
                    "type": "error",
                    "message": f"æ— æ•ˆçš„è¾“å‡ºæ ¼å¼: {new_format}",
                    "status": "error",
                    "error_code": "INVALID_OUTPUT_FORMAT"
                }
            old = self.output_format
            self.output_format = new_format
            self._log_config_change("output_format", old, new_format)
            return {
                "instance_id": self.instance_id,
                "type": "config_response",
                "action": action,
                "output_format": new_format,
                "status": "success",
                "message": f"Output Format å·²åˆ‡æ¢ä¸º {new_format}"
            }
        return {
            "instance_id": self.instance_id,
            "type": "error",
            "message": f"æœªçŸ¥é…ç½®æ“ä½œ: {action}",
            "status": "error",
            "error_code": "UNKNOWN_CONFIG_ACTION"
        }

    def _process_query(self, request):
        profile = request["config"]["profile"]
        params = self._get_model_params_for_profile(profile)
        self.conversation_history.append({
            "role": "user",
            "content": request["message"],
            "timestamp": request["timestamp"],
            "profile": profile
        })
        response_text = self._call_codex_with_params(request["message"], params)
        self.conversation_history.append({
            "role": "assistant",
            "content": response_text,
            "timestamp": int(time.time()),
            "profile": profile
        })
        if len(self.conversation_history) > 200:
            self.conversation_history = self.conversation_history[-200:]
        return {
            "instance_id": self.instance_id,
            "type": "response",
            "message": response_text,
            "status": "success",
            "metadata": {
                "context_length": len(self.conversation_history),
                "active_profile": profile,
                "show_reasoning": self.show_reasoning,
                "output_format": self.output_format
            }
        }

    def _handle_restore_history(self, request):
        history = request.get("history", [])
        self.conversation_history = history
        profile = request.get("profile", self.current_profile)
        if profile in ["high", "low", "default"]:
            self.current_profile = profile
        self.show_reasoning = bool(request.get("show_reasoning", self.show_reasoning))
        output = request.get("output_format", self.output_format)
        if output in ["final_only", "final_with_details"]:
            self.output_format = output
        return {
            "instance_id": self.instance_id,
            "type": "restore_response",
            "message": f"å·²æ¢å¤ {len(history)} æ¡å†å²ï¼Œå½“å‰profile: {self.current_profile}",
            "status": "success"
        }

    def _log_config_change(self, config_type, old, new):
        print(f"[Codex Config] {config_type}: {old} -> {new}")

    def _get_model_params_for_profile(self, profile):
        mapping = {
            "high": {"temperature": 0.1, "max_tokens": 4000, "top_p": 0.95},
            "low": {"temperature": 0.3, "max_tokens": 1000, "top_p": 0.9},
            "default": {"temperature": 0.2, "max_tokens": 2000, "top_p": 0.92}
        }
        return mapping.get(profile, mapping["default"])

    def _call_codex_with_params(self, message, params):
        # çœŸå®å®ç°ä¸­ä¼šè°ƒç”¨æ¨¡å‹æ¨ç†ï¼Œè¿™é‡Œä»…ä¸ºç¤ºæ„
        depth = params.get("max_tokens")
        return f"æ¨¡æ‹Ÿå›ç­”({depth} tokens): {message}"

    def _save_history(self):
        history_file = self.socket_path.replace('.sock', '-history.json')
        data = {
            "instance_id": self.instance_id,
            "conversation_history": self.conversation_history,
            "current_profile": self.current_profile,
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "saved_at": int(time.time())
        }
        with open(history_file, 'w') as f:
            json.dump(data, f, indent=2)
        os.chmod(history_file, 0o600)

    def _load_history_securely(self):
        history_file = self.socket_path.replace('.sock', '-history.json')
        if not os.path.exists(history_file):
            return
        with open(history_file, 'r') as f:
            data = json.load(f)
        if data.get("instance_id") != self.instance_id:
            return
        self.conversation_history = data.get("conversation_history", [])
        profile = data.get("current_profile", "default")
        if profile in ["high", "low", "default"]:
            self.current_profile = profile
        self.show_reasoning = bool(data.get("show_reasoning", False))
        output = data.get("output_format", "final_only")
        if output in ["final_only", "final_with_details"]:
            self.output_format = output
```
#### 3. Claudeå†…éƒ¨å­è¿›ç¨‹æ¶æ„
- **æ¿€æ´»è§¦å‘**ï¼šClaudeå†…éƒ¨æ£€æµ‹åˆ°é¦–æ¬¡Codexå‘½ä»¤æ—¶è‡ªåŠ¨æ¿€æ´»
- **è¿›ç¨‹ç”Ÿæˆ**ï¼šClaudeä¸»è¿›ç¨‹fork()ç”ŸæˆCodexå­è¿›ç¨‹
- **å®ä¾‹ç»‘å®š**ï¼šç”Ÿæˆå”¯ä¸€instance_idï¼Œç»‘å®šsocketè·¯å¾„å’Œå­è¿›ç¨‹PID
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šClaudeå®Œå…¨æ§åˆ¶Codexçš„å¯åŠ¨ã€ç›‘æ§ã€åœæ­¢å’Œæ¸…ç†

##### Claudeä¸»å¯¼çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼š
```python
import json
import os
import socket
import time


class ClaudeCodexManager:
    def __init__(self):
        self.instance_id = None
        self.socket_path = None
        self.codex_pid = None
        self.history_file = None
        self.codex_active = False
        self.current_profile = "default"  # æ·»åŠ profileçŠ¶æ€
        self.show_reasoning = False       # æ˜¯å¦åœ¨Claudeä¾§å±•ç¤ºæ¨ç†
        self.output_format = "final_only" # è¾“å‡ºæ¨¡å¼: final_only/final_with_details

    def auto_activate_on_first_use(self):
        """é¦–æ¬¡ä½¿ç”¨æ—¶è‡ªåŠ¨æ¿€æ´»"""
        if not self.codex_active:
            self.instance_id = self._generate_instance_id()
            self.socket_path = f"/tmp/codex-{os.getppid()}-{self.instance_id}.sock"
            self.history_file = self.socket_path.replace('.sock', '-history.json')

            # fork()åˆ›å»ºå­è¿›ç¨‹
            self.codex_pid = os.fork()
            if self.codex_pid == 0:  # å­è¿›ç¨‹
                self._run_codex_child_process()
                os._exit(0)
            else:  # Claudeçˆ¶è¿›ç¨‹
                self.codex_active = True
                self._setup_child_monitor()

    def send_to_codex(self, message):
        """å‘Codexå®ä¾‹å‘é€æŸ¥è¯¢"""
        if not self.codex_active:
            self.auto_activate_on_first_use()

        request = {
            "instance_id": self.instance_id,
            "type": "query",
            "message": message,
            "config": {
                "profile": self.current_profile,
                "show_reasoning": self.show_reasoning,
                "output_format": self.output_format
            },
            "timestamp": int(time.time())
        }

        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.send(json.dumps(request).encode())
            response = json.loads(sock.recv(4096).decode())
            sock.close()
            if response.get("instance_id") != self.instance_id:
                raise RuntimeError("å®ä¾‹IDä¸åŒ¹é…")
            return response
        except Exception as exc:
            raise RuntimeError(f"ä¸Codexé€šä¿¡å¤±è´¥: {exc}")


    def _run_codex_child_process(self):
        """å­è¿›ç¨‹ä¸­è¿è¡ŒCodexæœåŠ¡"""
        # å¯åŠ¨Codexå®ˆæŠ¤è¿›ç¨‹ï¼Œç›‘å¬ä¸“ç”¨socket
        from codex_process import CodexProcess
        codex = CodexProcess(self.socket_path, self.instance_id)
        codex.run()

    def _setup_child_monitor(self):
        """è®¾ç½®å­è¿›ç¨‹ç›‘æ§"""
        import threading
        import os

        def monitor_child():
            while self.codex_active:
                try:
                    # æ£€æŸ¥å­è¿›ç¨‹çŠ¶æ€
                    os.waitpid(self.codex_pid, os.WNOHANG)
                except OSError:
                    # å­è¿›ç¨‹å¼‚å¸¸é€€å‡ºï¼ŒClaudeé‡æ–°æ‹‰èµ·
                    print("Codexè¿›ç¨‹å¼‚å¸¸é€€å‡ºï¼Œæ­£åœ¨é‡æ–°å¯åŠ¨...")
                    self._restart_codex_process()
                    break
                time.sleep(2)

        monitor_thread = threading.Thread(target=monitor_child, daemon=True)
        monitor_thread.start()

    def claude_cleanup_on_exit(self):
        """Claudeé€€å‡ºæ—¶ç»Ÿä¸€å›æ”¶èµ„æº"""
        if self.codex_active and self.codex_pid:
            try:
                # å‘é€SIGTERMä¿¡å·è®©Codexä¼˜é›…é€€å‡º
                os.kill(self.codex_pid, signal.SIGTERM)
                os.waitpid(self.codex_pid, 0)  # ç­‰å¾…å­è¿›ç¨‹é€€å‡º

                # æ¸…ç†æ–‡ä»¶èµ„æº
                if os.path.exists(self.socket_path):
                    os.unlink(self.socket_path)
                if os.path.exists(self.history_file):
                    # ä¿ç•™å†å²æ–‡ä»¶ä¾›ä¸‹æ¬¡å¯åŠ¨ä½¿ç”¨
                    pass

                self.codex_active = False
            except:
                pass  # é€€å‡ºæ—¶å¿½ç•¥æ¸…ç†é”™è¯¯
```

#### 4. Claudeä¸»å¯¼çš„æŒä¹…åŒ–å’Œæ¢å¤é€»è¾‘

##### æŒä¹…åŒ–ç­–ç•¥ï¼š
- **Claudeè§¦å‘ä¿å­˜**ï¼šClaudeé€€å‡ºæ—¶é€šçŸ¥Codexä¿å­˜å¯¹è¯å†å²
- **ä¿¡å·å¤„ç†ä¿å­˜**ï¼šCodexæ”¶åˆ°SIGTERMæ—¶è‡ªåŠ¨ä¿å­˜
- **å†…å­˜é™åˆ¶ç®¡ç†**ï¼šè¶…å‡º100è½®å¯¹è¯æ—¶åˆ é™¤æœ€æ—§è®°å½•
- **å®ä¾‹å…³è”å­˜å‚¨**ï¼šå†å²æ–‡ä»¶åŒ…å«instance_idï¼Œç¡®ä¿æ¢å¤æ­£ç¡®æ€§

##### Claudeä¸»å¯¼çš„æ¢å¤é€»è¾‘ï¼š
```python
class ClaudeCodexManager:
    def _restart_codex_process(self):
        """Claudeé‡æ–°æ‹‰èµ·å¼‚å¸¸é€€å‡ºçš„Codexè¿›ç¨‹"""
        print(f"æ­£åœ¨é‡å¯Codexå®ä¾‹ {self.instance_id}...")

        # ä¿å­˜æ—§è¿›ç¨‹çš„çŠ¶æ€ï¼ˆåŒ…æ‹¬å¯¹è¯å†å²å’Œprofileï¼‰
        old_state = {}
        if os.path.exists(self.history_file):
            try:
                with open(self.history_file, 'r') as f:
                    old_data = json.load(f)
                    if old_data.get("instance_id") == self.instance_id:
                        old_state = {
                            "conversation_history": old_data.get("conversation_history", []),
                            "current_profile": old_data.get("current_profile", "default"),
                            "show_reasoning": old_data.get("show_reasoning", False),
                            "output_format": old_data.get("output_format", "final_only")
                        }
                        # æ¢å¤Claudeç«¯çŠ¶æ€
                        self.current_profile = old_state["current_profile"]
                        self.show_reasoning = old_state["show_reasoning"]
                        self.output_format = old_state["output_format"]
            except:
                pass

        # é‡æ–°forkå­è¿›ç¨‹
        self.codex_pid = os.fork()
        if self.codex_pid == 0:  # æ–°å­è¿›ç¨‹
            self._run_codex_child_process()
            os._exit(0)
        else:  # Claudeçˆ¶è¿›ç¨‹
            self._setup_child_monitor()

        # ç­‰å¾…æ–°è¿›ç¨‹å¯åŠ¨å¹¶æ¢å¤çŠ¶æ€
        time.sleep(1)
        self._restore_conversation_state(old_state)

    def _restore_conversation_state(self, state):
        """æ¢å¤å¯¹è¯çŠ¶æ€ï¼ˆå†å²+profileï¼‰"""
        if not state:
            return

        try:
            restore_request = {
                "instance_id": self.instance_id,
                "type": "restore_history",
                "history": state.get("conversation_history", []),
                "profile": state.get("current_profile", "default"),
                "show_reasoning": state.get("show_reasoning", False),
                "output_format": state.get("output_format", "final_only"),
                "timestamp": int(time.time())
            }

            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.send(json.dumps(restore_request).encode())
            response = json.loads(sock.recv(4096).decode())
            sock.close()

            if response.get("status") == "success":
                history_count = len(state.get("conversation_history", []))
                profile = state.get("current_profile", "default")
                reasoning = state.get("show_reasoning", False)
                output_format = state.get("output_format", "final_only")
                print(f"å·²æ¢å¤ {history_count} æ¡å¯¹è¯å†å²ï¼ŒProfile: {profile}, ShowReasoning: {reasoning}, OutputFormat: {output_format}")
            else:
                print("çŠ¶æ€æ¢å¤å¤±è´¥")
        except Exception as e:
            print(f"æ¢å¤çŠ¶æ€æ—¶å‡ºé”™: {e}")

    def get_detailed_status(self):
        """è·å–è¯¦ç»†çŠ¶æ€ä¿¡æ¯"""
        if not self.codex_active:
            return {}

        uptime = int(time.time()) - getattr(self, 'start_time', time.time())
        conversation_count = len(self._load_conversation_count())

        return {
            "instance_id": self.instance_id,
            "current_profile": self.current_profile,
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "conversation_count": conversation_count,
            "uptime": uptime,
            "socket_path": self.socket_path,
            "codex_pid": self.codex_pid
        }

    def get_current_config(self):
        """è·å–å½“å‰é…ç½®"""
        return {
            "profile": self.current_profile,
            "instance_id": self.instance_id,
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "conversation_count": len(self._load_conversation_count())
        }

    def _load_conversation_count(self):
        """åŠ è½½å¯¹è¯è®¡æ•°"""
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    data = json.load(f)
                    return data.get("conversation_history", [])
        except:
            pass
        return []

    def _send_config_command(self, payload):
        """ç»Ÿä¸€å‘é€é…ç½®æŒ‡ä»¤"""
        if not self.codex_active:
            return {"status": "error", "message": "Codexæœªæ¿€æ´»"}

        command = {
            "instance_id": self.instance_id,
            "type": "config",
            "timestamp": int(time.time())
        }
        command.update(payload)

        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.send(json.dumps(command).encode())
            response = json.loads(sock.recv(4096).decode())
            sock.close()
            return response
        except Exception as exc:
            return {"status": "error", "message": str(exc)}

    def set_profile(self, new_profile):
        """åˆ‡æ¢æ¨¡å‹å¼ºåº¦"""
        normalized = new_profile.lower()
        aliases = {"high": "high", "default": "default", "low": "low"}
        if normalized not in aliases:
            return "âŒ æ— æ•ˆå‚æ•°ï¼Œè¯·ä½¿ç”¨: highã€defaultã€low"

        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-start"

        response = self._send_config_command(
            {"action": "set_profile", "profile": aliases[normalized]}
        )
        if response.get("status") == "success":
            self.current_profile = aliases[normalized]
            return f"âœ… Profileå·²æ›´æ–°ä¸º: {self.current_profile}"
        return f"âŒ Profileæ›´æ–°å¤±è´¥: {response.get('message', 'æœªçŸ¥é”™è¯¯')}"

    def update_show_reasoning(self, state_token):
        """æ§åˆ¶æ¨ç†å±•ç¤ºå¼€å…³ï¼ˆon/offï¼‰"""
        if state_token not in ["on", "off"]:
            return "âŒ å‚æ•°é”™è¯¯ï¼Œä½¿ç”¨ on æˆ– off"

        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-start"

        target = state_token == "on"
        response = self._send_config_command(
            {"action": "set_reasoning", "show_reasoning": target}
        )
        if response.get("status") == "success":
            self.show_reasoning = target
            label = "on" if target else "off"
            return f"âœ… Show Reasoning å·²è®¾ç½®ä¸º {label}"
        return f"âŒ è®¾ç½®å¤±è´¥: {response.get('message', 'æœªçŸ¥é”™è¯¯')}"

    def update_output_format(self, state_token):
        """æ§åˆ¶æ˜¯å¦ä»…è¾“å‡ºæœ€ç»ˆç­”æ¡ˆï¼ˆon/offï¼‰"""
        if state_token not in ["on", "off"]:
            return "âŒ å‚æ•°é”™è¯¯ï¼Œä½¿ç”¨ on æˆ– off"

        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-start"

        target = "final_only" if state_token == "on" else "final_with_details"
        response = self._send_config_command(
            {"action": "set_output_format", "output_format": target}
        )
        if response.get("status") == "success":
            self.output_format = target
            return f"âœ… Output Format å·²åˆ‡æ¢ä¸º {target}"
        return f"âŒ è®¾ç½®å¤±è´¥: {response.get('message', 'æœªçŸ¥é”™è¯¯')}"

    def show_config(self):
        """ä»¥æ–‡æœ¬æ ¼å¼å±•ç¤ºå½“å‰é…ç½®"""
        cfg = self.get_current_config()
        reasoning_flag = "on" if cfg["show_reasoning"] else "off"
        output_flag = cfg["output_format"]
        output_desc = "final_only" if output_flag == "final_only" else "final_with_details"
        return (
            "ğŸ“‹ å½“å‰é…ç½®:\n"
            f"â€¢ Profile: {cfg['profile']} ({self._describe_profile(cfg['profile'])})\n"
            f"â€¢ Instance ID: {cfg.get('instance_id') or 'å°šæœªåˆ›å»ºï¼ˆæœåŠ¡æœªæ¿€æ´»ï¼‰'}\n"
            f"â€¢ Show Reasoning: {reasoning_flag}  (on=è¾“å‡ºæ¨ç†æ‘˜è¦ï¼›off=ä»…å†…éƒ¨ä½¿ç”¨)\n"
            f"â€¢ Output Format: {output_desc}  (final_only=åªè¾“å‡ºæœ€ç»ˆç­”æ¡ˆ)\n"
            f"â€¢ å†å²è½®æ¬¡: {cfg['conversation_count']}"
        )

    def show_status(self):
        """ä»¥æ–‡æœ¬æ ¼å¼å±•ç¤ºè¿è¡ŒçŠ¶æ€"""
        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªè¿è¡Œ"

        status = self.get_detailed_status()
        return (
            "âœ… CodexæœåŠ¡è¿è¡Œä¸­:\n"
            f"â€¢ å®ä¾‹ID: {status['instance_id']}\n"
            f"â€¢ å½“å‰Profile: {status['current_profile']}\n"
            f"â€¢ Show Reasoning: {'on' if status['show_reasoning'] else 'off'}\n"
            f"â€¢ Output Format: {status['output_format']}\n"
            f"â€¢ å¯¹è¯è½®æ¬¡: {status['conversation_count']}\n"
            f"â€¢ è¿›ç¨‹PID: {status['codex_pid']}\n"
            f"â€¢ Socket: {status['socket_path']}"
        )

    def _describe_profile(self, profile):
        mapping = {
            "high": "æ·±åº¦åˆ†æ",
            "default": "å¹³è¡¡æ¨¡å¼",
            "low": "ç®€æ´å¿«é€Ÿ"
        }
        return mapping.get(profile, "å¹³è¡¡æ¨¡å¼")
```

##### Codexå­è¿›ç¨‹çš„æŒä¹…åŒ–å¤„ç†ï¼š
```python
class CodexProcess:
    def __init__(self, socket_path, instance_id):
        self.socket_path = socket_path
        self.instance_id = instance_id
        self.conversation_history = []

        # æ³¨å†Œä¿¡å·å¤„ç†å™¨
        signal.signal(signal.SIGTERM, self._graceful_shutdown)

    def _graceful_shutdown(self, signum, frame):
        """Claudeå‘èµ·çš„ä¼˜é›…é€€å‡ºï¼Œä¿å­˜æ•°æ®"""
        self._save_history()
        exit(0)

    def _save_history(self):
        """ä¿å­˜åŒ…å«å®ä¾‹IDå’ŒprofileçŠ¶æ€çš„å¯¹è¯å†å²"""
        history_file = self.socket_path.replace('.sock', '-history.json')
        history_data = {
            "instance_id": self.instance_id,
            "conversation_history": self.conversation_history,
            "current_profile": self.current_profile,  # ä¿å­˜å½“å‰profile
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "saved_at": int(time.time()),
            "version": "1.0"
        }

        with open(history_file, 'w') as f:
            json.dump(history_data, f, indent=2)

        # è®¾ç½®æ–‡ä»¶æƒé™ä¸ºç”¨æˆ·ç§æœ‰
        os.chmod(history_file, 0o600)

    def _load_history_securely(self):
        """å®‰å…¨åŠ è½½å†å²è®°å½•ï¼ŒåŒ…æ‹¬profileçŠ¶æ€"""
        history_file = self.socket_path.replace('.sock', '-history.json')

        if os.path.exists(history_file):
            # éªŒè¯æ–‡ä»¶æƒé™
            file_stat = os.stat(history_file)
            if file_stat.st_uid != os.getuid():
                print("è­¦å‘Šï¼šå†å²æ–‡ä»¶æ‰€æœ‰è€…ä¸æ­£ç¡®ï¼Œè·³è¿‡åŠ è½½")
                return

            if file_stat.st_mode & 0o077 != 0:
                print("è­¦å‘Šï¼šå†å²æ–‡ä»¶æƒé™è¿‡äºå¼€æ”¾ï¼Œè·³è¿‡åŠ è½½")
                return

            try:
                with open(history_file, 'r') as f:
                    data = json.load(f)

                # éªŒè¯æ•°æ®åŒ…å«æ­£ç¡®çš„instance_id
                if data.get("instance_id") == self.instance_id:
                    self.conversation_history = data.get("conversation_history", [])
                    # æ¢å¤profileçŠ¶æ€
                    saved_profile = data.get("current_profile", "default")
                    if saved_profile in ["high", "low", "default"]:
                        self.current_profile = saved_profile
                        print(f"å·²æ¢å¤profile: {saved_profile}")
                    # æ¢å¤æ¨ç†ä¸è¾“å‡ºå¼€å…³
                    self.show_reasoning = bool(data.get("show_reasoning", False))
                    saved_format = data.get("output_format", "final_only")
                    if saved_format in ["final_only", "final_with_details"]:
                        self.output_format = saved_format
                else:
                    print("è­¦å‘Šï¼šå†å²æ–‡ä»¶instance_idä¸åŒ¹é…ï¼Œè·³è¿‡åŠ è½½")

            except Exception as e:
                print(f"è­¦å‘Šï¼šåŠ è½½å†å²æ–‡ä»¶å¤±è´¥: {e}")

    def _handle_restore_history(self, request):
        """å¤„ç†å†å²æ¢å¤è¯·æ±‚"""
        history = request.get("history", [])
        self.conversation_history = history

        requested_profile = request.get("profile")
        if requested_profile in ["high", "low", "default"]:
            self.current_profile = requested_profile
        elif history:
            for entry in reversed(history[-10:]):
                if entry.get("role") == "assistant" and entry.get("profile") in ["high", "low", "default"]:
                    self.current_profile = entry["profile"]
                    break

        self.show_reasoning = bool(request.get("show_reasoning", self.show_reasoning))
        requested_output = request.get("output_format", self.output_format)
        if requested_output in ["final_only", "final_with_details"]:
            self.output_format = requested_output

        return {
            "instance_id": self.instance_id,
            "type": "restore_response",
            "message": f"å·²æ¢å¤ {len(history)} æ¡å†å²ï¼Œå½“å‰profile: {self.current_profile}",
            "status": "success"
        }

    def handle_request(self, request):
        """å¤„ç†è¯·æ±‚ï¼Œæ”¯æŒå†å²æ¢å¤"""
        if request.get("type") == "restore_history":
            # Claudeé‡å¯æ—¶æ¢å¤å¯¹è¯å†å²
            self.conversation_history = request.get("history", [])
            return {
                "instance_id": self.instance_id,
                "type": "restore_response",
                "message": f"å·²æ¢å¤ {len(self.conversation_history)} æ¡å†å²",
                "status": "success"
            }

        elif request.get("type") == "query":
            # æ­£å¸¸å¯¹è¯è¯·æ±‚
            self.conversation_history.append({
                "role": "user",
                "content": request["message"],
                "timestamp": request["timestamp"]
            })

            # å¤„ç†å¹¶è·å¾—å“åº”
            response_text = self._process_query(request["message"])

            self.conversation_history.append({
                "role": "assistant",
                "content": response_text,
                "timestamp": int(time.time())
            })

            # å†…å­˜ç®¡ç†ï¼šä¿æŒæœ€æ–°100è½®å¯¹è¯
            if len(self.conversation_history) > 200:  # 100è½®å¯¹è¯ = 200æ¡æ¶ˆæ¯
                self.conversation_history = self.conversation_history[-200:]

            return {
                "instance_id": self.instance_id,
                "type": "response",
                "message": response_text,
                "status": "success",
                "metadata": {
                    "context_length": len(self.conversation_history)
                }
            }
```

## å®ç°ç»„ä»¶

### 1. Claude Codexç®¡ç†å™¨ (é›†æˆåœ¨Claudeä¸­)
```python
# codex_manager.py (Claudeå†…éƒ¨æ¨¡å—)
import os
import uuid
import signal
import subprocess
import socket
import json

#### 3. Claudeå†…éƒ¨å­è¿›ç¨‹æ¶æ„
- **æ¿€æ´»è§¦å‘**ï¼šClaudeå†…éƒ¨æ£€æµ‹åˆ°é¦–æ¬¡Codexå‘½ä»¤æ—¶è‡ªåŠ¨æ¿€æ´»
- **è¿›ç¨‹ç”Ÿæˆ**ï¼šClaudeä¸»è¿›ç¨‹fork()ç”ŸæˆCodexå­è¿›ç¨‹
- **å®ä¾‹ç»‘å®š**ï¼šç”Ÿæˆå”¯ä¸€instance_idï¼Œç»‘å®šsocketè·¯å¾„å’Œå­è¿›ç¨‹PID
- **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šClaudeå®Œå…¨æ§åˆ¶Codexçš„å¯åŠ¨ã€ç›‘æ§ã€åœæ­¢å’Œæ¸…ç†

##### Claudeä¸»å¯¼çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼š
```python
class ClaudeCodexManager:
    def __init__(self):
        self.instance_id = None
        self.socket_path = None
        self.codex_pid = None
        self.history_file = None
        self.codex_active = False
        self.current_profile = "default"  # æ·»åŠ profileçŠ¶æ€
        self.show_reasoning = False       # æ˜¯å¦åœ¨Claudeä¾§å±•ç¤ºæ¨ç†
        self.output_format = "final_only" # è¾“å‡ºæ¨¡å¼: final_only/final_with_details

    def auto_activate_on_first_use(self):
        """é¦–æ¬¡ä½¿ç”¨æ—¶è‡ªåŠ¨æ¿€æ´»"""
        if not self.codex_active:
            self.instance_id = self._generate_instance_id()
            self.socket_path = f"/tmp/codex-{os.getppid()}-{self.instance_id}.sock"
            self.history_file = self.socket_path.replace('.sock', '-history.json')

            # fork()åˆ›å»ºå­è¿›ç¨‹
            self.codex_pid = os.fork()
            if self.codex_pid == 0:  # å­è¿›ç¨‹
                self._run_codex_child_process()
                os._exit(0)
            else:  # Claudeçˆ¶è¿›ç¨‹
                self.codex_active = True
                self._setup_child_monitor()

    def _run_codex_child_process(self):
        """å­è¿›ç¨‹ä¸­è¿è¡ŒCodexæœåŠ¡"""
        # å¯åŠ¨Codexå®ˆæŠ¤è¿›ç¨‹ï¼Œç›‘å¬ä¸“ç”¨socket
        from codex_process import CodexProcess
        codex = CodexProcess(self.socket_path, self.instance_id)
        codex.run()

    def _setup_child_monitor(self):
        """è®¾ç½®å­è¿›ç¨‹ç›‘æ§"""
        import threading
        import os

        def monitor_child():
            while self.codex_active:
                try:
                    # æ£€æŸ¥å­è¿›ç¨‹çŠ¶æ€
                    os.waitpid(self.codex_pid, os.WNOHANG)
                except OSError:
                    # å­è¿›ç¨‹å¼‚å¸¸é€€å‡ºï¼ŒClaudeé‡æ–°æ‹‰èµ·
                    print("Codexè¿›ç¨‹å¼‚å¸¸é€€å‡ºï¼Œæ­£åœ¨é‡æ–°å¯åŠ¨...")
                    self._restart_codex_process()
                    break
                time.sleep(2)

        monitor_thread = threading.Thread(target=monitor_child, daemon=True)
        monitor_thread.start()

    def claude_cleanup_on_exit(self):
        """Claudeé€€å‡ºæ—¶ç»Ÿä¸€å›æ”¶èµ„æº"""
        if self.codex_active and self.codex_pid:
            try:
                # å‘é€SIGTERMä¿¡å·è®©Codexä¼˜é›…é€€å‡º
                os.kill(self.codex_pid, signal.SIGTERM)
                os.waitpid(self.codex_pid, 0)  # ç­‰å¾…å­è¿›ç¨‹é€€å‡º

                # æ¸…ç†æ–‡ä»¶èµ„æº
                if os.path.exists(self.socket_path):
                    os.unlink(self.socket_path)
                if os.path.exists(self.history_file):
                    # ä¿ç•™å†å²æ–‡ä»¶ä¾›ä¸‹æ¬¡å¯åŠ¨ä½¿ç”¨
                    pass

                self.codex_active = False
            except:
                pass  # é€€å‡ºæ—¶å¿½ç•¥æ¸…ç†é”™è¯¯
```

#### 4. Claudeä¸»å¯¼çš„æŒä¹…åŒ–å’Œæ¢å¤é€»è¾‘

##### æŒä¹…åŒ–ç­–ç•¥ï¼š
- **Claudeè§¦å‘ä¿å­˜**ï¼šClaudeé€€å‡ºæ—¶é€šçŸ¥Codexä¿å­˜å¯¹è¯å†å²
- **ä¿¡å·å¤„ç†ä¿å­˜**ï¼šCodexæ”¶åˆ°SIGTERMæ—¶è‡ªåŠ¨ä¿å­˜
- **å†…å­˜é™åˆ¶ç®¡ç†**ï¼šè¶…å‡º100è½®å¯¹è¯æ—¶åˆ é™¤æœ€æ—§è®°å½•
- **å®ä¾‹å…³è”å­˜å‚¨**ï¼šå†å²æ–‡ä»¶åŒ…å«instance_idï¼Œç¡®ä¿æ¢å¤æ­£ç¡®æ€§

##### Claudeä¸»å¯¼çš„æ¢å¤é€»è¾‘ï¼š
```python
class ClaudeCodexManager:
    def _restart_codex_process(self):
        """Claudeé‡æ–°æ‹‰èµ·å¼‚å¸¸é€€å‡ºçš„Codexè¿›ç¨‹"""
        print(f"æ­£åœ¨é‡å¯Codexå®ä¾‹ {self.instance_id}...")

        # ä¿å­˜æ—§è¿›ç¨‹çš„çŠ¶æ€ï¼ˆåŒ…æ‹¬å¯¹è¯å†å²å’Œprofileï¼‰
        old_state = {}
        if os.path.exists(self.history_file):
            try:
                with open(self.history_file, 'r') as f:
                    old_data = json.load(f)
                    if old_data.get("instance_id") == self.instance_id:
                        old_state = {
                            "conversation_history": old_data.get("conversation_history", []),
                            "current_profile": old_data.get("current_profile", "default"),
                            "show_reasoning": old_data.get("show_reasoning", False),
                            "output_format": old_data.get("output_format", "final_only")
                        }
                        # æ¢å¤Claudeç«¯çŠ¶æ€
                        self.current_profile = old_state["current_profile"]
                        self.show_reasoning = old_state["show_reasoning"]
                        self.output_format = old_state["output_format"]
            except:
                pass

        # é‡æ–°forkå­è¿›ç¨‹
        self.codex_pid = os.fork()
        if self.codex_pid == 0:  # æ–°å­è¿›ç¨‹
            self._run_codex_child_process()
            os._exit(0)
        else:  # Claudeçˆ¶è¿›ç¨‹
            self._setup_child_monitor()

        # ç­‰å¾…æ–°è¿›ç¨‹å¯åŠ¨å¹¶æ¢å¤çŠ¶æ€
        time.sleep(1)
        self._restore_conversation_state(old_state)

    def _restore_conversation_state(self, state):
        """æ¢å¤å¯¹è¯çŠ¶æ€ï¼ˆå†å²+profileï¼‰"""
        if not state:
            return

        try:
            restore_request = {
                "instance_id": self.instance_id,
                "type": "restore_history",
                "history": state.get("conversation_history", []),
                "profile": state.get("current_profile", "default"),
                "timestamp": int(time.time())
            }

            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.send(json.dumps(restore_request).encode())
            response = json.loads(sock.recv(4096).decode())
            sock.close()

            if response.get("status") == "success":
                history_count = len(state.get("conversation_history", []))
                profile = state.get("current_profile", "default")
                print(f"å·²æ¢å¤ {history_count} æ¡å¯¹è¯å†å²ï¼ŒProfile: {profile}")
            else:
                print("çŠ¶æ€æ¢å¤å¤±è´¥")
        except Exception as e:
            print(f"æ¢å¤çŠ¶æ€æ—¶å‡ºé”™: {e}")

    def get_detailed_status(self):
        """è·å–è¯¦ç»†çŠ¶æ€ä¿¡æ¯"""
        if not self.codex_active:
            return {}

        uptime = int(time.time()) - getattr(self, 'start_time', time.time())
        conversation_count = len(self._load_conversation_count())

        return {
            "instance_id": self.instance_id,
            "current_profile": self.current_profile,
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "conversation_count": conversation_count,
            "uptime": uptime,
            "socket_path": self.socket_path,
            "codex_pid": self.codex_pid
        }

    def get_current_config(self):
        """è·å–å½“å‰é…ç½®"""
        return {
            "profile": self.current_profile,
            "instance_id": self.instance_id,
            "show_reasoning": self.show_reasoning,
            "output_format": self.output_format,
            "conversation_count": len(self._load_conversation_count())
        }

    def _load_conversation_count(self):
        """åŠ è½½å¯¹è¯è®¡æ•°"""
        try:
            if os.path.exists(self.history_file):
                with open(self.history_file, 'r') as f:
                    data = json.load(f)
                    return data.get("conversation_history", [])
        except:
            pass
        return []

    def _send_config_command(self, payload):
        """ç»Ÿä¸€å‘é€é…ç½®æŒ‡ä»¤"""
        if not self.codex_active:
            return {"status": "error", "message": "Codexæœªæ¿€æ´»"}

        command = {
            "instance_id": self.instance_id,
            "type": "config",
            "timestamp": int(time.time())
        }
        command.update(payload)

        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(self.socket_path)
            sock.send(json.dumps(command).encode())
            response = json.loads(sock.recv(4096).decode())
            sock.close()
            return response
        except Exception as exc:
            return {"status": "error", "message": str(exc)}

    def set_profile(self, new_profile):
        """åˆ‡æ¢æ¨¡å‹å¼ºåº¦"""
        normalized = new_profile.lower()
        aliases = {"high": "high", "default": "default", "low": "low"}
        if normalized not in aliases:
            return "âŒ æ— æ•ˆå‚æ•°ï¼Œè¯·ä½¿ç”¨: highã€defaultã€low"

        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-start"

        response = self._send_config_command(
            {"action": "set_profile", "profile": aliases[normalized]}
        )
        if response.get("status") == "success":
            self.current_profile = aliases[normalized]
            return f"âœ… Profileå·²æ›´æ–°ä¸º: {self.current_profile}"
        return f"âŒ Profileæ›´æ–°å¤±è´¥: {response.get('message', 'æœªçŸ¥é”™è¯¯')}"

    def update_show_reasoning(self, state_token):
        """æ§åˆ¶æ¨ç†å±•ç¤ºå¼€å…³ï¼ˆon/offï¼‰"""
        if state_token not in ["on", "off"]:
            return "âŒ å‚æ•°é”™è¯¯ï¼Œä½¿ç”¨ on æˆ– off"

        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-start"

        target = state_token == "on"
        response = self._send_config_command(
            {"action": "set_reasoning", "show_reasoning": target}
        )
        if response.get("status") == "success":
            self.show_reasoning = target
            label = "on" if target else "off"
            return f"âœ… Show Reasoning å·²è®¾ç½®ä¸º {label}"
        return f"âŒ è®¾ç½®å¤±è´¥: {response.get('message', 'æœªçŸ¥é”™è¯¯')}"

    def update_output_format(self, state_token):
        """æ§åˆ¶æ˜¯å¦ä»…è¾“å‡ºæœ€ç»ˆç­”æ¡ˆï¼ˆon/offï¼‰"""
        if state_token not in ["on", "off"]:
            return "âŒ å‚æ•°é”™è¯¯ï¼Œä½¿ç”¨ on æˆ– off"

        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-start"

        target = "final_only" if state_token == "on" else "final_with_details"
        response = self._send_config_command(
            {"action": "set_output_format", "output_format": target}
        )
        if response.get("status") == "success":
            self.output_format = target
            return f"âœ… Output Format å·²åˆ‡æ¢ä¸º {target}"
        return f"âŒ è®¾ç½®å¤±è´¥: {response.get('message', 'æœªçŸ¥é”™è¯¯')}"

    def show_config(self):
        """ä»¥æ–‡æœ¬æ ¼å¼å±•ç¤ºå½“å‰é…ç½®"""
        cfg = self.get_current_config()
        reasoning_flag = "on" if cfg["show_reasoning"] else "off"
        output_flag = cfg["output_format"]
        output_desc = "final_only" if output_flag == "final_only" else "final_with_details"
        return (
            "ğŸ“‹ å½“å‰é…ç½®:\n"
            f"â€¢ Profile: {cfg['profile']} ({self._describe_profile(cfg['profile'])})\n"
            f"â€¢ Instance ID: {cfg.get('instance_id') or 'å°šæœªåˆ›å»ºï¼ˆæœåŠ¡æœªæ¿€æ´»ï¼‰'}\n"
            f"â€¢ Show Reasoning: {reasoning_flag}  (on=è¾“å‡ºæ¨ç†æ‘˜è¦ï¼›off=ä»…å†…éƒ¨ä½¿ç”¨)\n"
            f"â€¢ Output Format: {output_desc}  (final_only=åªè¾“å‡ºæœ€ç»ˆç­”æ¡ˆ)\n"
            f"â€¢ å†å²è½®æ¬¡: {cfg['conversation_count']}"
        )

    def show_status(self):
        """ä»¥æ–‡æœ¬æ ¼å¼å±•ç¤ºè¿è¡ŒçŠ¶æ€"""
        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªè¿è¡Œ"

        status = self.get_detailed_status()
        return (
            "âœ… CodexæœåŠ¡è¿è¡Œä¸­:\n"
            f"â€¢ å®ä¾‹ID: {status['instance_id']}\n"
            f"â€¢ å½“å‰Profile: {status['current_profile']}\n"
            f"â€¢ Show Reasoning: {'on' if status['show_reasoning'] else 'off'}\n"
            f"â€¢ Output Format: {status['output_format']}\n"
            f"â€¢ å¯¹è¯è½®æ¬¡: {status['conversation_count']}\n"
            f"â€¢ è¿›ç¨‹PID: {status['codex_pid']}\n"
            f"â€¢ Socket: {status['socket_path']}"
        )

    def _describe_profile(self, profile):
        mapping = {
            "high": "æ·±åº¦åˆ†æ",
            "default": "å¹³è¡¡æ¨¡å¼",
            "low": "ç®€æ´å¿«é€Ÿ"
        }
        return mapping.get(profile, "å¹³è¡¡æ¨¡å¼")

    def _restore_conversation_history(self, history):
        """æ¢å¤å¯¹è¯å†å²åˆ°æ–°è¿›ç¨‹"""
        if history:
            restore_request = {
                "instance_id": self.instance_id,
                "type": "restore_history",
                "history": history,
                "timestamp": int(time.time())
            }

            try:
                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                sock.connect(self.socket_path)
                sock.send(json.dumps(restore_request).encode())
                sock.close()
                print(f"å·²æ¢å¤ {len(history)} æ¡å¯¹è¯å†å²")
            except:
                print("æ¢å¤å¯¹è¯å†å²å¤±è´¥")
```

##### Codexå­è¿›ç¨‹çš„æŒä¹…åŒ–å¤„ç†ï¼š
```python
class CodexProcess:
    def __init__(self, socket_path, instance_id):
        self.socket_path = socket_path
        self.instance_id = instance_id
        self.conversation_history = []

        # æ³¨å†Œä¿¡å·å¤„ç†å™¨
        signal.signal(signal.SIGTERM, self._graceful_shutdown)

    def _graceful_shutdown(self, signum, frame):
        """Claudeå‘èµ·çš„ä¼˜é›…é€€å‡ºï¼Œä¿å­˜æ•°æ®"""
        self._save_history()
        exit(0)

    def _save_history(self):
        """ä¿å­˜åŒ…å«å®ä¾‹IDå’ŒprofileçŠ¶æ€çš„å¯¹è¯å†å²"""
        history_file = self.socket_path.replace('.sock', '-history.json')
        history_data = {
            "instance_id": self.instance_id,
            "conversation_history": self.conversation_history,
            "current_profile": self.current_profile,  # ä¿å­˜å½“å‰profile
            "saved_at": int(time.time()),
            "version": "1.0"
        }

        with open(history_file, 'w') as f:
            json.dump(history_data, f, indent=2)

        # è®¾ç½®æ–‡ä»¶æƒé™ä¸ºç”¨æˆ·ç§æœ‰
        os.chmod(history_file, 0o600)

    def _load_history_securely(self):
        """å®‰å…¨åŠ è½½å†å²è®°å½•ï¼ŒåŒ…æ‹¬profileçŠ¶æ€"""
        history_file = self.socket_path.replace('.sock', '-history.json')

        if os.path.exists(history_file):
            # éªŒè¯æ–‡ä»¶æƒé™
            file_stat = os.stat(history_file)
            if file_stat.st_uid != os.getuid():
                print("è­¦å‘Šï¼šå†å²æ–‡ä»¶æ‰€æœ‰è€…ä¸æ­£ç¡®ï¼Œè·³è¿‡åŠ è½½")
                return

            if file_stat.st_mode & 0o077 != 0:
                print("è­¦å‘Šï¼šå†å²æ–‡ä»¶æƒé™è¿‡äºå¼€æ”¾ï¼Œè·³è¿‡åŠ è½½")
                return

            try:
                with open(history_file, 'r') as f:
                    data = json.load(f)

                # éªŒè¯æ•°æ®åŒ…å«æ­£ç¡®çš„instance_id
                if data.get("instance_id") == self.instance_id:
                    self.conversation_history = data.get("conversation_history", [])
                    # æ¢å¤profileçŠ¶æ€
                    saved_profile = data.get("current_profile", "default")
                    if saved_profile in ["high", "low", "default"]:
                        self.current_profile = saved_profile
                        print(f"å·²æ¢å¤profile: {saved_profile}")
                else:
                    print("è­¦å‘Šï¼šå†å²æ–‡ä»¶instance_idä¸åŒ¹é…ï¼Œè·³è¿‡åŠ è½½")

            except Exception as e:
                print(f"è­¦å‘Šï¼šåŠ è½½å†å²æ–‡ä»¶å¤±è´¥: {e}")

    def _handle_restore_history(self, request):
        """å¤„ç†å†å²æ¢å¤è¯·æ±‚"""
        # Claudeé‡å¯æ—¶æ¢å¤å¯¹è¯å†å²å’Œprofile
        history = request.get("history", [])
        self.conversation_history = history

        # å°è¯•ä»å†å²ä¸­æ¢å¤æœ€åçš„profileçŠ¶æ€
        if history:
            # ä»æœ€åå‡ æ¡å¯¹è¯ä¸­æ¢å¤profile
            for entry in reversed(history[-10:]):  # æŸ¥çœ‹æœ€å10æ¡è®°å½•
                if entry.get("role") == "assistant" and "profile" in entry:
                    self.current_profile = entry["profile"]
                    break

        return {
            "instance_id": self.instance_id,
            "type": "restore_response",
            "message": f"å·²æ¢å¤ {len(history)} æ¡å†å²ï¼Œå½“å‰profile: {self.current_profile}",
            "status": "success"
        }

    def handle_request(self, request):
        """å¤„ç†è¯·æ±‚ï¼Œæ”¯æŒå†å²æ¢å¤"""
        if request.get("type") == "restore_history":
            # Claudeé‡å¯æ—¶æ¢å¤å¯¹è¯å†å²
            self.conversation_history = request.get("history", [])
            return {
                "instance_id": self.instance_id,
                "type": "restore_response",
                "message": f"å·²æ¢å¤ {len(self.conversation_history)} æ¡å†å²",
                "status": "success"
            }

        elif request.get("type") == "query":
            # æ­£å¸¸å¯¹è¯è¯·æ±‚
            self.conversation_history.append({
                "role": "user",
                "content": request["message"],
                "timestamp": request["timestamp"]
            })

            # å¤„ç†å¹¶è·å¾—å“åº”
            response_text = self._process_query(request["message"])

            self.conversation_history.append({
                "role": "assistant",
                "content": response_text,
                "timestamp": int(time.time())
            })

            # å†…å­˜ç®¡ç†ï¼šä¿æŒæœ€æ–°100è½®å¯¹è¯
            if len(self.conversation_history) > 200:  # 100è½®å¯¹è¯ = 200æ¡æ¶ˆæ¯
                self.conversation_history = self.conversation_history[-200:]

            return {
                "instance_id": self.instance_id,
                "type": "response",
                "message": response_text,
                "status": "success",
                "metadata": {
                    "context_length": len(self.conversation_history)
                }
            }
```

## å®ç°ç»„ä»¶

### 1. Claude Codexç®¡ç†å™¨ (é›†æˆåœ¨Claudeä¸­)
```python
# codex_manager.py (Claudeå†…éƒ¨æ¨¡å—)
import os
import uuid
import signal
import subprocess
import socket
import json

### 2. Codexå­è¿›ç¨‹ (codex_process.py)
```python
#!/usr/bin/env python3
import socket
import json
import os
import signal
import sys

class CodexProcess:
    def __init__(self, socket_path, instance_id):
        self.socket_path = socket_path
        self.instance_id = instance_id
        self.conversation_history = []
        self.current_profile = "default"  # Codexç»´æŠ¤å½“å‰profileçŠ¶æ€
        self.running = True

        # æ³¨å†Œä¿¡å·å¤„ç†å™¨
        signal.signal(signal.SIGTERM, self.signal_handler)

    def signal_handler(self, signum, frame):
        """ä¼˜é›…é€€å‡º"""
        self.save_history()
        exit(0)

    def run(self):
        """ä¸»å¾ªç¯"""
        # åŠ è½½å†å²è®°å½•
        self.load_history()

        # åˆ›å»ºSocket
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.bind(self.socket_path)
        sock.listen(1)
        os.chmod(self.socket_path, 0o600)  # ç”¨æˆ·ç§æœ‰æƒé™

        # å¤„ç†è¯·æ±‚
        while self.running:
            try:
                conn, addr = sock.accept()
                data = conn.recv(4096).decode()
                if data:
                    response = self.handle_request(json.loads(data))
                    conn.send(json.dumps(response).encode())
                conn.close()
            except:
                break

        sock.close()

    def handle_request(self, request):
        """å¤„ç†è¯·æ±‚ï¼Œæ”¯æŒé…ç½®ç®¡ç†å’Œprofile"""
        try:
            # Schemaæ ¡éªŒå’Œé»˜è®¤å€¼è®¾ç½®
            validated_request = self._validate_schema(request)
        except ValueError as e:
            return {
                "instance_id": self.instance_id,
                "type": "error",
                "message": str(e),
                "status": "error",
                "error_code": "VALIDATION_ERROR"
            }

        # å¤„ç†ä¸åŒç±»å‹çš„è¯·æ±‚
        if validated_request["type"] == "config":
            return self._handle_config_request(validated_request)
        elif validated_request["type"] == "query":
            return self._process_query(validated_request)
        elif validated_request["type"] == "restore_history":
            return self._handle_restore_history(validated_request)
        else:
            return {
                "instance_id": self.instance_id,
                "type": "error",
                "message": f"æœªçŸ¥è¯·æ±‚ç±»å‹: {validated_request['type']}",
                "status": "error",
                "error_code": "UNKNOWN_REQUEST_TYPE"
            }

    def _validate_schema(self, request):
        """Schemaæ ¡éªŒä¸é»˜è®¤å€¼è®¾ç½®"""
        required_fields = ["instance_id", "type", "timestamp"]
        for field in required_fields:
            if field not in request:
                raise ValueError(f"ç¼ºå°‘å¿…éœ€å­—æ®µ: {field}")

        # éªŒè¯instance_id
        if request["instance_id"] != self.instance_id:
            raise ValueError("å®ä¾‹IDä¸åŒ¹é…")

        # è®¾ç½®configé»˜è®¤å€¼
        if "config" not in request:
            request["config"] = {}

        config_defaults = {
            "show_reasoning": False,
            "output_format": "final_only",
            "profile": "default"
        }

        for key, default_value in config_defaults.items():
            if key not in request["config"]:
                request["config"][key] = default_value

        # éªŒè¯profileå€¼
        valid_profiles = ["high", "low", "default"]
        if request["config"]["profile"] not in valid_profiles:
            request["config"]["profile"] = "default"

        return request

    def _handle_config_request(self, request):
        """å¤„ç†é…ç½®å˜æ›´è¯·æ±‚"""
        action = request.get("action")

        if action == "set_profile":
            new_profile = request.get("profile", "default")
            if new_profile in ["high", "low", "default"]:
                old_profile = self.current_profile
                self.current_profile = new_profile

                # è®°å½•é…ç½®å˜æ›´æ—¥å¿—
                self._log_config_change("profile", old_profile, new_profile)

                return {
                    "instance_id": self.instance_id,
                    "type": "config_response",
                    "action": "set_profile",
                    "profile": new_profile,
                    "status": "success",
                    "message": f"Profileå·²æ›´æ–°ä¸º{new_profile}"
                }
            else:
                return {
                    "instance_id": self.instance_id,
                    "type": "error",
                    "message": f"æ— æ•ˆçš„profile: {new_profile}",
                    "status": "error",
                    "error_code": "INVALID_PROFILE"
                }
        else:
            return {
                "instance_id": self.instance_id,
                "type": "error",
                "message": f"æœªçŸ¥é…ç½®æ“ä½œ: {action}",
                "status": "error",
                "error_code": "UNKNOWN_CONFIG_ACTION"
            }

    def _log_config_change(self, config_type, old_value, new_value):
        """è®°å½•é…ç½®å˜æ›´æ—¥å¿—"""
        print(f"[Codex Config] {config_type}: {old_value} -> {new_value}")

    def _process_query(self, request):
        """å¤„ç†æŸ¥è¯¢è¯·æ±‚ï¼Œè€ƒè™‘å½“å‰profile"""
        config = request["config"]
        profile = config.get("profile", self.current_profile)

        # æ ¹æ®profileè°ƒæ•´æ¨¡å‹å‚æ•°
        model_params = self._get_model_params_for_profile(profile)

        # æ·»åŠ åˆ°å¯¹è¯å†å²
        self.conversation_history.append({
            "role": "user",
            "content": request["message"],
            "timestamp": request["timestamp"],
            "profile": profile
        })

        # å¤„ç†å¹¶è·å¾—å“åº”ï¼ˆä½¿ç”¨profileå¯¹åº”çš„å‚æ•°ï¼‰
        response_text = self._call_codex_with_params(request["message"], model_params)

        self.conversation_history.append({
            "role": "assistant",
            "content": response_text,
            "timestamp": int(time.time()),
            "profile": profile
        })

        # å†…å­˜ç®¡ç†ï¼šä¿æŒæœ€æ–°100è½®å¯¹è¯
        if len(self.conversation_history) > 200:
            self.conversation_history = self.conversation_history[-200:]

        return {
            "instance_id": self.instance_id,
            "type": "response",
            "message": response_text,
            "status": "success",
            "metadata": {
                "context_length": len(self.conversation_history),
                "active_profile": profile
            }
        }

    def _get_model_params_for_profile(self, profile):
        """æ ¹æ®profileè·å–æ¨¡å‹å‚æ•°"""
        profile_params = {
            "high": {
                "temperature": 0.1,
                "max_tokens": 4000,
                "top_p": 0.95,
                "reasoning_depth": "deep"
            },
            "low": {
                "temperature": 0.3,
                "max_tokens": 1000,
                "top_p": 0.9,
                "reasoning_depth": "shallow"
            },
            "default": {
                "temperature": 0.2,
                "max_tokens": 2000,
                "top_p": 0.92,
                "reasoning_depth": "medium"
            }
        }

        return profile_params.get(profile, profile_params["default"])

    def _call_codex_with_params(self, message, params):
        """ä½¿ç”¨æŒ‡å®šå‚æ•°è°ƒç”¨Codex"""
        # è¿™é‡Œè°ƒç”¨çœŸæ­£çš„Codex APIï¼Œä½¿ç”¨paramsä¸­çš„å‚æ•°
        # response = call_codex_api(message, **params)

        # æ¨¡æ‹Ÿå“åº”ï¼Œæ ¹æ®profileè°ƒæ•´å›ç­”é•¿åº¦å’Œè¯¦ç»†ç¨‹åº¦
        profile = params.get("reasoning_depth", "medium")
        if profile == "deep":
            return f"è¯¦ç»†çš„æ·±åº¦å›ç­”: {message} (ä½¿ç”¨high profileå‚æ•°)"
        elif profile == "shallow":
            return f"ç®€æ´å›ç­”: {message} (ä½¿ç”¨low profileå‚æ•°)"
        else:
            return f"å¹³è¡¡å›ç­”: {message} (ä½¿ç”¨default profileå‚æ•°)"

    def _handle_restore_history(self, request):
        """å¤„ç†å†å²æ¢å¤è¯·æ±‚"""
        # Claudeé‡å¯æ—¶æ¢å¤å¯¹è¯å†å²å’Œprofile
        history = request.get("history", [])
        profile = request.get("profile", "default")
        self.conversation_history = history
        self.current_profile = profile

        return {
            "instance_id": self.instance_id,
            "type": "restore_response",
            "message": f"å·²æ¢å¤ {len(history)} æ¡å†å²ï¼Œå½“å‰profile: {self.current_profile}",
            "status": "success"
        }

    def load_history(self):
        """åŠ è½½å†å²"""
        history_file = self.socket_path.replace('.sock', '-history.json')
        if os.path.exists(history_file):
            try:
                with open(history_file, 'r') as f:
                    self.conversation_history = json.load(f)
            except:
                pass

    def save_history(self):
        """ä¿å­˜å†å²"""
        history_file = self.socket_path.replace('.sock', '-history.json')
        with open(history_file, 'w') as f:
            json.dump(self.conversation_history, f)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        sys.exit(1)

    # å‚æ•°: socket_path
    socket_path = sys.argv[1]
    # ä»socket_pathä¸­æå–instance_id
    instance_id = socket_path.split('/')[-1].replace('.sock', '').split('-')[-1]

    codex = CodexProcess(socket_path, instance_id)
    codex.run()
```

### 3. ç®€åŒ–è¯Šæ–­å·¥å…·ï¼ˆä»…ç”¨äºé—®é¢˜æ’æŸ¥ï¼‰
```bash
#!/bin/bash
# codex-status - ç³»ç»Ÿçº§è¯Šæ–­å·¥å…·

show_codex_status() {
    echo "=== CodexæœåŠ¡çŠ¶æ€ ==="

    # æŸ¥æ‰¾æ‰€æœ‰Codexç›¸å…³è¿›ç¨‹
    codex_processes=$(ps aux | grep codex_process | grep -v grep)
    if [ -n "$codex_processes" ]; then
        echo "è¿è¡Œä¸­çš„Codexè¿›ç¨‹ï¼š"
        echo "$codex_processes"
    else
        echo "æ— è¿è¡Œä¸­çš„Codexè¿›ç¨‹"
    fi

    # æŸ¥æ‰¾Socketæ–‡ä»¶
    echo -e "\n=== Socketæ–‡ä»¶ ==="
    socket_files=$(ls -la /tmp/codex-*.sock 2>/dev/null)
    if [ -n "$socket_files" ]; then
        echo "$socket_files"
    else
        echo "æ— Socketæ–‡ä»¶"
    fi

    # æŸ¥æ‰¾å†å²æ–‡ä»¶
    echo -e "\n=== å†å²æ–‡ä»¶ ==="
    history_files=$(ls -la /tmp/codex-*-history.json 2>/dev/null)
    if [ -n "$history_files" ]; then
        echo "$history_files"
    else
        echo "æ— å†å²æ–‡ä»¶"
    fi

    # æ˜¾ç¤ºå½“å‰Claudeè¿›ç¨‹ä¿¡æ¯
    echo -e "\n=== å½“å‰è¿›ç¨‹ä¿¡æ¯ ==="
    echo "Claude PID: $$"
    echo "çˆ¶è¿›ç¨‹ PID: $(ps -o ppid= -p $$)"
}

show_codex_status
```

## Claudeå†…éƒ¨é›†æˆæ–¹æ¡ˆ

### å®Œæ•´çš„Claudeå†…éƒ¨é›†æˆ
```python
# claude_codex_integration.py
import os
import atexit
import signal

class ClaudeCodexIntegration:
    def __init__(self):
        self.codex_manager = None
        self.codex_active = False

        # æ³¨å†Œé€€å‡ºæ¸…ç†å‡½æ•°
        atexit.register(self._cleanup_on_exit)
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)

    def _signal_handler(self, signum, frame):
        """å¤„ç†é€€å‡ºä¿¡å·"""
        self._cleanup_on_exit()
        exit(0)

    def _cleanup_on_exit(self):
        """Claudeé€€å‡ºæ—¶è‡ªåŠ¨æ¸…ç†"""
        if self.codex_active:
            self.codex_manager.cleanup()
            self.codex_active = False

    def handle_command(self, command):
        """ç»Ÿä¸€å‘½ä»¤å¤„ç†å…¥å£ï¼Œæ”¯æŒé…ç½®ç®¡ç†"""
        # è‡ªåŠ¨æ¿€æ´»é€»è¾‘
        keyword = command.strip().split()[0] if command.strip() else command
        if keyword.startswith("/codex-") and not self.codex_active:
            allowed_when_inactive = {"/codex-start", "/codex-help", "/codex-config"}
            if keyword not in allowed_when_inactive:
                return "âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-start æˆ–è¾“å…¥ /codex-help æŸ¥çœ‹æŒ‡å¼•"

        # å‘½ä»¤è·¯ç”±
        if command == "/codex-start":
            return self._start_codex()
        elif command.startswith("/codex-ask"):
            return self._ask_codex(command)
        elif command == "/codex-stop":
            return self._stop_codex()
        elif command == "/codex-status":
            return self._get_status()
        elif command.startswith("/codex-config"):
            return self._handle_config_command(command)
        elif command.startswith("/codex-reasoning"):
            return self._toggle_reasoning(command)
        elif command.startswith("/codex-final_only"):
            return self._toggle_final_only(command)
        elif command == "/codex-help":
            return self._show_help()
        else:
            return f"âŒ æœªçŸ¥å‘½ä»¤: {command}"

    def _start_codex(self):
        """å¯åŠ¨CodexæœåŠ¡"""
        if not self.codex_active:
            try:
                self.codex_manager = ClaudeCodexManager()
                self.codex_manager.start_codex_process()
                self.codex_active = True
                return f"âœ… CodexæœåŠ¡å·²å¯åŠ¨ (å®ä¾‹ID: {self.codex_manager.instance_id}, é»˜è®¤Profile: default)"
            except Exception as e:
                return f"âŒ å¯åŠ¨å¤±è´¥: {str(e)}"
        else:
            return f"â„¹ï¸ CodexæœåŠ¡å·²åœ¨è¿è¡Œ (Profile: {self.codex_manager.current_profile})"

    def _ask_codex(self, command):
        """å‘Codexæé—®"""
        if not self.codex_active:
            return "âŒ è¯·å…ˆè¿è¡Œ /codex-start å¯åŠ¨æœåŠ¡ï¼Œæˆ–è¾“å…¥ /codex-help æŸ¥çœ‹æŒ‡å¼•"

        if command == "/codex-ask":
            return "âŒ è¯·æä¾›è¦è¯¢é—®çš„é—®é¢˜ï¼Œç”¨æ³•: /codex-ask <ä½ çš„é—®é¢˜>"

        question = command.replace("/codex-ask ", "").strip()
        if not question:
            return "âŒ é—®é¢˜å†…å®¹ä¸èƒ½ä¸ºç©º"

        try:
            response = self.codex_manager.send_to_codex(question)
            profile = response.get("metadata", {}).get("active_profile", "default")
            return f"ğŸ¤– [Profile: {profile}]\n{response['message']}"
        except Exception as e:
            return f"âŒ è¯·æ±‚å¤±è´¥: {str(e)}"

    def _stop_codex(self):
        """åœæ­¢CodexæœåŠ¡"""
        if self.codex_active:
            instance_id = self.codex_manager.instance_id
            self.codex_manager.cleanup()
            self.codex_active = False
            return f"âœ… CodexæœåŠ¡å·²åœæ­¢ (å®ä¾‹ID: {instance_id})"
        else:
            return "â„¹ï¸ CodexæœåŠ¡æœªè¿è¡Œ"

    def _get_status(self):
        """è·å–æœåŠ¡çŠ¶æ€"""
        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªè¿è¡Œ"

        return f"""âœ… CodexæœåŠ¡è¿è¡Œä¸­:
â€¢ å®ä¾‹ID: {self.codex_manager.instance_id}
â€¢ å½“å‰Profile: {self.codex_manager.current_profile}
â€¢ è¿›ç¨‹PID: {self.codex_manager.codex_pid}
â€¢ Socket: {self.codex_manager.socket_path}"""

    def _handle_config_command(self, command):
        """å±•ç¤ºæˆ–æ›´æ–°æ ¸å¿ƒé…ç½®ï¼ˆæ¨¡å‹å¼ºåº¦ + è¾“å‡ºæ ¼å¼ï¼‰"""
        parts = command.strip().split()
        if len(parts) == 1:
            return self._show_config()

        if len(parts) != 2:
            return """âŒ å‚æ•°é”™è¯¯
ç”¨æ³•:
â€¢ /codex-config            # æŸ¥çœ‹å½“å‰é…ç½®
â€¢ /codex-config <high|default|low>  # åˆ‡æ¢æ¨¡å‹å¼ºåº¦"""

        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-startï¼Œæˆ–è¾“å…¥ /codex-help æŸ¥çœ‹æŒ‡å¼•"

        target = parts[1].lower()
        aliases = {
            "high": "high",
            "low": "low",
            "default": "default",
            "medium": "default",
            "mid": "default",
            "normal": "default",
            "balanced": "default",
        }

        if target not in aliases:
            return "âŒ æ— æ•ˆå‚æ•°ï¼Œè¯·ä½¿ç”¨: highã€defaultã€low"

        resolved = aliases[target]

        try:
            result = self.codex_manager.set_profile(resolved)
            return f"""{result}

ğŸ“‹ æ¨¡å‹å¼ºåº¦è¯´æ˜:
â€¢ high: {self._get_profile_desc('high')} (æ¸©åº¦ {self._get_profile_temp('high')} / æœ€å¤§é•¿åº¦ {self._get_profile_tokens('high')})
â€¢ default: {self._get_profile_desc('default')} (æ¸©åº¦ {self._get_profile_temp('default')} / æœ€å¤§é•¿åº¦ {self._get_profile_tokens('default')})
â€¢ low: {self._get_profile_desc('low')} (æ¸©åº¦ {self._get_profile_temp('low')} / æœ€å¤§é•¿åº¦ {self._get_profile_tokens('low')})"""
        except Exception as e:
            return f"âŒ æ¨¡å‹å¼ºåº¦åˆ‡æ¢å¤±è´¥: {str(e)}"

    def _show_config(self):
        """æ˜¾ç¤ºå½“å‰é…ç½®"""
        manager = self.codex_manager
        profile = manager.current_profile if (manager and self.codex_active) else "default"
        reasoning = "on" if (manager and manager.show_reasoning) else "off"
        final_flag = manager.output_format if manager else "final_only"

        lines = [
            "ğŸ“‹ å½“å‰é…ç½®:",
            f"â€¢ Profile: {profile} ({self._get_profile_desc(profile)})",
        ]

        if manager and self.codex_active:
            lines.extend(
                [
                    f"â€¢ Instance ID: {manager.instance_id}",
                    f"â€¢ Socket: {manager.socket_path}",
                ]
            )
        else:
            lines.append("â€¢ Instance ID: å°šæœªåˆ›å»ºï¼ˆæœåŠ¡æœªæ¿€æ´»ï¼‰")

        lines.extend(
            [
                f"â€¢ Show Reasoning: {reasoning}  (on=è¾“å‡ºæ¨ç†æ‘˜è¦ï¼›off=ä»…å†…éƒ¨ä½¿ç”¨)",
                f"â€¢ Output Format: {final_flag}  (final_only=åªè¾“å‡ºæœ€ç»ˆç­”æ¡ˆ)",
            ]
        )

        return "\n".join(lines)

    def _toggle_reasoning(self, command):
        """å¼€å…³æ¨ç†å¯è§æ€§ï¼ˆä¸å½±å“å†…éƒ¨æ¨ç†æµç¨‹ï¼‰"""
        parts = command.strip().split()
        if len(parts) != 2 or parts[1] not in ["on", "off"]:
            return """âŒ å‚æ•°é”™è¯¯
ç”¨æ³•: /codex-reasoning <on|off>
â€¢ on: åœ¨Claudeä¸­å±•ç¤ºæ¨ç†æ‘˜è¦ï¼ˆå¯èƒ½æš´éœ²ç»†èŠ‚ï¼‰
â€¢ off: ä»…å±•ç¤ºæœ€ç»ˆç­”æ¡ˆï¼ˆæ¨èï¼‰"""

        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-startï¼Œæˆ–è¾“å…¥ /codex-help æŸ¥çœ‹æŒ‡å¼•"

        state_token = parts[1]
        self.codex_manager.update_show_reasoning(state_token)
        state = state_token == "on"
        label = state_token
        advice = "ï¼ˆå»ºè®®å…³é—­ä»¥ä¿æŒè¾“å‡ºçº¯å‡€ï¼‰" if state else "ï¼ˆå·²å…³é—­æ¨ç†å±•ç¤ºï¼‰"
        return f"âœ… Show Reasoning å·²è®¾ç½®ä¸º {label} {advice}"

    def _toggle_final_only(self, command):
        """æ§åˆ¶æ˜¯å¦ä»…è¾“å‡ºæœ€ç»ˆç­”æ¡ˆ"""
        parts = command.strip().split()
        if len(parts) != 2 or parts[1] not in ["on", "off"]:
            return """âŒ å‚æ•°é”™è¯¯
ç”¨æ³•: /codex-final_only <on|off>
â€¢ on: ä»…è¿”å›æœ€ç»ˆç­”æ¡ˆï¼ˆæ¨èï¼‰
â€¢ off: è¿”å›æœ€ç»ˆç­”æ¡ˆåŠé¢å¤–ç»†èŠ‚ï¼ˆç”¨äºè°ƒè¯•ï¼‰"""

        if not self.codex_active:
            return "âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-startï¼Œæˆ–è¾“å…¥ /codex-help æŸ¥çœ‹æŒ‡å¼•"

        state_token = parts[1]
        self.codex_manager.update_output_format(state_token)
        state = state_token == "on"
        label = "final_only" if state else "final_with_details"
        advice = "ï¼ˆæ¨èå¼€å¯ä»¥é¿å…é¢å¤–å™ªéŸ³ï¼‰" if state else "ï¼ˆå°†è¿”å›é¢å¤–ç»†èŠ‚ä¿¡æ¯ï¼‰"
        return f"âœ… Output Format å·²åˆ‡æ¢ä¸º {label} {advice}"

    def _show_help(self):
        """æ˜¾ç¤ºå‘½ä»¤å¸®åŠ©"""
        return (
            "ğŸ“– Codexå‘½ä»¤å¸®åŠ©ï¼ˆClaudeå†…ç½®ï¼‰\n"
            "â€¢ /codex-start\n"
            "  - è¯´æ˜: å¯åŠ¨æˆ–é‡æ–°è¿æ¥Codexè¿›ç¨‹ï¼Œè‡ªåŠ¨ç”Ÿæˆä¸“å±socketå’Œå®ä¾‹ID\n"
            "  - ä½¿ç”¨: é¦–æ¬¡å¯¹è¯å‰æ‰§è¡Œä¸€æ¬¡å³å¯ï¼Œå¦‚å·²è¿è¡Œä¼šè¿”å›å½“å‰æ¡£ä½\n"
            "â€¢ /codex-ask <é—®é¢˜>\n"
            "  - è¯´æ˜: å‘å½“å‰Codexå®ä¾‹å‘èµ·æé—®ï¼Œè‡ªåŠ¨æºå¸¦å½“å‰æ¨¡å‹å¼ºåº¦/è¾“å‡ºé…ç½®\n"
            "  - ä½¿ç”¨: `/codex-ask è§£é‡Šä¸€ä¸‹æ•°æ®åº“åˆ†ç‰‡`\n"
            "â€¢ /codex-config [high|default|low]\n"
            "  - è¯´æ˜: ä¸å¸¦å‚æ•°æŸ¥çœ‹æ¡£ä½å’Œå¼€å…³ï¼›é™„å¸¦å‚æ•°å¯åˆ‡æ¢æ¨¡å‹å¼ºåº¦\n"
            "  - å»ºè®®: è¯¦ç»†æ¨¡å¼ç”¨ highï¼Œå¿«é€Ÿé—®ç­”ç”¨ lowï¼Œdefault ä¿æŒå¹³è¡¡\n"
            "â€¢ /codex-reasoning <on|off>\n"
            "  - è¯´æ˜: æ§åˆ¶æ˜¯å¦åœ¨Claudeä¾§å±•ç¤ºæ¨ç†æ‘˜è¦ï¼Œon ä»…å½±å“å±•ç¤ºä¸å½±å“çœŸå®æ¨ç†\n"
            "  - å»ºè®®: é»˜è®¤ä¸º off ä»¥ä¿æŒå›ç­”çº¯å‡€ï¼Œé™¤éè°ƒè¯•éœ€è¦\n"
            "â€¢ /codex-final_only <on|off>\n"
            "  - è¯´æ˜: on æ—¶ä»…è¿”å›æœ€ç»ˆç­”æ¡ˆï¼›off æ—¶é™„å¸¦é¢å¤–ç»†èŠ‚æˆ–ä¸­é—´è¯´æ˜\n"
            "  - å»ºè®®: ç”Ÿäº§ä½¿ç”¨ä¿æŒ onï¼Œè°ƒè¯•åœºæ™¯å¯ä¸´æ—¶å…³é—­\n"
            "â€¢ /codex-status\n"
            "  - è¯´æ˜: æŸ¥çœ‹å®ä¾‹IDã€å½“å‰profileã€æ¨ç†/è¾“å‡ºå¼€å…³ã€è¿›ç¨‹PIDç­‰è¿è¡Œä¿¡æ¯\n"
            "â€¢ /codex-stop\n"
            "  - è¯´æ˜: æ‰‹åŠ¨åœæ­¢å½“å‰Codexå­è¿›ç¨‹å¹¶æ¸…ç†socketï¼ŒClaudeé€€å‡ºæ—¶ä¼šè‡ªåŠ¨è°ƒç”¨\n"
            "â€¢ /codex-help\n"
            "  - è¯´æ˜: æ˜¾ç¤ºæœ¬å¸®åŠ©ä¿¡æ¯\n"
            "\n"
            "âš™ï¸ ç»´æŠ¤å»ºè®®:\n"
            "1. éœ€è¦æ’¤å›æœ€è¿‘ä¸€è½®æˆ–æ¸…ç†ä¸Šä¸‹æ–‡æ—¶ï¼Œå¯ç»“åˆ /codex-rewind æˆ– /codex-clearï¼ˆè‹¥å·²å®ç°ï¼‰ã€‚\n"
            "2. åˆ‡æ¢æ¡£ä½åå¦‚é‡å›ç­”å¼‚å¸¸ï¼Œä¼˜å…ˆæ‰§è¡Œ `/codex-config` æŸ¥çœ‹å½“å‰çŠ¶æ€ã€‚\n"
            "3. è‹¥é•¿æ—¶é—´æœªç”¨ï¼Œå»ºè®® `/codex-stop` åå† `/codex-start` ä»¥é‡Šæ”¾èµ„æºã€‚"
        )

    def _get_profile_desc(self, profile):
        descs = {"high": "æ·±åº¦åˆ†æ", "low": "ç®€æ´å¿«é€Ÿ", "default": "å¹³è¡¡æ¨¡å¼"}
        return descs.get(profile, "æ ‡å‡†")

    def _get_profile_temp(self, profile):
        temps = {"high": "0.1", "low": "0.3", "default": "0.2"}
        return temps.get(profile, "0.2")

    def _get_profile_tokens(self, profile):
        tokens = {"high": "4000", "low": "1000", "default": "2000"}
        return tokens.get(profile, "2000")
```

## æ–¹æ¡ˆè¯„ä¼°

### âœ… Claudeå†…éƒ¨è§¦å‘ä¼˜åŠ¿
1. **ä¸€æ¬¡æ€§æ¿€æ´»**ï¼šç”¨æˆ·åªéœ€è¿è¡Œä¸€æ¬¡ /codex-start
2. **è‡ªåŠ¨åŒ–é…ç½®**ï¼šè·¯å¾„ã€PIDç­‰å…¨éƒ¨è‡ªåŠ¨ç”Ÿæˆ
3. **ç”Ÿå‘½å‘¨æœŸç»‘å®š**ï¼šä¸Claudeè¿›ç¨‹å®Œå…¨ç»‘å®š
4. **å†…ç½®æ¢å¤**ï¼šå¼‚å¸¸æ—¶è‡ªåŠ¨é‡æ–°å¯åŠ¨
5. **ç®€æ´è¯Šæ–­**ï¼šä»…ä¿ç•™å¿…è¦çš„çŠ¶æ€æŸ¥çœ‹åŠŸèƒ½

### âœ… ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- **é›¶å­¦ä¹ æˆæœ¬**ï¼šé€šè¿‡ /codex-help ä¸€é”®æŸ¥çœ‹å…¨éƒ¨å‘½ä»¤
- **é€æ˜è¿è¡Œ**ï¼šå¯åŠ¨åå®Œå…¨æ— æ„ŸçŸ¥ä½¿ç”¨
- **è‡ªåŠ¨æ¸…ç†**ï¼šé€€å‡ºæ—¶æ— éœ€æ‰‹åŠ¨æ“ä½œ
- **çŠ¶æ€åé¦ˆ**ï¼šæ¸…æ™°çš„æœåŠ¡çŠ¶æ€æç¤º

### ğŸ”§ å®ç°å¤æ‚åº¦ï¼ˆæœ€ç»ˆç‰ˆï¼‰
- **ç­‰çº§**ï¼šåˆçº§
- **æ ¸å¿ƒä»£ç **ï¼šçº¦180è¡ŒPythonä»£ç 
- **ä¾èµ–**ï¼šPythonæ ‡å‡†åº“
- **å¼€å‘æ—¶é—´**ï¼š30åˆ†é’Ÿ
- **æµ‹è¯•æ—¶é—´**ï¼š20åˆ†é’Ÿ

## ä½¿ç”¨æµç¨‹ï¼ˆClaudeå†…éƒ¨è§¦å‘ï¼‰

### 1. Claudeå†…éƒ¨æ¿€æ´»æµç¨‹
```python
# Claude Codeå†…éƒ¨é€»è¾‘
class ClaudeCode:
    def __init__(self):
        self.codex_manager = None
        self.codex_active = False

    def activate_codex(self):
        """ç”¨æˆ·é¦–æ¬¡ä½¿ç”¨æ—¶æ¿€æ´»Codex"""
        if not self.codex_active:
            print("æ­£åœ¨å¯åŠ¨CodexæœåŠ¡...")
            self.codex_manager = ClaudeCodexManager()
            self.codex_manager.start_codex_process()
            self.codex_active = True
            print("CodexæœåŠ¡å·²å¯åŠ¨ï¼Œå¯ä»¥å¼€å§‹å¯¹è¯")

    def handle_user_command(self, command):
        # é¦–æ¬¡ä½¿ç”¨ /codex- ç³»åˆ—å‘½ä»¤æ—¶è‡ªåŠ¨æ¿€æ´»
        if command.startswith("/codex-"):
            if not self.codex_active:
                self.activate_codex()

        if command == "/codex-start":
            self.activate_codex()
            return "CodexæœåŠ¡å·²å¯åŠ¨"

        elif command.startswith("/codex-ask"):
            if not self.codex_active:
                return "è¯·å…ˆè¿è¡Œ /codex-start å¯åŠ¨æœåŠ¡ï¼Œæˆ–è¾“å…¥ /codex-help æŸ¥çœ‹æŒ‡å¼•"
            question = command.replace("/codex-ask ", "")
            response = self.codex_manager.send_to_codex(question)
            return response["message"]

        elif command.startswith("/codex-config"):
            parts = command.split()
            if len(parts) == 1:
                return self.codex_manager.show_config()
            elif len(parts) == 2:
                return self.codex_manager.set_profile(parts[1])
            else:
                return "ç”¨æ³•: /codex-config [high|default|low]"

        elif command.startswith("/codex-reasoning"):
            parts = command.split()
            if len(parts) != 2:
                return "ç”¨æ³•: /codex-reasoning <on|off>"
            return self.codex_manager.update_show_reasoning(parts[1])

        elif command.startswith("/codex-final_only"):
            parts = command.split()
            if len(parts) != 2:
                return "ç”¨æ³•: /codex-final_only <on|off>"
            return self.codex_manager.update_output_format(parts[1])

        elif command == "/codex-status":
            return self.codex_manager.show_status()

        elif command == "/codex-help":
            return self.codex_manager.show_help()

        elif command == "/codex-stop":
            if self.codex_active:
                self.codex_manager.cleanup()
                self.codex_active = False
                return "CodexæœåŠ¡å·²åœæ­¢"
            else:
                return "CodexæœåŠ¡æœªè¿è¡Œ"

        # å…¶ä»–å‘½ä»¤å¤„ç†...
```

### 2. Claudeå†…éƒ¨å‘½ä»¤å¤„ç†ï¼ˆè‡ªåŠ¨æ¿€æ´»ï¼‰
```python
class ClaudeCode:
    def __init__(self):
        self.codex_manager = ClaudeCodexManager()
        # æ³¨å†Œé€€å‡ºæ¸…ç†
        import atexit
        atexit.register(self.codex_manager.claude_cleanup_on_exit)

    def handle_command(self, command):
        # Claudeå†…éƒ¨ç»Ÿä¸€å‘½ä»¤å¤„ç†ï¼Œè‡ªåŠ¨æ¿€æ´»
        if command.startswith("/codex-"):
            # é¦–æ¬¡ä½¿ç”¨æ—¶è‡ªåŠ¨æ¿€æ´»
            if not self.codex_manager.codex_active:
                self.codex_manager.auto_activate_on_first_use()
                print("æ­£åœ¨å¯åŠ¨CodexæœåŠ¡...")

        if command == "/codex-start":
            if not self.codex_manager.codex_active:
                self.codex_manager.auto_activate_on_first_use()
                return "âœ… CodexæœåŠ¡å·²å¯åŠ¨"
            else:
                return "â„¹ï¸ CodexæœåŠ¡å·²åœ¨è¿è¡Œ"

        elif command.startswith("/codex-ask"):
            if not self.codex_manager.codex_active:
                return "âŒ è¯·å…ˆè¿è¡Œ /codex-start å¯åŠ¨æœåŠ¡ï¼Œæˆ–è¾“å…¥ /codex-help æŸ¥çœ‹æŒ‡å¼•"

            question = command.replace("/codex-ask ", "")
            response = self.codex_manager.send_to_codex(question)
            return response["message"]

        elif command == "/codex-stop":
            if self.codex_manager.codex_active:
                self.codex_manager.claude_cleanup_on_exit()
                return "âœ… CodexæœåŠ¡å·²åœæ­¢"
            else:
                return "â„¹ï¸ CodexæœåŠ¡æœªè¿è¡Œ"

        elif command == "/codex-status":
            if self.codex_manager.codex_active:
                return f"âœ… Codexè¿è¡Œä¸­ (å®ä¾‹ID: {self.codex_manager.instance_id}, Profile: {self.codex_manager.current_profile})"
            else:
                return "âŒ CodexæœåŠ¡æœªè¿è¡Œ"

        elif command.startswith("/codex-config"):
            parts = command.split()
            if len(parts) == 1:
                return self.codex_manager.show_config()
            elif len(parts) == 2:
                return self.codex_manager.set_profile(parts[1])
            else:
                return "ç”¨æ³•: /codex-config [high|default|low]"

        elif command.startswith("/codex-reasoning"):
            parts = command.split()
            if len(parts) != 2:
                return "ç”¨æ³•: /codex-reasoning <on|off>"
            return self.codex_manager.update_show_reasoning(parts[1])

        elif command.startswith("/codex-final_only"):
            parts = command.split()
            if len(parts) != 2:
                return "ç”¨æ³•: /codex-final_only <on|off>"
            return self.codex_manager.update_output_format(parts[1])

        elif command == "/codex-help":
            return self.codex_manager.show_help()
```

### 3. ç®€åŒ–è¯Šæ–­å·¥å…·ï¼ˆä»…ä¾›é—®é¢˜æ’æŸ¥ï¼‰
```bash
#!/bin/bash
# codex-diagnose - ç³»ç»Ÿçº§è¯Šæ–­å·¥å…·ï¼Œä¸ç”¨äºæ—¥å¸¸ç®¡ç†

show_codex_diagnosis() {
    echo "=== Codexç³»ç»Ÿè¯Šæ–­ ==="

    # æ˜¾ç¤ºå½“å‰ç”¨æˆ·çš„Claudeè¿›ç¨‹
    echo "å½“å‰ç”¨æˆ·çš„Claudeè¿›ç¨‹ï¼š"
    ps aux | grep -E "(claude|Claude)" | grep -v grep || echo "æœªæ‰¾åˆ°Claudeè¿›ç¨‹"

    # æŸ¥æ‰¾Codexå­è¿›ç¨‹
    echo -e "\nCodexå­è¿›ç¨‹ï¼š"
    ps aux | grep codex_process | grep -v grep || echo "æœªæ‰¾åˆ°Codexè¿›ç¨‹"

    # æŸ¥æ‰¾Socketæ–‡ä»¶
    echo -e "\næ´»è·ƒçš„Socketæ–‡ä»¶ï¼š"
    find /tmp -name "codex-*.sock" -user $(whoami) 2>/dev/null | while read sock; do
        echo "Socket: $sock"
        echo "æƒé™: $(ls -l $sock)"
        # å°è¯•è·å–å…³è”çš„è¿›ç¨‹ä¿¡æ¯
        pid=$(lsof -t "$sock" 2>/dev/null)
        if [ -n "$pid" ]; then
            echo "å…³è”è¿›ç¨‹: $pid"
        fi
        echo "---"
    done

    # æŸ¥æ‰¾å†å²æ–‡ä»¶
    echo -e "\nå†å²æ–‡ä»¶ï¼š"
    find /tmp -name "codex-*-history.json" -user $(whoami) 2>/dev/null | while read hist; do
        echo "å†å²: $hist"
        echo "å¤§å°: $(du -h $hist | cut -f1)"
        echo "ä¿®æ”¹æ—¶é—´: $(stat -c %y $hist)"
        echo "---"
    done
}

show_codex_diagnosis
```

### 3. è‡ªåŠ¨ç”Ÿå‘½å‘¨æœŸç®¡ç†
```python
class ClaudeCodexManager:
    def __init__(self):
        self.socket_path = None
        self.codex_pid = None
        self.history_file = None

    def start_codex_process(self):
        """å¯åŠ¨Codexå­è¿›ç¨‹"""
        import os
        import uuid

        # åŸºäºClaudeè¿›ç¨‹IDç”Ÿæˆè·¯å¾„
        claude_pid = os.getppid()
        unique_id = str(uuid.uuid4())[:8]
        self.socket_path = f"/tmp/codex-{claude_pid}-{unique_id}.sock"
        self.history_file = self.socket_path.replace('.sock', '-history.json')

        # forkå­è¿›ç¨‹
        pid = os.fork()
        if pid == 0:  # å­è¿›ç¨‹
            self._run_codex_daemon()
            os._exit(0)
        else:  # çˆ¶è¿›ç¨‹
            self.codex_pid = pid
            self._monitor_child_process()

    def _monitor_child_process(self):
        """ç›‘æ§å­è¿›ç¨‹çŠ¶æ€"""
        import threading
        import time
        import os
        import signal

        def monitor():
            while True:
                try:
                    # æ£€æŸ¥å­è¿›ç¨‹æ˜¯å¦è¿˜åœ¨è¿è¡Œ
                    os.waitpid(self.codex_pid, os.WNOHANG)
                except OSError:
                    # å­è¿›ç¨‹å·²é€€å‡ºï¼Œé‡æ–°å¯åŠ¨
                    print("æ£€æµ‹åˆ°Codexè¿›ç¨‹å¼‚å¸¸ï¼Œæ­£åœ¨é‡æ–°å¯åŠ¨...")
                    self.start_codex_process()
                    break
                time.sleep(1)

        monitor_thread = threading.Thread(target=monitor, daemon=True)
        monitor_thread.start()

    def cleanup(self):
        """æ¸…ç†Codexè¿›ç¨‹"""
        if self.codex_pid:
            try:
                os.kill(self.codex_pid, signal.SIGTERM)
                os.waitpid(self.codex_pid, 0)
                os.unlink(self.socket_path)
            except:
                pass
```

## å®‰å…¨éš”ç¦»å’Œæƒé™æ§åˆ¶

### 1. æ¯å®ä¾‹ç‹¬ç«‹Socketç›®å½•å’Œæƒé™
- **ä¸“ç”¨Socketè·¯å¾„**ï¼š`/tmp/codex-{claude_pid}-{instance_id}.sock`
- **è‡ªåŠ¨æƒé™è®¾ç½®**ï¼šSocketæ–‡ä»¶è‡ªåŠ¨è®¾ç½®0600æƒé™ï¼ˆä»…ç”¨æˆ·å¯è¯»å†™ï¼‰
- **ç”¨æˆ·éš”ç¦»**ï¼šä¸åŒç”¨æˆ·çš„Socketæ–‡ä»¶å®Œå…¨éš”ç¦»
- **è¿›ç¨‹éš”ç¦»**ï¼šé€šè¿‡æ–‡ä»¶ç³»ç»Ÿæƒé™å¤©ç„¶éš”ç¦»ä¸åŒå®ä¾‹

##### å®‰å…¨è·¯å¾„ç”Ÿæˆå’Œæƒé™è®¾ç½®ï¼š
```python
class ClaudeCodexManager:
    def _generate_secure_socket_path(self):
        """ç”Ÿæˆå®‰å…¨çš„Socketè·¯å¾„"""
        claude_pid = os.getppid()
        instance_id = self._generate_instance_id()

        # ç”Ÿæˆç”¨æˆ·ä¸“ç”¨çš„Socketè·¯å¾„
        socket_path = f"/tmp/codex-{claude_pid}-{instance_id}.sock"

        # ç¡®ä¿åœ¨ç”¨æˆ·å¯å†™çš„ç›®å½•ä¸­
        if not os.path.exists("/tmp"):
            raise Exception("/tmpç›®å½•ä¸å¯è®¿é—®")

        return socket_path

    def _setup_socket_permissions(self, socket_path):
        """è®¾ç½®Socketæ–‡ä»¶æƒé™"""
        # è®¾ç½®æ–‡ä»¶æƒé™ä¸ºä»…ç”¨æˆ·å¯è¯»å†™
        os.chmod(socket_path, 0o600)

        # éªŒè¯æƒé™è®¾ç½®æˆåŠŸ
        file_stat = os.stat(socket_path)
        if file_stat.st_mode & 0o777 != 0o600:
            raise Exception("Socketæƒé™è®¾ç½®å¤±è´¥")
```

##### Codexå­è¿›ç¨‹çš„å®‰å…¨å¯åŠ¨ï¼š
```python
class CodexProcess:
    def run(self):
        """å®‰å…¨å¯åŠ¨CodexæœåŠ¡"""
        # åŠ è½½å†å²è®°å½•
        self._load_history_securely()

        # åˆ›å»ºSocketå¹¶è®¾ç½®å®‰å…¨æƒé™
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)

        # ç¡®ä¿æ–‡ä»¶ä¸å­˜åœ¨ï¼Œé¿å…æƒé™é—®é¢˜
        if os.path.exists(self.socket_path):
            os.unlink(self.socket_path)

        sock.bind(self.socket_path)

        # ç«‹å³è®¾ç½®æƒé™
        os.chmod(self.socket_path, 0o600)

        # éªŒè¯æƒé™
        self._verify_socket_permissions()

        sock.listen(1)
        self.running = True

        # å¤„ç†è¯·æ±‚
        while self.running:
            try:
                conn, addr = sock.accept()
                # éªŒè¯è¿æ¥æƒé™ï¼ˆUnix Socketå¤©ç„¶æœ‰æ–‡ä»¶ç³»ç»Ÿä¿æŠ¤ï¼‰
                self._handle_connection(conn)
            except:
                break

        sock.close()

    def _verify_socket_permissions(self):
        """éªŒè¯Socketæ–‡ä»¶æƒé™"""
        file_stat = os.stat(self.socket_path)
        file_mode = file_stat.st_mode & 0o777

        if file_mode != 0o600:
            # æƒé™ä¸æ­£ç¡®ï¼Œé‡æ–°è®¾ç½®
            os.chmod(self.socket_path, 0o600)

        # éªŒè¯æ‰€æœ‰è€…
        if file_stat.st_uid != os.getuid():
            raise Exception("Socketæ–‡ä»¶æ‰€æœ‰è€…ä¸æ­£ç¡®")

    def _load_history_securely(self):
        """å®‰å…¨åŠ è½½å†å²è®°å½•"""
        history_file = self.socket_path.replace('.sock', '-history.json')

        if os.path.exists(history_file):
            # éªŒè¯æ–‡ä»¶æƒé™
            file_stat = os.stat(history_file)
            if file_stat.st_uid != os.getuid():
                # ä¸æ˜¯æ‰€æœ‰è€…çš„æ–‡ä»¶ï¼Œæ‹’ç»åŠ è½½
                print("è­¦å‘Šï¼šå†å²æ–‡ä»¶æ‰€æœ‰è€…ä¸æ­£ç¡®ï¼Œè·³è¿‡åŠ è½½")
                return

            if file_stat.st_mode & 0o077 != 0:
                # æ–‡ä»¶æƒé™è¿‡äºå¼€æ”¾ï¼Œæ‹’ç»åŠ è½½
                print("è­¦å‘Šï¼šå†å²æ–‡ä»¶æƒé™è¿‡äºå¼€æ”¾ï¼Œè·³è¿‡åŠ è½½")
                return

            try:
                with open(history_file, 'r') as f:
                    data = json.load(f)

                # éªŒè¯æ•°æ®åŒ…å«æ­£ç¡®çš„instance_id
                if data.get("instance_id") == self.instance_id:
                    self.conversation_history = data.get("conversation_history", [])
                else:
                    print("è­¦å‘Šï¼šå†å²æ–‡ä»¶instance_idä¸åŒ¹é…ï¼Œè·³è¿‡åŠ è½½")

            except Exception as e:
                print(f"è­¦å‘Šï¼šåŠ è½½å†å²æ–‡ä»¶å¤±è´¥: {e}")
```

### 2. è¿›ç¨‹çº§å®‰å…¨éš”ç¦»
- **çˆ¶è¿›ç¨‹ç›‘æ§**ï¼šåªæœ‰Claudeçˆ¶è¿›ç¨‹èƒ½ç®¡ç†Codexå­è¿›ç¨‹
- **ä¿¡å·æ§åˆ¶**ï¼šåªæœ‰çˆ¶è¿›ç¨‹èƒ½å‘å­è¿›ç¨‹å‘é€ä¿¡å·
- **è¿›ç¨‹æ ‘éš”ç¦»**ï¼šä¸åŒClaudeè¿›ç¨‹çš„Codexå­è¿›ç¨‹å®Œå…¨éš”ç¦»
- **ç”¨æˆ·çº§éš”ç¦»**ï¼šä¸åŒç”¨æˆ·çš„è¿›ç¨‹å¤©ç„¶éš”ç¦»

### 3. å¼‚å¸¸æƒ…å†µçš„å®‰å…¨å¤„ç†
- **æƒé™éªŒè¯å¤±è´¥**ï¼šæ‹’ç»å¯åŠ¨å¹¶è®°å½•é”™è¯¯
- **æ–‡ä»¶æƒé™é”™è¯¯**ï¼šè‡ªåŠ¨ä¿®å¤æˆ–æ‹’ç»ä½¿ç”¨
- **è¿›ç¨‹å¼‚å¸¸é€€å‡º**ï¼šClaudeé‡æ–°æ‹‰èµ·ï¼Œä¿æŒå®‰å…¨é…ç½®
- **æœªæˆæƒè®¿é—®**ï¼šUnix Socketçš„æ–‡ä»¶ç³»ç»Ÿæƒé™å¤©ç„¶é˜²æŠ¤

### 4. èµ„æºæ¸…ç†å®‰å…¨ç­–ç•¥
- **ä¼˜é›…é€€å‡º**ï¼šSIGTERMä¿¡å·ç¡®ä¿æ•°æ®ä¿å­˜
- **å¼ºåˆ¶æ¸…ç†**ï¼šé€€å‡ºæ—¶åˆ é™¤æ‰€æœ‰ç›¸å…³æ–‡ä»¶
- **æƒé™éªŒè¯**ï¼šæ¸…ç†å‰éªŒè¯æ–‡ä»¶æ‰€æœ‰æƒ
- **æ®‹ç•™æ£€æµ‹**ï¼šå¯åŠ¨æ—¶æ£€æŸ¥å¹¶æ¸…ç†å†å²æ®‹ç•™

## ä½¿ç”¨æµç¨‹å’Œé…ç½®ç®¡ç†ï¼ˆå®Œæ•´ç‰ˆï¼‰

### 1. é…ç½®ä¸æ¨¡å‹å¼ºåº¦ä½¿ç”¨æµç¨‹

#### åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹ï¼š
```bash
# æ­¥éª¤1ï¼šå¯åŠ¨æœåŠ¡
ç”¨æˆ·: /codex-start
Claude: âœ… CodexæœåŠ¡å·²å¯åŠ¨ (å®ä¾‹ID: abc123def, é»˜è®¤Profile: default)

# æ­¥éª¤2ï¼šæŸ¥çœ‹å½“å‰é…ç½®
ç”¨æˆ·: /codex-config
Claude: ğŸ“‹ å½“å‰é…ç½®:
â€¢ Profile: default (å¹³è¡¡æ¨¡å¼)
â€¢ Instance ID: abc123def
â€¢ Socket: /tmp/codex-12345-abc123def.sock
â€¢ Show Reasoning: off  (on=è¾“å‡ºæ¨ç†æ‘˜è¦ï¼›off=ä»…å†…éƒ¨ä½¿ç”¨)
â€¢ Output Format: final_only  (final_only=åªè¾“å‡ºæœ€ç»ˆç­”æ¡ˆ)

# æ­¥éª¤3ï¼šåˆ‡æ¢åˆ°é«˜å¼ºåº¦æ¨¡å‹
ç”¨æˆ·: /codex-config high
Claude: âœ… Profileå·²æ›´æ–°ä¸º: high

ğŸ“‹ æ¨¡å‹å¼ºåº¦è¯´æ˜:
â€¢ high: æ·±åº¦åˆ†æ (æ¸©åº¦ 0.1 / æœ€å¤§é•¿åº¦ 4000)
â€¢ default: å¹³è¡¡æ¨¡å¼ (æ¸©åº¦ 0.2 / æœ€å¤§é•¿åº¦ 2000)
â€¢ low: ç®€æ´å¿«é€Ÿ (æ¸©åº¦ 0.3 / æœ€å¤§é•¿åº¦ 1000)

# æ­¥éª¤4ï¼šä½¿ç”¨é«˜å¼ºåº¦æ¨¡å¼å¯¹è¯
ç”¨æˆ·: /codex-ask è§£é‡Šé‡å­è®¡ç®—çš„åŸºæœ¬åŸç†
Claude: ğŸ¤– [Profile: high]
é‡å­è®¡ç®—æ˜¯ä¸€ç§é©å‘½æ€§çš„è®¡ç®—èŒƒå¼...
[è¯¦ç»†çš„æ·±åº¦è§£é‡Šï¼ŒåŒ…å«æ•°å­¦å…¬å¼å’Œåº”ç”¨åœºæ™¯]

# æ­¥éª¤5ï¼šè°ƒæ•´è¾“å‡ºè¡Œä¸ºï¼ˆä»…æœ€ç»ˆç­”æ¡ˆï¼‰
ç”¨æˆ·: /codex-final_only on
Claude: âœ… Output Format å·²åˆ‡æ¢ä¸º final_only ï¼ˆæ¨èä¿æŒå¼€å¯ä»¥é¿å…é¢å¤–å™ªéŸ³ï¼‰

# æ­¥éª¤6ï¼šå…³é—­æ¨ç†å±•ç¤º
ç”¨æˆ·: /codex-reasoning off
Claude: âœ… Show Reasoning å·²è®¾ç½®ä¸º off ï¼ˆå·²å…³é—­æ¨ç†å±•ç¤ºï¼‰

# æ­¥éª¤7ï¼šåˆ‡æ¢åˆ°ä½å¼ºåº¦æ¨¡å‹
ç”¨æˆ·: /codex-config low
Claude: âœ… Profileå·²æ›´æ–°ä¸º: low

# æ­¥éª¤8ï¼šä½¿ç”¨ä½å¼ºåº¦æ¨¡å¼å¯¹è¯
ç”¨æˆ·: /codex-ask ä»€ä¹ˆæ˜¯é‡å­è®¡ç®—ï¼Ÿ
Claude: ğŸ¤– [Profile: low]
é‡å­è®¡ç®—æ˜¯åˆ©ç”¨é‡å­åŠ›å­¦åŸç†è¿›è¡Œä¿¡æ¯å¤„ç†çš„æ–°å‹è®¡ç®—æŠ€æœ¯ã€‚

# æ­¥éª¤9ï¼šæŸ¥çœ‹æœåŠ¡çŠ¶æ€
ç”¨æˆ·: /codex-status
Claude: âœ… CodexæœåŠ¡è¿è¡Œä¸­:
â€¢ å®ä¾‹ID: abc123def
â€¢ å½“å‰Profile: low
â€¢ Show Reasoning: off
â€¢ Output Format: final_only
â€¢ è¿›ç¨‹PID: 54321
â€¢ Socket: /tmp/codex-12345-abc123def.sock
```

#### é…ç½®è¡Œä¸ºè¯´æ˜ï¼š
- **æ¨¡å‹å¼ºåº¦**ï¼š`/codex-config <high|default|low>` å³æ—¶ç”Ÿæ•ˆï¼Œä¸å½±å“ç°æœ‰å†å²
- **æ¨ç†å±•ç¤º**ï¼š`/codex-reasoning on/off` ä»…æ§åˆ¶æ˜¯å¦å‘Claudeå›æ˜¾æ¨ç†ï¼Œæ¨èä¿æŒ off
- **è¾“å‡ºæ ¼å¼**ï¼š`/codex-final_only on/off` å†³å®šæ˜¯å¦ä»…è¿”å›æœ€ç»ˆç­”æ¡ˆï¼Œæ¨èä¿æŒ on

### 2. é”™è¯¯å¤„ç†å’Œå¼‚å¸¸æƒ…å†µ

#### å¸¸è§é”™è¯¯åœºæ™¯ï¼š
```bash
# åœºæ™¯1ï¼šæœåŠ¡æœªæ¿€æ´»æ—¶å°è¯•é…ç½®
ç”¨æˆ·: /codex-config high
Claude: âŒ CodexæœåŠ¡æœªæ¿€æ´»ï¼Œè¯·å…ˆè¿è¡Œ /codex-startï¼Œæˆ–è¾“å…¥ /codex-help æŸ¥çœ‹æŒ‡å¼•

# åœºæ™¯2ï¼šæ— æ•ˆçš„æ¨¡å‹å¼ºåº¦
ç”¨æˆ·: /codex-config ultra
Claude: âŒ æ— æ•ˆå‚æ•°ï¼Œè¯·ä½¿ç”¨: highã€defaultã€low

# åœºæ™¯3ï¼šç¼ºå°‘å¼€å…³å‚æ•°
ç”¨æˆ·: /codex-reasoning
Claude: âŒ å‚æ•°é”™è¯¯
ç”¨æ³•: /codex-reasoning <on|off>

# åœºæ™¯4ï¼šæ¨ç†å±•ç¤ºå‚æ•°é”™è¯¯
ç”¨æˆ·: /codex-reasoning maybe
Claude: âŒ å‚æ•°é”™è¯¯
ç”¨æ³•: /codex-reasoning <on|off>

# åœºæ™¯5ï¼šOutput Format å‚æ•°é”™è¯¯
ç”¨æˆ·: /codex-final_only maybe
Claude: âŒ å‚æ•°é”™è¯¯
ç”¨æ³•: /codex-final_only <on|off>

# åœºæ™¯6ï¼šCodexè¿›ç¨‹å¼‚å¸¸é‡å¯
ç³»ç»Ÿ: Codexè¿›ç¨‹å¼‚å¸¸é€€å‡ºï¼Œæ­£åœ¨é‡æ–°å¯åŠ¨...
ç³»ç»Ÿ: å·²æ¢å¤ 15 æ¡å¯¹è¯å†å²ï¼ŒProfile: high

# åœºæ™¯7ï¼šç½‘ç»œè¿æ¥é—®é¢˜
ç”¨æˆ·: /codex-ask æµ‹è¯•é—®é¢˜
Claude: âŒ è¯·æ±‚å¤±è´¥: è¿æ¥CodexæœåŠ¡å¤±è´¥ï¼Œæ­£åœ¨é‡æ–°è¿æ¥...
Claude: ğŸ¤– [Profile: high] è¿æ¥å·²æ¢å¤ï¼Œè¿™æ˜¯ä½ çš„å›ç­”...
```

#### æ¢å¤æœºåˆ¶ï¼š
1. **è‡ªåŠ¨é‡è¿**ï¼šè¿æ¥å¤±è´¥æ—¶è‡ªåŠ¨å°è¯•é‡æ–°è¿æ¥
2. **çŠ¶æ€æ¢å¤**ï¼šè¿›ç¨‹é‡å¯åè‡ªåŠ¨æ¢å¤profileã€æ¨ç†å¼€å…³ä¸å¯¹è¯å†å²
3. **é™çº§å¤„ç†**ï¼šä¸¥é‡é”™è¯¯æ—¶é™çº§åˆ°default profile
4. **ç”¨æˆ·é€šçŸ¥**ï¼šæ‰€æœ‰å¼‚å¸¸å’Œæ¢å¤è¿‡ç¨‹éƒ½æœ‰æ˜ç¡®æç¤º

### 3. é…ç½®æŒä¹…åŒ–å’Œæ—¥å¿—è®°å½•

#### çŠ¶æ€æŒä¹…åŒ–ï¼š
```json
// å†å²æ–‡ä»¶ç»“æ„ (codex-12345-abc123def-history.json)
{
  "instance_id": "abc123def",
  "current_profile": "high",
  "conversation_history": [
    {
      "role": "user",
      "content": "è§£é‡Šé‡å­è®¡ç®—",
      "timestamp": 1734987654,
      "profile": "high"
    },
    {
      "role": "assistant",
      "content": "é‡å­è®¡ç®—æ˜¯...",
      "timestamp": 1734987655,
      "profile": "high"
    }
  ],
  "saved_at": 1734987656,
  "version": "1.0"
}
```

#### é…ç½®å˜æ›´æ—¥å¿—ï¼š
```
[Codex Config] profile: default -> high     (ç”¨æˆ·åˆ‡æ¢åˆ°è¯¦ç»†æ¨¡å¼)
[Codex Config] profile: high -> low       (ç”¨æˆ·åˆ‡æ¢åˆ°ç®€æ´æ¨¡å¼)
[Codex Config] profile: low -> default     (ç³»ç»Ÿé‡å¯æ¢å¤é»˜è®¤å€¼)
```

### 4. å®‰å…¨é™åˆ¶å’Œæ³¨æ„äº‹é¡¹

#### å®‰å…¨çº¦æŸï¼š
- **å‚æ•°éªŒè¯**ï¼šä¸¥æ ¼éªŒè¯æ‰€æœ‰profileå‚æ•°ï¼Œé˜²æ­¢æ³¨å…¥æ”»å‡»
- **æƒé™æ§åˆ¶**ï¼šé…ç½®å˜æ›´ä»…é™å½“å‰ç”¨æˆ·å®ä¾‹
- **çŠ¶æ€éš”ç¦»**ï¼šä¸åŒClaudeå®ä¾‹çš„é…ç½®å®Œå…¨éš”ç¦»
- **å®¡è®¡æ—¥å¿—**ï¼šè®°å½•æ‰€æœ‰é…ç½®å˜æ›´ä¾¿äºå®¡è®¡

#### ä½¿ç”¨æ³¨æ„äº‹é¡¹ï¼š
1. **Profileé€‰æ‹©**ï¼š
   - `high`ï¼šé€‚åˆéœ€è¦æ·±åº¦åˆ†æã€è¯¦ç»†è§£é‡Šçš„åœºæ™¯
   - `low`ï¼šé€‚åˆå¿«é€Ÿé—®ç­”ã€ç®€æ´å“åº”çš„åœºæ™¯
   - `default`ï¼šå¹³è¡¡æ¨¡å¼ï¼Œé€‚åˆä¸€èˆ¬å¯¹è¯

2. **æ€§èƒ½å½±å“**ï¼š
   - `high` profileå“åº”æ—¶é—´è¾ƒé•¿ï¼Œä½†è´¨é‡æ›´é«˜
   - `low` profileå“åº”å¿«é€Ÿï¼Œé€‚åˆé«˜é¢‘äº¤äº’
   - åˆ‡æ¢profileä¸ä¼šå½±å“å·²æœ‰å¯¹è¯å†å²

3. **èµ„æºç®¡ç†**ï¼š
   - å¯¹è¯å†å²è‡ªåŠ¨é™åˆ¶åœ¨100è½®ä»¥å†…
   - é…ç½®å˜æ›´ä¼šç«‹å³æŒä¹…åŒ–åˆ°æœ¬åœ°æ–‡ä»¶
   - å¼‚å¸¸é€€å‡ºæ—¶è‡ªåŠ¨æ¢å¤æœ€åçŠ¶æ€

4. **æ•…éšœå¤„ç†**ï¼š
   - é…ç½®å˜æ›´å¤±è´¥æ—¶å›é€€åˆ°ä¹‹å‰çš„profile
   - è¿›ç¨‹å´©æºƒæ—¶è‡ªåŠ¨é‡å¯å¹¶æ¢å¤é…ç½®
   - ç½‘ç»œé—®é¢˜æ—¶æœ‰é‡è¯•æœºåˆ¶

---

## æ€»ç»“

è¿™ä¸ª**Claudeå†…éƒ¨è§¦å‘çš„å­è¿›ç¨‹æ–¹æ¡ˆ**å®Œç¾å¹³è¡¡äº†è‡ªåŠ¨åŒ–å’Œç”¨æˆ·æ§åˆ¶ï¼š

### âœ… æ ¸å¿ƒè®¾è®¡ç†å¿µ
1. **ä¸€æ¬¡æ€§æ¿€æ´»**ï¼šç”¨æˆ·åªéœ€åœ¨Claudeå†…è¿è¡Œä¸€æ¬¡ /codex-start
2. **å†…éƒ¨è‡ªåŠ¨åŒ–**ï¼šæ‰€æœ‰é…ç½®ã€è·¯å¾„ã€è¿›ç¨‹ç®¡ç†å®Œå…¨è‡ªåŠ¨
3. **ç”Ÿå‘½å‘¨æœŸç»‘å®š**ï¼šCodexä¸Claudeè¿›ç¨‹å®Œå…¨åŒæ­¥
4. **é€æ˜ä½¿ç”¨**ï¼šæ¿€æ´»åæ—¥å¸¸åªéœ€ä½¿ç”¨ /codex-ask å¯¹è¯
5. **è‡ªåŠ¨æ¸…ç†**ï¼šClaudeé€€å‡ºæ—¶è‡ªåŠ¨æ¸…ç†æ‰€æœ‰èµ„æº

### âœ… å…³é”®æŠ€æœ¯ç‰¹ç‚¹
- **å†…éƒ¨è§¦å‘**ï¼šæ¿€æ´»ç”±Claudeç¯å¢ƒå†…éƒ¨è§¦å‘ï¼Œè€Œéå¤–éƒ¨å‘½ä»¤
- **è‡ªåŠ¨è·¯å¾„**ï¼š`/tmp/codex-{claude_pid}-{uuid}.sock`è‡ªåŠ¨ç”Ÿæˆ
- **å­è¿›ç¨‹ç›‘æ§**ï¼šå®æ—¶ç›‘æ§ï¼Œå¼‚å¸¸æ—¶è‡ªåŠ¨é‡æ–°å¯åŠ¨
- **ä¿¡å·å¤„ç†**ï¼šä¼˜é›…é€€å‡ºå’Œæ•°æ®æŒä¹…åŒ–
- **ç®€åŒ–è¯Šæ–­**ï¼šä»…ä¿ç•™ç³»ç»Ÿçº§çŠ¶æ€æŸ¥çœ‹å·¥å…·

### âœ… ç”¨æˆ·å·¥ä½œæµç¨‹
```bash
# 1. å¯åŠ¨Claudeï¼ˆæ— å˜åŒ–ï¼‰
# 2. åœ¨Claudeä¸­æ¿€æ´»ï¼ˆä¸€æ¬¡æ€§ï¼‰
ç”¨æˆ·: /codex-start
Claude: âœ… CodexæœåŠ¡å·²å¯åŠ¨ï¼Œå¯ä»¥å¼€å§‹å¯¹è¯

# 3. æŸ¥çœ‹å¸®åŠ©ä¸å‘½ä»¤è¯´æ˜
ç”¨æˆ·: /codex-help
Claude: ğŸ“– Codexå‘½ä»¤å¸®åŠ©ï¼ˆClaudeå†…ç½®ï¼‰
â€¢ /codex-start  å¯åŠ¨æˆ–é‡æ–°è¿æ¥Codexå­è¿›ç¨‹
â€¢ /codex-ask <é—®é¢˜>  å‘èµ·æé—®
â€¢ /codex-config [high|default|low]  æŸ¥çœ‹æˆ–åˆ‡æ¢æ¨¡å‹å¼ºåº¦
â€¢ /codex-reasoning <on|off>  æ§åˆ¶æ¨ç†æ‘˜è¦å±•ç¤º
â€¢ /codex-final_only <on|off>  æ§åˆ¶æ˜¯å¦ä»…è¿”å›æœ€ç»ˆç­”æ¡ˆ
â€¢ /codex-status  æŸ¥çœ‹å®ä¾‹/å¼€å…³/è¿›ç¨‹ä¿¡æ¯
â€¢ /codex-stop  åœæ­¢å½“å‰Codex
â€¢ /codex-help  æ˜¾ç¤ºå¸®åŠ©
âš™ï¸ å»ºè®®: éœ€è¦é‡ç½®å¯¹è¯æ—¶ï¼Œå¯ä½¿ç”¨ Claude è‡ªå¸¦çš„ /rewind æˆ– /clearã€‚

# 4. æŸ¥çœ‹å½“å‰é…ç½®
ç”¨æˆ·: /codex-config
Claude: ğŸ“‹ å½“å‰é…ç½®:
â€¢ Profile: default
â€¢ Instance ID: abc123def
â€¢ Socket: /tmp/codex-12345-abc123def.sock
â€¢ Show Reasoning: false
â€¢ Output Format: final_only

# 5. åˆ‡æ¢æ¨¡å‹å¼ºåº¦
ç”¨æˆ·: /codex-config high
Claude: âœ… Profileå·²æ›´æ–°ä¸º: high

ğŸ“‹ æ¨¡å‹å¼ºåº¦è¯´æ˜:
â€¢ high: æ·±åº¦åˆ†æ (æ¸©åº¦ 0.1 / æœ€å¤§é•¿åº¦ 4000)
â€¢ default: å¹³è¡¡æ¨¡å¼ (æ¸©åº¦ 0.2 / æœ€å¤§é•¿åº¦ 2000)
â€¢ low: ç®€æ´å¿«é€Ÿ (æ¸©åº¦ 0.3 / æœ€å¤§é•¿åº¦ 1000)

# 6. æ§åˆ¶è¾“å‡ºè¡Œä¸º
ç”¨æˆ·: /codex-reasoning off
Claude: âœ… Show Reasoning å·²è®¾ç½®ä¸º off ï¼ˆå·²å…³é—­æ¨ç†å±•ç¤ºï¼‰

ç”¨æˆ·: /codex-final_only on
Claude: âœ… Output Format å·²åˆ‡æ¢ä¸º final_only ï¼ˆæ¨èä¿æŒå¼€å¯ä»¥é¿å…é¢å¤–å™ªéŸ³ï¼‰

# 7. æ­£å¸¸å¯¹è¯ï¼ˆè‡ªåŠ¨ä¿æŒä¸Šä¸‹æ–‡ï¼‰
ç”¨æˆ·: /codex-ask è§£é‡Šä¸€ä¸‹Pythonçš„è£…é¥°å™¨
Claude: [Codexçš„å›ç­”] è£…é¥°å™¨æ˜¯Pythonçš„ä¸€ç§è®¾è®¡æ¨¡å¼...

# 8. æŸ¥çœ‹çŠ¶æ€
ç”¨æˆ·: /codex-status
Claude: âœ… CodexæœåŠ¡è¿è¡Œä¸­:
â€¢ å®ä¾‹ID: abc123def
â€¢ å½“å‰Profile: high
â€¢ è¿›ç¨‹PID: 54321
â€¢ Socket: /tmp/codex-12345-abc123def.sock

# 9. ç»§ç»­æé—®ï¼ˆå¯é€‰å¤šè½®ï¼‰
ç”¨æˆ·: /codex-ask ç»™ä¸ªå…·ä½“çš„ä»£ç ä¾‹å­
Claude: [Codexçš„å›ç­”] è¿™æ˜¯ä¸€ä¸ªè£…é¥°å™¨çš„å®ç°ç¤ºä¾‹...

# 10. å¯é€‰åœæ­¢
ç”¨æˆ·: /codex-stop
Claude: âœ… CodexæœåŠ¡å·²åœæ­¢

# 11. Claudeé€€å‡ºæ—¶è‡ªåŠ¨æ¸…ç†ï¼ˆæ— éœ€ç”¨æˆ·æ“ä½œï¼‰
```

### âœ… é€‚ç”¨åœºæ™¯
- **æœ¬æœºå¼€å‘ç¯å¢ƒ**ï¼šå•ä¸ªå¼€å‘è€…ä½¿ç”¨
- **é¡¹ç›®éš”ç¦»**ï¼šä¸åŒé¡¹ç›®çš„Claudeè¿›ç¨‹å®Œå…¨ç‹¬ç«‹
- **ç®€å•å¯é **ï¼šæœ€å°åŒ–å¤æ‚åº¦å’Œæ•…éšœç‚¹
- **èµ„æºæ¸…æ´**ï¼šé€€å‡ºæ—¶å®Œå…¨æ¸…ç†ï¼Œä¸ç•™åƒåœ¾æ–‡ä»¶

*æœ¬æ–¹æ¡ˆå®ç°äº†"ä¸€æ¬¡æ¿€æ´»ï¼ŒæŒç»­ä½¿ç”¨ï¼Œè‡ªåŠ¨æ¸…ç†"çš„ç†æƒ³ç”¨æˆ·ä½“éªŒï¼Œå®Œå…¨è´´åˆæœ¬æœºå°‘å®ä¾‹çš„ä½¿ç”¨åœºæ™¯ã€‚*
