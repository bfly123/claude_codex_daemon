#!/usr/bin/env python3
"""
claude_codex - Claude-Codex 双窗口模式启动器
同时启动Claude和Codex两个窗口，建立单向控制通道
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
import shlex
import re
from pathlib import Path

class ClaudeCodexDual:
    _RESUME_FLAGS = {"-c", "-C", "--resume"}
    _SESSION_ID_PATTERN = re.compile(
        r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}",
        re.IGNORECASE,
    )

    def __init__(
        self,
        resume: bool = False,
        claude_args=None,
        resume_claude: bool = False,
        resume_codex: bool = False,
    ):
        self.resume = resume
        self.resume_claude = resume_claude or resume
        self.resume_codex = resume_codex or resume
        self.claude_args = self._clean_claude_args(claude_args or [])
        self.script_dir = Path(__file__).resolve().parent

        # 会话管理
        self.session_id = f"dual-{int(time.time())}-{os.getpid()}"
        self.runtime_dir = Path("/tmp") / f"codex-{getpass.getuser()}" / self.session_id
        self.runtime_dir.mkdir(parents=True, exist_ok=True)

        # 文件路径
        self.input_fifo = self.runtime_dir / "input.fifo"
        self.output_fifo = self.runtime_dir / "output.fifo"
        self.codex_pid_file = self.runtime_dir / "codex.pid"
        self.claude_pid_file = self.runtime_dir / "claude.pid"
        self.status_file = self.runtime_dir / "status"
        self.lock_file = self.runtime_dir / "lock"
        self.project_session_file = Path.cwd() / ".codex-session"
        self.bridge_pid_file = self.runtime_dir / "bridge.pid"
        self.tmux_session = f"codex-{self.session_id[:8]}"
        self.tmux_log_file = self.runtime_dir / "bridge_output.log"
        self._cleaned = False

        # 进程管理
        self.codex_process = None
        self.terminal_type = None
        self.daemon_socket = self.runtime_dir / "codex-daemon.sock"
        self.daemon_pid_file = self.runtime_dir / "codex-daemon.pid"
        self.client_id = f"codex-dual-{uuid.uuid4().hex[:8]}"

        # 历史会话信息
        self.previous_session = self._load_previous_session()
        self.session_record = dict(self.previous_session) if isinstance(self.previous_session, dict) else {}
        self.codex_start_cmd = self._prepare_codex_start_command()
        self._apply_claude_resume_preferences()
        self._session_record_written = False

    def _clean_claude_args(self, args):
        """移除控制自身恢复行为的标志，避免传给 Claude CLI"""
        cleaned = []
        if not isinstance(args, (list, tuple)):
            args = [args]

        for raw in args:
            if raw is None:
                continue

            if isinstance(raw, (list, tuple)):
                tokens = [str(item) for item in raw]
            else:
                text = str(raw).strip()
                if not text:
                    continue
                tokens = shlex.split(text)

            for token in tokens:
                if token in self._RESUME_FLAGS:
                    continue
                cleaned.append(token)

        return cleaned

    def _load_previous_session(self):
        if not self.project_session_file.exists():
            return {}
        try:
            with open(self.project_session_file, "r", encoding="utf-8") as handle:
                data = json.load(handle)
                if isinstance(data, dict):
                    return data
        except Exception as exc:
            print(f"⚠️ 无法读取历史会话信息: {exc}")
        return {}

    def _prepare_codex_start_command(self) -> str:
        default_cmd = "codex"
        if not self.resume_codex:
            return default_cmd

        data = self.previous_session or {}
        stored_cmd = data.get("codex_start_cmd")
        if isinstance(stored_cmd, str) and stored_cmd.strip():
            print(f"🔁 使用历史 Codex 启动命令: {stored_cmd}")
            return stored_cmd

        session_id = data.get("codex_session_id")
        if isinstance(session_id, str) and session_id.strip():
            resume_cmd = f"codex resume {session_id.strip()}"
            print(f"🔁 根据会话ID恢复 Codex: {resume_cmd}")
            return resume_cmd

        print("⚠️ 未找到可恢复的 Codex 信息，将使用默认命令")
        return default_cmd

    def _apply_claude_resume_preferences(self):
        if not self.resume_claude or self.claude_args:
            return

        data = self.previous_session or {}
        saved_args = data.get("claude_args")
        if isinstance(saved_args, list) and saved_args:
            self.claude_args = self._clean_claude_args(saved_args)
            print(f"🔁 已恢复 Claude 启动参数: {' '.join(self.claude_args)}")
        elif isinstance(saved_args, str) and saved_args.strip():
            self.claude_args = self._clean_claude_args([saved_args.strip()])
            print(f"🔁 已恢复 Claude 启动参数: {saved_args.strip()}")
        else:
            print("⚠️ 未找到 Claude 历史参数，将使用默认命令")

    def _build_claude_command(self):
        """构建 Claude CLI 启动命令"""
        command = ["claude"]
        if self.resume_claude:
            command.append("-c")
        command.extend(self.claude_args)
        return command

    def _write_project_session(self, active: bool):
        record = {}
        latest = self._load_previous_session()
        if isinstance(latest, dict):
            record.update(latest)

        existing_codex_cmd = record.get("codex_start_cmd", "")
        codex_cmd_to_store = self.codex_start_cmd
        if (
            isinstance(existing_codex_cmd, str)
            and existing_codex_cmd.startswith("codex resume ")
            and isinstance(self.codex_start_cmd, str)
            and not self.codex_start_cmd.startswith("codex resume ")
        ):
            codex_cmd_to_store = existing_codex_cmd

        inferred_path, inferred_session = self._infer_codex_log()
        if inferred_path and not record.get("codex_session_path"):
            record["codex_session_path"] = inferred_path
        if inferred_session and not record.get("codex_session_id"):
            record["codex_session_id"] = inferred_session
        if (
            inferred_session
            and isinstance(codex_cmd_to_store, str)
            and not codex_cmd_to_store.startswith("codex resume ")
        ):
            codex_cmd_to_store = f"codex resume {inferred_session}"

        record.update(
            {
                "session_id": self.session_id,
                "runtime_dir": str(self.runtime_dir),
                "input_fifo": str(self.input_fifo),
                "output_fifo": str(self.output_fifo),
                "tmux_session": self.tmux_session,
                "tmux_log": str(self.tmux_log_file),
                "daemon_socket": str(self.daemon_socket),
                "daemon_pid_file": str(self.daemon_pid_file),
                "bridge_pid_file": str(self.bridge_pid_file),
                "bridge_log": str(self.runtime_dir / "bridge.log"),
                "client_id": self.client_id,
                "codex_start_cmd": codex_cmd_to_store,
                "claude_args": self._clean_claude_args(self.claude_args),
                "flags": {
                    "resume": self.resume,
                    "resume_claude": self.resume_claude,
                    "resume_codex": self.resume_codex,
                },
            }
        )

        record["active"] = active
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        if active:
            record["started_at"] = timestamp
            record.pop("ended_at", None)
        else:
            record["ended_at"] = timestamp

        tmp_file = self.project_session_file.with_suffix(".tmp")
        try:
            with open(tmp_file, "w", encoding="utf-8") as handle:
                json.dump(record, handle, ensure_ascii=False, indent=2)
            os.replace(tmp_file, self.project_session_file)
            action = "保存" if active else "更新"
            print(f"✅ 会话信息已{action}: {self.project_session_file}")
            self.session_record = record
            self._session_record_written = True
        except Exception as exc:
            if tmp_file.exists():
                try:
                    tmp_file.unlink()
                except Exception:
                    pass
            prefix = "保存" if active else "更新"
            print(f"⚠️ {prefix}会话信息失败: {exc}")

    def _infer_codex_log(self):
        """尝试根据最新 Codex 日志推断恢复所需的信息"""
        sessions_root = Path.home() / ".codex" / "sessions"
        if not sessions_root.exists():
            return None, None

        try:
            logs = sorted(
                (p for p in sessions_root.glob("**/*.jsonl") if p.is_file()),
                key=lambda path: path.stat().st_mtime,
            )
        except OSError:
            return None, None

        for candidate in reversed(logs):
            session_id = self._extract_session_id(candidate)
            if session_id:
                return str(candidate), session_id

        if logs:
            return str(logs[-1]), None
        return None, None

    def _extract_session_id(self, path: Path):
        """从日志文件推断 Codex session ID"""
        for source in (path.stem, path.name):
            match = self._SESSION_ID_PATTERN.search(source)
            if match:
                return match.group(0)

        try:
            with path.open("r", encoding="utf-8") as handle:
                first_line = handle.readline()
        except OSError:
            return None

        if not first_line:
            return None

        match = self._SESSION_ID_PATTERN.search(first_line)
        if match:
            return match.group(0)
        return None

    def detect_terminal(self):
        """检测可用的终端工具"""
        terminals = [
            "gnome-terminal",
            "konsole",
            "alacritty",
            "xterm",
            "xfce4-terminal"
        ]

        for term in terminals:
            if subprocess.run(["which", term], capture_output=True).returncode == 0:
                print(f"✅ 检测到终端: {term}")
                return term

        print("⚠️ 未检测到图形终端，使用 tmux")
        return "tmux"

    def create_fifos(self):
        """创建FIFO管道"""
        print("🔧 创建通信管道...")

        try:
            # 创建输入管道 (Claude → Codex)
            if not self.input_fifo.exists():
                os.mkfifo(self.input_fifo)
            os.chmod(self.input_fifo, 0o600)  # 只允许所有者读写

            # 创建输出管道 (Codex → Claude 监控)
            if not self.output_fifo.exists():
                os.mkfifo(self.output_fifo)
            os.chmod(self.output_fifo, 0o644)  # 允许所有者读写，其他用户只读

            print(f"✅ 管道创建完成:")
            print(f"   输入: {self.input_fifo}")
            print(f"   输出: {self.output_fifo}")
            return True

        except Exception as e:
            print(f"❌ 创建管道失败: {e}")
            return False

    def start_codex_window(self):
        """启动Codex窗口"""
        print("🚀 启动Codex窗口...")
        print(f"➡️ Codex启动命令: {self.codex_start_cmd}")

        self.terminal_type = self.detect_terminal()

        python_bin = sys.executable
        bridge_script = self.script_dir / "codex_dual_bridge.py"

        # 创建Codex启动脚本
        codex_wrapper_script = f'''
#!/bin/bash
# Codex窗口启动脚本

 SESSION_ID="{self.session_id}"
 RUNTIME_DIR="/tmp/codex-{getpass.getuser()}/$SESSION_ID"
 INPUT_FIFO="$RUNTIME_DIR/input.fifo"
 OUTPUT_FIFO="$RUNTIME_DIR/output.fifo"
 PID_FILE="$RUNTIME_DIR/codex.pid"
 TMUX_SESSION="{self.tmux_session}"
 TMUX_LOG_FILE="$RUNTIME_DIR/bridge_output.log"
 BRIDGE_SCRIPT="{bridge_script}"
 PYTHON_BIN="{python_bin}"
 SCRIPT_DIR="{self.script_dir}"
 SOCKET_PATH="{self.daemon_socket}"
 DAEMON_PID="{self.daemon_pid_file}"
CLIENT_ID="{self.client_id}"
BRIDGE_PID_FILE="$RUNTIME_DIR/bridge.pid"
BRIDGE_LOG="$RUNTIME_DIR/bridge.log"

# 写入PID
echo $$ > "$PID_FILE"

 echo "🤖 Codex会话启动: $SESSION_ID"
 echo "📁 运行目录: $RUNTIME_DIR"
 echo "🔧 输入管道: $INPUT_FIFO"
 echo "🔧 输出管道: $OUTPUT_FIFO"
 echo "🖥️  tmux会话: $TMUX_SESSION"

 # 等待输入管道可用
 while [ ! -p "$INPUT_FIFO" ]; do
     echo "⏳ 等待输入管道..."
     sleep 0.1
done

echo "✅ 管道连接建立"

# 检查桥接脚本和Python环境
if [ ! -f "$BRIDGE_SCRIPT" ]; then
    echo "❌ 找不到桥接脚本: $BRIDGE_SCRIPT"
    sleep 5
    exit 1
fi

if [ ! -x "$PYTHON_BIN" ]; then
    echo "❌ 无法执行Python解释器: $PYTHON_BIN"
    sleep 5
    exit 1
fi

echo "🔧 准备启动Codex桥接器..."
export PYTHONPATH="$SCRIPT_DIR:${{PYTHONPATH:-}}"
export CODEX_SESSION_ID="$SESSION_ID"
export CODEX_RUNTIME_DIR="$RUNTIME_DIR"
export CODEX_DAEMON_SOCKET="$SOCKET_PATH"
 export CODEX_DAEMON_PID="$DAEMON_PID"
 export CODEX_CLIENT_ID="$CLIENT_ID"
 export CODEX_INPUT_FIFO="$INPUT_FIFO"
 export CODEX_OUTPUT_FIFO="$OUTPUT_FIFO"
 export CODEX_TMUX_SESSION="$TMUX_SESSION"
 export CODEX_TMUX_LOG="$TMUX_LOG_FILE"
CODEX_START_CMD={json.dumps(self.codex_start_cmd)}

# 启动或准备tmux会话
if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    tmux new-session -d -s "$TMUX_SESSION" "$CODEX_START_CMD"
    sleep 1
fi
tmux pipe-pane -o -t "$TMUX_SESSION" "cat >> '$TMUX_LOG_FILE'"

# 启动桥接器（后台运行）
"$PYTHON_BIN" "$BRIDGE_SCRIPT" --runtime-dir "$RUNTIME_DIR" --session-id "$SESSION_ID" >>"$BRIDGE_LOG" 2>&1 &
BRIDGE_PID=$!
echo $BRIDGE_PID > "$BRIDGE_PID_FILE"
echo "🪄 桥接器已启动 (PID: $BRIDGE_PID)"
echo "📄 日志输出: $BRIDGE_LOG"

cleanup() {{
    if [ -n "$BRIDGE_PID" ]; then
        kill -TERM "$BRIDGE_PID" 2>/dev/null
        wait "$BRIDGE_PID" 2>/dev/null
    fi
}}
trap cleanup EXIT

# 附加到tmux会话供用户使用
exec tmux attach -t "$TMUX_SESSION"
'''

        try:
            # 将脚本写入临时文件
            script_file = self.runtime_dir / "codex_wrapper.sh"
            with open(script_file, 'w') as f:
                f.write(codex_wrapper_script)
            os.chmod(script_file, 0o755)

            if self.terminal_type == "tmux":
                # 使用tmux创建新会话
                cmd = [
                    "tmux", "new-session", "-d", "-s", f"codex-{self.session_id[:8]}",
                    str(script_file)
                ]
                subprocess.run(cmd, check=True)

                # 附加到tmux会话
                subprocess.run([
                    "tmux", "attach-session", "-t", f"codex-{self.session_id[:8]}"
                ])

            elif self.terminal_type in ["gnome-terminal", "xfce4-terminal"]:
                cmd = [
                    self.terminal_type, "--title", f"Codex ({self.session_id[:8]})",
                    "--", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "konsole":
                cmd = [
                    "konsole", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "alacritty":
                cmd = [
                    "alacritty", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            else:  # xterm 或其他
                cmd = [
                    self.terminal_type, "-title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            print(f"✅ Codex窗口已启动 (PID: {self.codex_process.pid if self.codex_process else 'tmux'})")
            return True

        except Exception as e:
            print(f"❌ 启动Codex窗口失败: {e}")
            return False

    def start_claude_window(self):
        """启动Claude窗口"""
        print("🚀 启动Claude窗口...")

        # 保存会话信息到项目目录
        self._write_project_session(active=True)

        # 设置环境变量
        env = os.environ.copy()
        env["CODEX_SESSION_ID"] = self.session_id
        env["CODEX_RUNTIME_DIR"] = str(self.runtime_dir)
        env["CODEX_INPUT_FIFO"] = str(self.input_fifo)
        env["CODEX_OUTPUT_FIFO"] = str(self.output_fifo)
        env["CODEX_CLIENT_ID"] = self.client_id
        env["CODEX_DAEMON_SOCKET"] = str(self.daemon_socket)
        env["CODEX_DAEMON_PID"] = str(self.daemon_pid_file)
        env["CODEX_TMUX_SESSION"] = self.tmux_session
        env["CODEX_TMUX_LOG"] = str(self.tmux_log_file)

        # 写入Claude PID
        with open(self.claude_pid_file, 'w') as f:
            f.write(str(os.getpid()))

        # 更新状态
        with open(self.status_file, 'w') as f:
            f.write("running")

        print(f"📋 会话ID: {self.session_id}")
        print(f"📁 运行目录: {self.runtime_dir}")
        print("✅ Claude窗口就绪")
        print()
        print("🎯 可用命令:")
        print("   cask <问题>         - 异步发送问题")
        print("   cask-w <问题>       - 同步等待回复")
        print("   cping               - 测试连通性")
        print("   cpend               - 查看最新回复")
        print()

        # 启动Claude Code
        try:
            cmd = self._build_claude_command()
            print(f"执行: {' '.join(cmd)}")

            return subprocess.run(
                cmd,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                env=env
            ).returncode

        except KeyboardInterrupt:
            print("\\n⚠️ 用户中断")
            return 130
        except Exception as e:
            print(f"❌ 启动Claude失败: {e}")
            return 1

    def cleanup(self):
        """清理资源"""
        if self._cleaned:
            return
        self._cleaned = True
        print("\\n🧹 清理会话资源...")

        try:
            # 停止Codex进程
            if self.codex_process and self.codex_process.poll() is None:
                self.codex_process.terminate()
                try:
                    self.codex_process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.codex_process.kill()

            # 停止桥接器
            if self.bridge_pid_file.exists():
                try:
                    bridge_pid = int(self.bridge_pid_file.read_text().strip())
                    os.kill(bridge_pid, signal.SIGTERM)
                except Exception:
                    pass
                try:
                    self.bridge_pid_file.unlink()
                except Exception:
                    pass

            # 如果是tmux会话，杀掉tmux
            if self.terminal_type == "tmux":
                subprocess.run([
                    "tmux", "kill-session", "-t", f"codex-{self.session_id[:8]}"
                ], stderr=subprocess.DEVNULL)
            elif self.terminal_type:
                subprocess.run([
                    "tmux", "kill-session", "-t", self.tmux_session
                ], stderr=subprocess.DEVNULL)

            # 删除运行时目录
            import shutil
            if self.runtime_dir.exists():
                shutil.rmtree(self.runtime_dir)

            if self._session_record_written:
                self._write_project_session(active=False)

            print("✅ 清理完成")

        except Exception as e:
            print(f"⚠️ 清理时出现错误: {e}")

    def run(self):
        """主运行流程"""
        print(f"🚀 Claude-Codex 双窗口模式")
        print(f"📅 启动时间: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"🆔 会话ID: {self.session_id}")
        print("=" * 50)

        # 注册清理函数
        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, lambda s, f: (self.cleanup(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (self.cleanup(), sys.exit(0)))

        # 创建管道
        if not self.create_fifos():
            return 1

        # 启动Codex窗口
        if not self.start_codex_window():
            return 1

        # 等待Codex启动
        time.sleep(2)

        # 启动Claude窗口
        try:
            return self.start_claude_window()
        finally:
            self.cleanup()

def show_help():
    """显示帮助信息"""
    help_text = """
claude_codex - Claude-Codex 双窗口模式启动器

用法:
    claude_codex [OPTIONS] [COMMAND] [ARGS]...

功能:
    🚀 同时启动Claude和Codex两个窗口
    🔗 建立Claude到Codex的单向控制通道
    💾 自动保存会话信息和历史记录
    🔄 支持中断恢复和错误处理

选项:
    -c                    恢复Claude上下文
    -C                    恢复Codex上下文
    --resume              同时恢复Claude和Codex上下文
    --help, -h            显示帮助信息

Claude命令 (在Claude窗口中使用):
    cask <问题>         - 异步发送问题到Codex
    cask-w <问题>       - 同步等待Codex回复
    cping               - 测试连通性
    cpend               - 查看最新回复

示例:
    claude_codex                  # 启动双窗口模式
    claude_codex -c               # 恢复Claude上下文
    claude_codex -C               # 恢复Codex上下文
    claude_codex /path/to/project # 在项目目录启动
"""
    print(help_text)

def handle_single_command(command, *args):
    """处理单命令模式"""
    try:
        # 导入通信模块
        from codex_comm import CodexCommunicator
        comm = CodexCommunicator()

        if command == 'ask':
            if not args:
                print("❌ 请提供问题内容")
                return 1
            question = ' '.join(args)
            wait_mode = '--wait' in args or '-w' in args
            if wait_mode:
                # 移除等待参数
                clean_args = [arg for arg in args if arg not in ['--wait', '-w']]
                question = ' '.join(clean_args)
                comm.ask_sync(question)
            else:
                comm.ask_async(question)
            return 0

        elif command == 'ping':
            healthy, message = comm.ping(display=False)
            print(message)
            return 0 if healthy else 1

        elif command == 'status':
            status = comm.get_status()
            print(status)
            return 0

        elif command == 'pending':
            result = comm.get_pending()
            if result:
                print(result)
            else:
                print("📭 没有待处理的回复")
            return 0

        else:
            print(f"❌ 未知命令: {command}")
            return 1

    except ImportError:
        print("❌ 找不到 codex_comm 模块")
        return 1
    except Exception as e:
        print(f"❌ 命令执行失败: {e}")
        return 1

def main():
    import sys

    # 首先检查是否有来自标准输入的命令（管道输入）
    if not sys.stdin.isatty():
        # 有管道输入，读取第一行作为命令
        try:
            input_line = sys.stdin.readline().strip()
            if input_line:
                # 解析输入的命令
                parts = input_line.split()
                command = parts[0].lstrip('/')  # 移除可能的斜杠前缀
                args = parts[1:] if len(parts) > 1 else []

                if command in ['ask', 'ping', 'status', 'pending', 'cask', 'cping', 'cstatus', 'cpend']:
                    # 映射命令别名
                    cmd_mapping = {
                        'cask': 'ask',
                        'cping': 'ping',
                        'cstatus': 'status',
                        'cpend': 'pending'
                    }
                    actual_command = cmd_mapping.get(command, command)
                    return handle_single_command(actual_command, *args)
        except Exception as e:
            print(f"❌ 处理管道输入失败: {e}")
            return 1

    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--resume', action='store_true', help='恢复上次的会话')
    parser.add_argument('-c', dest='resume_claude', action='store_true', help='恢复Claude上下文')
    parser.add_argument('-C', dest='resume_codex', action='store_true', help='恢复Codex上下文')
    parser.add_argument('--help', '-h', action='store_true', help='显示帮助')

    # 解析已知参数，其余传给claude
    args, remaining_args = parser.parse_known_args()

    # 检查是否为单命令模式
    if remaining_args:
        command = remaining_args[0]
        if command in ['ask', 'ping', 'status', 'pending']:
            return handle_single_command(command, *remaining_args[1:])

    if args.help:
        show_help()
        return 0

    dual = ClaudeCodexDual(
        resume=args.resume,
        claude_args=remaining_args,
        resume_claude=args.resume_claude,
        resume_codex=args.resume_codex,
    )
    return dual.run()

if __name__ == "__main__":
    sys.exit(main())
