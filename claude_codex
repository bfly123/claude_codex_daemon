#!/usr/bin/env python3
"""
claude_codex - Claude-Codex åŒçª—å£æ¨¡å¼å¯åŠ¨å™¨
åŒæ—¶å¯åŠ¨Claudeå’ŒCodexä¸¤ä¸ªçª—å£ï¼Œå»ºç«‹å•å‘æ§åˆ¶é€šé“
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
import shlex
import re
import platform
from pathlib import Path


def is_wsl() -> bool:
    try:
        return "microsoft" in Path("/proc/version").read_text().lower()
    except Exception:
        return False


def get_wsl_version() -> int:
    if os.environ.get("WSL_INTEROP"):
        return 2
    return 1

class ClaudeCodexDual:
    _RESUME_FLAGS = {"-c", "-C", "--resume"}
    _SESSION_ID_PATTERN = re.compile(
        r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}",
        re.IGNORECASE,
    )

    def __init__(
        self,
        resume: bool = False,
        claude_args=None,
        resume_claude: bool = False,
        resume_codex: bool = False,
    ):
        self.resume = resume
        self.resume_claude = resume_claude or resume
        self.resume_codex = resume_codex or resume
        self.claude_args = self._clean_claude_args(claude_args or [])
        self.script_dir = Path(__file__).resolve().parent

        # ä¼šè¯ç®¡ç†
        self.session_id = f"dual-{int(time.time())}-{os.getpid()}"

        # æ ¹æ®æ“ä½œç³»ç»Ÿé€‰æ‹©ä¸´æ—¶ç›®å½•
        if platform.system() == "Darwin":  # macOS
            temp_base = Path("/tmp")
        else:  # Linux
            temp_base = Path("/tmp")

        self.runtime_dir = temp_base / f"codex-{getpass.getuser()}" / self.session_id
        self.runtime_dir.mkdir(parents=True, exist_ok=True)

        # æ–‡ä»¶è·¯å¾„
        self.input_fifo = self.runtime_dir / "input.fifo"
        self.output_fifo = self.runtime_dir / "output.fifo"
        self.codex_pid_file = self.runtime_dir / "codex.pid"
        self.claude_pid_file = self.runtime_dir / "claude.pid"
        self.status_file = self.runtime_dir / "status"
        self.lock_file = self.runtime_dir / "lock"
        self.project_session_file = Path.cwd() / ".codex-session"
        self.bridge_pid_file = self.runtime_dir / "bridge.pid"
        self.tmux_session = f"codex-{self.session_id[:8]}"
        self.tmux_log_file = self.runtime_dir / "bridge_output.log"
        self._cleaned = False

        # è¿›ç¨‹ç®¡ç†
        self.codex_process = None
        self.terminal_type = None
        self.daemon_socket = self.runtime_dir / "codex-daemon.sock"
        self.daemon_pid_file = self.runtime_dir / "codex-daemon.pid"
        self.client_id = f"codex-dual-{uuid.uuid4().hex[:8]}"
        self._log_mtime_cutoff = None if self.resume_codex else time.time()

        # å†å²ä¼šè¯ä¿¡æ¯
        self.previous_session = self._load_previous_session()
        self.session_record = dict(self.previous_session) if isinstance(self.previous_session, dict) else {}
        self.codex_start_cmd = self._prepare_codex_start_command()
        self._apply_claude_resume_preferences()
        self._session_record_written = False

    def _clean_claude_args(self, args):
        """ç§»é™¤æ§åˆ¶è‡ªèº«æ¢å¤è¡Œä¸ºçš„æ ‡å¿—ï¼Œé¿å…ä¼ ç»™ Claude CLI"""
        cleaned = []
        if not isinstance(args, (list, tuple)):
            args = [args]

        for raw in args:
            if raw is None:
                continue

            if isinstance(raw, (list, tuple)):
                tokens = [str(item) for item in raw]
            else:
                text = str(raw).strip()
                if not text:
                    continue
                tokens = shlex.split(text)

            for token in tokens:
                if token in self._RESUME_FLAGS:
                    continue
                cleaned.append(token)

        return cleaned

    def _load_previous_session(self):
        if not self.project_session_file.exists():
            return {}
        try:
            with open(self.project_session_file, "r", encoding="utf-8") as handle:
                data = json.load(handle)
                if isinstance(data, dict):
                    return data
        except Exception as exc:
            print(f"âš ï¸ æ— æ³•è¯»å–å†å²ä¼šè¯ä¿¡æ¯: {exc}")
        return {}

    def _prepare_codex_start_command(self) -> str:
        default_cmd = "codex"
        if not self.resume_codex:
            return default_cmd

        data = self.previous_session or {}
        stored_cmd = data.get("codex_start_cmd")
        if isinstance(stored_cmd, str) and stored_cmd.strip():
            print(f"ğŸ” ä½¿ç”¨å†å² Codex å¯åŠ¨å‘½ä»¤: {stored_cmd}")
            return stored_cmd

        session_id = data.get("codex_session_id")
        if isinstance(session_id, str) and session_id.strip():
            resume_cmd = f"codex resume {session_id.strip()}"
            print(f"ğŸ” æ ¹æ®ä¼šè¯IDæ¢å¤ Codex: {resume_cmd}")
            return resume_cmd

        print("âš ï¸ æœªæ‰¾åˆ°å¯æ¢å¤çš„ Codex ä¿¡æ¯ï¼Œå°†ä½¿ç”¨é»˜è®¤å‘½ä»¤")
        return default_cmd

    def _apply_claude_resume_preferences(self):
        if not self.resume_claude or self.claude_args:
            return

        data = self.previous_session or {}
        saved_args = data.get("claude_args")
        if isinstance(saved_args, list) and saved_args:
            self.claude_args = self._clean_claude_args(saved_args)
            print(f"ğŸ” å·²æ¢å¤ Claude å¯åŠ¨å‚æ•°: {' '.join(self.claude_args)}")
        elif isinstance(saved_args, str) and saved_args.strip():
            self.claude_args = self._clean_claude_args([saved_args.strip()])
            print(f"ğŸ” å·²æ¢å¤ Claude å¯åŠ¨å‚æ•°: {saved_args.strip()}")
        else:
            print("âš ï¸ æœªæ‰¾åˆ° Claude å†å²å‚æ•°ï¼Œå°†ä½¿ç”¨é»˜è®¤å‘½ä»¤")

    def _build_claude_command(self):
        """æ„å»º Claude CLI å¯åŠ¨å‘½ä»¤"""
        command = ["claude"]
        if self.resume_claude:
            command.append("-c")
        command.extend(self.claude_args)
        return command

    def _write_project_session(self, active: bool):
        record = {}
        latest = self._load_previous_session()
        if isinstance(latest, dict):
            record.update(latest)

        inferred_path, inferred_session = self._infer_codex_log()
        existing_path = record.get("codex_session_path")
        if inferred_path and inferred_path != existing_path:
            record["codex_session_path"] = inferred_path

        existing_session = record.get("codex_session_id")
        if inferred_session and inferred_session != existing_session:
            record["codex_session_id"] = inferred_session

        if isinstance(self.codex_start_cmd, str) and self.codex_start_cmd.startswith("codex resume "):
            codex_cmd_to_store = self.codex_start_cmd
        elif inferred_session:
            codex_cmd_to_store = f"codex resume {inferred_session}"
        else:
            codex_cmd_to_store = self.codex_start_cmd

        record.update(
            {
                "session_id": self.session_id,
                "runtime_dir": str(self.runtime_dir),
                "input_fifo": str(self.input_fifo),
                "output_fifo": str(self.output_fifo),
                "tmux_session": self.tmux_session,
                "tmux_log": str(self.tmux_log_file),
                "daemon_socket": str(self.daemon_socket),
                "daemon_pid_file": str(self.daemon_pid_file),
                "bridge_pid_file": str(self.bridge_pid_file),
                "bridge_log": str(self.runtime_dir / "bridge.log"),
                "client_id": self.client_id,
                "codex_start_cmd": codex_cmd_to_store,
                "claude_args": self._clean_claude_args(self.claude_args),
                "flags": {
                    "resume": self.resume,
                    "resume_claude": self.resume_claude,
                    "resume_codex": self.resume_codex,
                },
            }
        )

        record["active"] = active
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        if active:
            record["started_at"] = timestamp
            record.pop("ended_at", None)
        else:
            record["ended_at"] = timestamp

        tmp_file = self.project_session_file.with_suffix(".tmp")
        try:
            with open(tmp_file, "w", encoding="utf-8") as handle:
                json.dump(record, handle, ensure_ascii=False, indent=2)
            os.replace(tmp_file, self.project_session_file)
            action = "ä¿å­˜" if active else "æ›´æ–°"
            print(f"âœ… ä¼šè¯ä¿¡æ¯å·²{action}: {self.project_session_file}")
            self.session_record = record
            self._session_record_written = True
        except Exception as exc:
            if tmp_file.exists():
                try:
                    tmp_file.unlink()
                except Exception:
                    pass
            prefix = "ä¿å­˜" if active else "æ›´æ–°"
            print(f"âš ï¸ {prefix}ä¼šè¯ä¿¡æ¯å¤±è´¥: {exc}")

    def _infer_codex_log(self):
        """å°è¯•æ ¹æ®æœ€æ–° Codex æ—¥å¿—æ¨æ–­æ¢å¤æ‰€éœ€çš„ä¿¡æ¯"""
        sessions_root = Path.home() / ".codex" / "sessions"
        if not sessions_root.exists():
            return None, None

        try:
            logs = sorted(
                (p for p in sessions_root.glob("**/*.jsonl") if p.is_file()),
                key=lambda path: path.stat().st_mtime,
            )
        except OSError:
            return None, None

        cutoff = self._log_mtime_cutoff
        for candidate in reversed(logs):
            try:
                mtime = candidate.stat().st_mtime
            except OSError:
                continue
            if cutoff and mtime < cutoff:
                continue
            session_id = self._extract_session_id(candidate)
            if session_id:
                return str(candidate), session_id

        if logs and cutoff is None:
            return str(logs[-1]), None
        return None, None

    def _extract_session_id(self, path: Path):
        """ä»æ—¥å¿—æ–‡ä»¶æ¨æ–­ Codex session ID"""
        for source in (path.stem, path.name):
            match = self._SESSION_ID_PATTERN.search(source)
            if match:
                return match.group(0)

        try:
            with path.open("r", encoding="utf-8") as handle:
                first_line = handle.readline()
        except OSError:
            return None

        if not first_line:
            return None

        match = self._SESSION_ID_PATTERN.search(first_line)
        if match:
            return match.group(0)
        return None

    def detect_terminal(self):
        """æ£€æµ‹å¯ç”¨çš„ç»ˆç«¯å·¥å…·"""
        if is_wsl():
            print("âœ… WSL ç¯å¢ƒï¼Œä½¿ç”¨ tmux")
            return "tmux"

        if platform.system() == "Darwin":  # macOS
            # æ£€æŸ¥macOSåŸç”Ÿç»ˆç«¯åº”ç”¨
            if self._check_macos_app("Terminal"):
                print("âœ… æ£€æµ‹åˆ°ç»ˆç«¯: Terminal.app")
                return "Terminal.app"
            elif self._check_macos_app("iTerm"):
                print("âœ… æ£€æµ‹åˆ°ç»ˆç«¯: iTerm.app")
                return "iTerm.app"

            # æ£€æŸ¥é€šè¿‡Homebrewç­‰å®‰è£…çš„ç»ˆç«¯
            terminals = ["alacritty", "xterm"]
            for term in terminals:
                if subprocess.run(["which", term], capture_output=True).returncode == 0:
                    print(f"âœ… æ£€æµ‹åˆ°ç»ˆç«¯: {term}")
                    return term
        else:  # Linux
            terminals = [
                "gnome-terminal",
                "konsole",
                "alacritty",
                "xterm",
                "xfce4-terminal"
            ]
            for term in terminals:
                if subprocess.run(["which", term], capture_output=True).returncode == 0:
                    print(f"âœ… æ£€æµ‹åˆ°ç»ˆç«¯: {term}")
                    return term

        print("âš ï¸ æœªæ£€æµ‹åˆ°å›¾å½¢ç»ˆç«¯ï¼Œä½¿ç”¨ tmux")
        return "tmux"

    def _check_macos_app(self, app_name):
        """æ£€æŸ¥macOSåº”ç”¨æ˜¯å¦å­˜åœ¨"""
        try:
            result = subprocess.run([
                "osascript", "-e", f'exists application "{app_name}"'
            ], capture_output=True, text=True)
            return result.stdout.strip().lower() == "true"
        except Exception:
            return False

    def create_fifos(self):
        """åˆ›å»ºFIFOç®¡é“"""
        if is_wsl() and get_wsl_version() == 1:
            print("âŒ WSL 1 ä¸æ”¯æŒ FIFO ç®¡é“ï¼Œè¯·å‡çº§åˆ° WSL 2")
            print("   è¿è¡Œ: wsl --set-version <distro> 2")
            return False

        print("ğŸ”§ åˆ›å»ºé€šä¿¡ç®¡é“...")

        try:
            # åˆ›å»ºè¾“å…¥ç®¡é“ (Claude â†’ Codex)
            if not self.input_fifo.exists():
                os.mkfifo(self.input_fifo)
            os.chmod(self.input_fifo, 0o600)  # åªå…è®¸æ‰€æœ‰è€…è¯»å†™

            # åˆ›å»ºè¾“å‡ºç®¡é“ (Codex â†’ Claude ç›‘æ§)
            if not self.output_fifo.exists():
                os.mkfifo(self.output_fifo)
            os.chmod(self.output_fifo, 0o644)  # å…è®¸æ‰€æœ‰è€…è¯»å†™ï¼Œå…¶ä»–ç”¨æˆ·åªè¯»

            print(f"âœ… ç®¡é“åˆ›å»ºå®Œæˆ:")
            print(f"   è¾“å…¥: {self.input_fifo}")
            print(f"   è¾“å‡º: {self.output_fifo}")
            return True

        except Exception as e:
            print(f"âŒ åˆ›å»ºç®¡é“å¤±è´¥: {e}")
            return False

    def start_codex_window(self):
        """å¯åŠ¨Codexçª—å£"""
        print("ğŸš€ å¯åŠ¨Codexçª—å£...")
        print(f"â¡ï¸ Codexå¯åŠ¨å‘½ä»¤: {self.codex_start_cmd}")

        self.terminal_type = self.detect_terminal()

        python_bin = sys.executable
        bridge_script = self.script_dir / "codex_dual_bridge.py"

        # åˆ›å»ºCodexå¯åŠ¨è„šæœ¬
        codex_wrapper_script = f'''
#!/bin/bash
# Codexçª—å£å¯åŠ¨è„šæœ¬

 SESSION_ID="{self.session_id}"
 RUNTIME_DIR="/tmp/codex-{getpass.getuser()}/$SESSION_ID"
 INPUT_FIFO="$RUNTIME_DIR/input.fifo"
 OUTPUT_FIFO="$RUNTIME_DIR/output.fifo"
 PID_FILE="$RUNTIME_DIR/codex.pid"
 TMUX_SESSION="{self.tmux_session}"
 TMUX_LOG_FILE="$RUNTIME_DIR/bridge_output.log"
 BRIDGE_SCRIPT="{bridge_script}"
 PYTHON_BIN="{python_bin}"
 SCRIPT_DIR="{self.script_dir}"
 SOCKET_PATH="{self.daemon_socket}"
 DAEMON_PID="{self.daemon_pid_file}"
CLIENT_ID="{self.client_id}"
BRIDGE_PID_FILE="$RUNTIME_DIR/bridge.pid"
BRIDGE_LOG="$RUNTIME_DIR/bridge.log"

# å†™å…¥PID
echo $$ > "$PID_FILE"

 echo "ğŸ¤– Codexä¼šè¯å¯åŠ¨: $SESSION_ID"
 echo "ğŸ“ è¿è¡Œç›®å½•: $RUNTIME_DIR"
 echo "ğŸ”§ è¾“å…¥ç®¡é“: $INPUT_FIFO"
 echo "ğŸ”§ è¾“å‡ºç®¡é“: $OUTPUT_FIFO"
 echo "ğŸ–¥ï¸  tmuxä¼šè¯: $TMUX_SESSION"

 # ç­‰å¾…è¾“å…¥ç®¡é“å¯ç”¨
 while [ ! -p "$INPUT_FIFO" ]; do
     echo "â³ ç­‰å¾…è¾“å…¥ç®¡é“..."
     sleep 0.1
done

echo "âœ… ç®¡é“è¿æ¥å»ºç«‹"

# æ£€æŸ¥æ¡¥æ¥è„šæœ¬å’ŒPythonç¯å¢ƒ
if [ ! -f "$BRIDGE_SCRIPT" ]; then
    echo "âŒ æ‰¾ä¸åˆ°æ¡¥æ¥è„šæœ¬: $BRIDGE_SCRIPT"
    sleep 5
    exit 1
fi

if [ ! -x "$PYTHON_BIN" ]; then
    echo "âŒ æ— æ³•æ‰§è¡ŒPythonè§£é‡Šå™¨: $PYTHON_BIN"
    sleep 5
    exit 1
fi

echo "ğŸ”§ å‡†å¤‡å¯åŠ¨Codexæ¡¥æ¥å™¨..."
export PYTHONPATH="$SCRIPT_DIR:${{PYTHONPATH:-}}"
export CODEX_SESSION_ID="$SESSION_ID"
export CODEX_RUNTIME_DIR="$RUNTIME_DIR"
export CODEX_DAEMON_SOCKET="$SOCKET_PATH"
 export CODEX_DAEMON_PID="$DAEMON_PID"
 export CODEX_CLIENT_ID="$CLIENT_ID"
 export CODEX_INPUT_FIFO="$INPUT_FIFO"
 export CODEX_OUTPUT_FIFO="$OUTPUT_FIFO"
 export CODEX_TMUX_SESSION="$TMUX_SESSION"
 export CODEX_TMUX_LOG="$TMUX_LOG_FILE"
CODEX_START_CMD={json.dumps(self.codex_start_cmd)}

# å¯åŠ¨æˆ–å‡†å¤‡tmuxä¼šè¯
if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    # åˆ‡æ¢åˆ°å½“å‰å·¥ä½œç›®å½•å¹¶å¯åŠ¨ codex
    cd "$(pwd)"
    tmux new-session -d -s "$TMUX_SESSION" "$CODEX_START_CMD"
    sleep 1
fi
tmux pipe-pane -o -t "$TMUX_SESSION" "cat >> '$TMUX_LOG_FILE'"

# å¯åŠ¨æ¡¥æ¥å™¨ï¼ˆåå°è¿è¡Œï¼‰
"$PYTHON_BIN" "$BRIDGE_SCRIPT" --runtime-dir "$RUNTIME_DIR" --session-id "$SESSION_ID" >>"$BRIDGE_LOG" 2>&1 &
BRIDGE_PID=$!
echo $BRIDGE_PID > "$BRIDGE_PID_FILE"
echo "ğŸª„ æ¡¥æ¥å™¨å·²å¯åŠ¨ (PID: $BRIDGE_PID)"
echo "ğŸ“„ æ—¥å¿—è¾“å‡º: $BRIDGE_LOG"

cleanup() {{
    if [ -n "$BRIDGE_PID" ]; then
        kill -TERM "$BRIDGE_PID" 2>/dev/null
        wait "$BRIDGE_PID" 2>/dev/null
    fi
}}
trap cleanup EXIT

# é™„åŠ åˆ°tmuxä¼šè¯ä¾›ç”¨æˆ·ä½¿ç”¨
exec tmux attach -t "$TMUX_SESSION"
'''

        try:
            # å°†è„šæœ¬å†™å…¥ä¸´æ—¶æ–‡ä»¶
            script_file = self.runtime_dir / "codex_wrapper.sh"
            with open(script_file, 'w') as f:
                f.write(codex_wrapper_script)
            os.chmod(script_file, 0o755)

            if self.terminal_type == "tmux":
                # ä½¿ç”¨tmuxåˆ›å»ºæ–°ä¼šè¯
                cmd = [
                    "tmux", "new-session", "-d", "-s", f"codex-{self.session_id[:8]}",
                    str(script_file)
                ]
                subprocess.run(cmd, check=True)

                # é™„åŠ åˆ°tmuxä¼šè¯
                subprocess.run([
                    "tmux", "attach-session", "-t", f"codex-{self.session_id[:8]}"
                ])

            elif self.terminal_type == "Terminal.app" and platform.system() == "Darwin":
                # macOS Terminal.app
                cmd = [
                    "osascript", "-e",
                    f'tell application "Terminal" to do script "exec {str(script_file)}"'
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "iTerm.app" and platform.system() == "Darwin":
                # macOS iTerm2
                cmd = [
                    "osascript", "-e",
                    f'tell application "iTerm" to create window with default profile command "{str(script_file)}"'
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type in ["gnome-terminal", "xfce4-terminal"]:
                cmd = [
                    self.terminal_type, "--title", f"Codex ({self.session_id[:8]})",
                    "--", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "konsole":
                cmd = [
                    "konsole", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "alacritty":
                cmd = [
                    "alacritty", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            else:  # xterm æˆ–å…¶ä»–
                cmd = [
                    self.terminal_type, "-title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            print(f"âœ… Codexçª—å£å·²å¯åŠ¨ (PID: {self.codex_process.pid if self.codex_process else 'tmux'})")
            return True

        except Exception as e:
            print(f"âŒ å¯åŠ¨Codexçª—å£å¤±è´¥: {e}")
            return False

    def start_claude_window(self):
        """å¯åŠ¨Claudeçª—å£"""
        print("ğŸš€ å¯åŠ¨Claudeçª—å£...")

        # ä¿å­˜ä¼šè¯ä¿¡æ¯åˆ°é¡¹ç›®ç›®å½•
        self._write_project_session(active=True)

        # è®¾ç½®ç¯å¢ƒå˜é‡
        env = os.environ.copy()
        env["CODEX_SESSION_ID"] = self.session_id
        env["CODEX_RUNTIME_DIR"] = str(self.runtime_dir)
        env["CODEX_INPUT_FIFO"] = str(self.input_fifo)
        env["CODEX_OUTPUT_FIFO"] = str(self.output_fifo)
        env["CODEX_CLIENT_ID"] = self.client_id
        env["CODEX_DAEMON_SOCKET"] = str(self.daemon_socket)
        env["CODEX_DAEMON_PID"] = str(self.daemon_pid_file)
        env["CODEX_TMUX_SESSION"] = self.tmux_session
        env["CODEX_TMUX_LOG"] = str(self.tmux_log_file)

        # å†™å…¥Claude PID
        with open(self.claude_pid_file, 'w') as f:
            f.write(str(os.getpid()))

        # æ›´æ–°çŠ¶æ€
        with open(self.status_file, 'w') as f:
            f.write("running")

        print(f"ğŸ“‹ ä¼šè¯ID: {self.session_id}")
        print(f"ğŸ“ è¿è¡Œç›®å½•: {self.runtime_dir}")
        print("âœ… Claudeçª—å£å°±ç»ª")
        print()
        print("ğŸ¯ å¯ç”¨å‘½ä»¤:")
        print("   cask <é—®é¢˜>         - å¼‚æ­¥å‘é€é—®é¢˜")
        print("   cask-w <é—®é¢˜>       - åŒæ­¥ç­‰å¾…å›å¤")
        print("   cping               - æµ‹è¯•è¿é€šæ€§")
        print("   cpend               - æŸ¥çœ‹æœ€æ–°å›å¤")
        print()

        # å¯åŠ¨Claude Code
        try:
            cmd = self._build_claude_command()
            print(f"æ‰§è¡Œ: {' '.join(cmd)}")

            return subprocess.run(
                cmd,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                env=env
            ).returncode

        except KeyboardInterrupt:
            print("\\nâš ï¸ ç”¨æˆ·ä¸­æ–­")
            return 130
        except Exception as e:
            print(f"âŒ å¯åŠ¨Claudeå¤±è´¥: {e}")
            return 1

    def cleanup(self):
        """æ¸…ç†èµ„æº"""
        if self._cleaned:
            return
        self._cleaned = True
        print("\\nğŸ§¹ æ¸…ç†ä¼šè¯èµ„æº...")

        try:
            # åœæ­¢Codexè¿›ç¨‹
            if self.codex_process and self.codex_process.poll() is None:
                self.codex_process.terminate()
                try:
                    self.codex_process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.codex_process.kill()

            # åœæ­¢æ¡¥æ¥å™¨
            if self.bridge_pid_file.exists():
                try:
                    bridge_pid = int(self.bridge_pid_file.read_text().strip())
                    os.kill(bridge_pid, signal.SIGTERM)
                except Exception:
                    pass
                try:
                    self.bridge_pid_file.unlink()
                except Exception:
                    pass

            # å¦‚æœæ˜¯tmuxä¼šè¯ï¼Œæ€æ‰tmux
            if self.terminal_type == "tmux":
                subprocess.run([
                    "tmux", "kill-session", "-t", f"codex-{self.session_id[:8]}"
                ], stderr=subprocess.DEVNULL)
            elif self.terminal_type:
                subprocess.run([
                    "tmux", "kill-session", "-t", self.tmux_session
                ], stderr=subprocess.DEVNULL)

            # åˆ é™¤è¿è¡Œæ—¶ç›®å½•
            import shutil
            if self.runtime_dir.exists():
                shutil.rmtree(self.runtime_dir)

            if self._session_record_written:
                self._write_project_session(active=False)

            print("âœ… æ¸…ç†å®Œæˆ")

        except Exception as e:
            print(f"âš ï¸ æ¸…ç†æ—¶å‡ºç°é”™è¯¯: {e}")

    def run(self):
        """ä¸»è¿è¡Œæµç¨‹"""
        print(f"ğŸš€ Claude-Codex åŒçª—å£æ¨¡å¼")
        print(f"ğŸ“… å¯åŠ¨æ—¶é—´: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"ğŸ†” ä¼šè¯ID: {self.session_id}")
        print("=" * 50)

        # æ³¨å†Œæ¸…ç†å‡½æ•°
        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, lambda s, f: (self.cleanup(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (self.cleanup(), sys.exit(0)))

        # åˆ›å»ºç®¡é“
        if not self.create_fifos():
            return 1

        # å¯åŠ¨Codexçª—å£
        if not self.start_codex_window():
            return 1

        # ç­‰å¾…Codexå¯åŠ¨
        time.sleep(2)

        # å¯åŠ¨Claudeçª—å£
        try:
            return self.start_claude_window()
        finally:
            self.cleanup()

def show_help():
    """æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"""
    help_text = """
claude_codex - Claude-Codex åŒçª—å£æ¨¡å¼å¯åŠ¨å™¨

ç”¨æ³•:
    claude_codex [OPTIONS] [COMMAND] [ARGS]...

åŠŸèƒ½:
    ğŸš€ åŒæ—¶å¯åŠ¨Claudeå’ŒCodexä¸¤ä¸ªçª—å£
    ğŸ”— å»ºç«‹Claudeåˆ°Codexçš„å•å‘æ§åˆ¶é€šé“
    ğŸ’¾ è‡ªåŠ¨ä¿å­˜ä¼šè¯ä¿¡æ¯å’Œå†å²è®°å½•
    ğŸ”„ æ”¯æŒä¸­æ–­æ¢å¤å’Œé”™è¯¯å¤„ç†

é€‰é¡¹:
    -c                    æ¢å¤Claudeä¸Šä¸‹æ–‡
    -C                    æ¢å¤Codexä¸Šä¸‹æ–‡
    --resume              åŒæ—¶æ¢å¤Claudeå’ŒCodexä¸Šä¸‹æ–‡
    --help, -h            æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯

Claudeå‘½ä»¤ (åœ¨Claudeçª—å£ä¸­ä½¿ç”¨):
    cask <é—®é¢˜>         - å¼‚æ­¥å‘é€é—®é¢˜åˆ°Codex
    cask-w <é—®é¢˜>       - åŒæ­¥ç­‰å¾…Codexå›å¤
    cping               - æµ‹è¯•è¿é€šæ€§
    cpend               - æŸ¥çœ‹æœ€æ–°å›å¤

ç¤ºä¾‹:
    claude_codex                  # å¯åŠ¨åŒçª—å£æ¨¡å¼
    claude_codex -c               # æ¢å¤Claudeä¸Šä¸‹æ–‡
    claude_codex -C               # æ¢å¤Codexä¸Šä¸‹æ–‡
    claude_codex /path/to/project # åœ¨é¡¹ç›®ç›®å½•å¯åŠ¨
"""
    print(help_text)

def handle_single_command(command, *args):
    """å¤„ç†å•å‘½ä»¤æ¨¡å¼"""
    try:
        # å¯¼å…¥é€šä¿¡æ¨¡å—
        from codex_comm import CodexCommunicator
        comm = CodexCommunicator()

        if command == 'ask':
            if not args:
                print("âŒ è¯·æä¾›é—®é¢˜å†…å®¹")
                return 1
            question = ' '.join(args)
            wait_mode = '--wait' in args or '-w' in args
            if wait_mode:
                # ç§»é™¤ç­‰å¾…å‚æ•°
                clean_args = [arg for arg in args if arg not in ['--wait', '-w']]
                question = ' '.join(clean_args)
                comm.ask_sync(question)
            else:
                comm.ask_async(question)
            return 0

        elif command == 'ping':
            healthy, message = comm.ping(display=False)
            print(message)
            return 0 if healthy else 1

        elif command == 'status':
            status = comm.get_status()
            print(status)
            return 0

        elif command == 'pending':
            result = comm.get_pending()
            if result:
                print(result)
            else:
                print("ğŸ“­ æ²¡æœ‰å¾…å¤„ç†çš„å›å¤")
            return 0

        else:
            print(f"âŒ æœªçŸ¥å‘½ä»¤: {command}")
            return 1

    except ImportError:
        print("âŒ æ‰¾ä¸åˆ° codex_comm æ¨¡å—")
        return 1
    except Exception as e:
        print(f"âŒ å‘½ä»¤æ‰§è¡Œå¤±è´¥: {e}")
        return 1

def main():
    import sys

    # é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰æ¥è‡ªæ ‡å‡†è¾“å…¥çš„å‘½ä»¤ï¼ˆç®¡é“è¾“å…¥ï¼‰
    if not sys.stdin.isatty():
        # æœ‰ç®¡é“è¾“å…¥ï¼Œè¯»å–ç¬¬ä¸€è¡Œä½œä¸ºå‘½ä»¤
        try:
            input_line = sys.stdin.readline().strip()
            if input_line:
                # è§£æè¾“å…¥çš„å‘½ä»¤
                parts = input_line.split()
                command = parts[0].lstrip('/')  # ç§»é™¤å¯èƒ½çš„æ–œæ å‰ç¼€
                args = parts[1:] if len(parts) > 1 else []

                if command in ['ask', 'ping', 'status', 'pending', 'cask', 'cping', 'cstatus', 'cpend']:
                    # æ˜ å°„å‘½ä»¤åˆ«å
                    cmd_mapping = {
                        'cask': 'ask',
                        'cping': 'ping',
                        'cstatus': 'status',
                        'cpend': 'pending'
                    }
                    actual_command = cmd_mapping.get(command, command)
                    return handle_single_command(actual_command, *args)
        except Exception as e:
            print(f"âŒ å¤„ç†ç®¡é“è¾“å…¥å¤±è´¥: {e}")
            return 1

    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--resume', action='store_true', help='æ¢å¤ä¸Šæ¬¡çš„ä¼šè¯')
    parser.add_argument('-c', dest='resume_claude', action='store_true', help='æ¢å¤Claudeä¸Šä¸‹æ–‡')
    parser.add_argument('-C', dest='resume_codex', action='store_true', help='æ¢å¤Codexä¸Šä¸‹æ–‡')
    parser.add_argument('--help', '-h', action='store_true', help='æ˜¾ç¤ºå¸®åŠ©')

    # è§£æå·²çŸ¥å‚æ•°ï¼Œå…¶ä½™ä¼ ç»™claude
    args, remaining_args = parser.parse_known_args()

    # æ£€æŸ¥æ˜¯å¦ä¸ºå•å‘½ä»¤æ¨¡å¼
    if remaining_args:
        command = remaining_args[0]
        if command in ['ask', 'ping', 'status', 'pending']:
            return handle_single_command(command, *remaining_args[1:])

    if args.help:
        show_help()
        return 0

    dual = ClaudeCodexDual(
        resume=args.resume,
        claude_args=remaining_args,
        resume_claude=args.resume_claude,
        resume_codex=args.resume_codex,
    )
    return dual.run()

if __name__ == "__main__":
    sys.exit(main())
