#!/usr/bin/env python3
"""
claude_codex - Claude-Codex åŒçª—å£æ¨¡å¼å¯åŠ¨å™¨
åŒæ—¶å¯åŠ¨Claudeå’ŒCodexä¸¤ä¸ªçª—å£ï¼Œå»ºç«‹å•å‘æ§åˆ¶é€šé“
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
import shlex
import shutil
from pathlib import Path

class ClaudeCodexDual:
    def __init__(self, resume=False, claude_args=None, codex_resume=False):
        self.resume = resume
        self.codex_resume = codex_resume
        self.claude_args = claude_args or []
        self.script_dir = Path(__file__).resolve().parent

        self.project_session_file = Path.cwd() / ".codex-session"
        self.saved_session = self._load_saved_session()
        self.codex_session_id = None
        if self.saved_session:
            self._sanitize_saved_session()
            self.codex_session_id = self.saved_session.get("codex_session_id")
        self.codex_session = None
        self.codex_start_cmd = "codex"

        if self.codex_resume:
            self._apply_saved_codex_session()
        else:
            self._reset_codex_defaults()

        # ä¼šè¯ç®¡ç†
        self.session_id = f"dual-{int(time.time())}-{os.getpid()}"
        self.runtime_dir = Path("/tmp") / f"codex-{getpass.getuser()}" / self.session_id
        self.runtime_dir.mkdir(parents=True, exist_ok=True)

        # æ–‡ä»¶è·¯å¾„
        self.input_fifo = self.runtime_dir / "input.fifo"
        self.output_fifo = self.runtime_dir / "output.fifo"
        self.codex_pid_file = self.runtime_dir / "codex.pid"
        self.claude_pid_file = self.runtime_dir / "claude.pid"
        self.status_file = self.runtime_dir / "status"
        self.lock_file = self.runtime_dir / "lock"
        self.bridge_pid_file = self.runtime_dir / "bridge.pid"
        self.tmux_session = f"codex-{self.session_id[:8]}"
        self.tmux_log_file = self.runtime_dir / "bridge_output.log"

        # è¿›ç¨‹ç®¡ç†
        self.codex_process = None
        self.terminal_type = None
        self.daemon_socket = self.runtime_dir / "codex-daemon.sock"
        self.daemon_pid_file = self.runtime_dir / "codex-daemon.pid"
        self.client_id = f"codex-dual-{uuid.uuid4().hex[:8]}"

    def _load_saved_session(self) -> dict | None:
        if not self.project_session_file.exists():
            return None
        try:
            with open(self.project_session_file, "r", encoding="utf-8") as handle:
                return json.load(handle)
        except Exception as exc:
            print(f"âš ï¸ æ— æ³•è¯»å–å†å²ä¼šè¯ä¿¡æ¯: {exc}")
            return None

    def _apply_saved_codex_session(self) -> None:
        if not self.saved_session:
            raise RuntimeError("âŒ æœªæ‰¾åˆ°å†å² Codex ä¼šè¯è®°å½•ï¼Œè¯·å…ˆè¿è¡Œ /cask å»ºç«‹ä¼šè¯")

        session_path = self.saved_session.get("codex_session_path")
        if not session_path:
            self._refresh_codex_session(force=True)
            session_path = self.saved_session.get("codex_session_path")
            if not session_path:
                raise RuntimeError("âŒ å†å²è®°å½•ä¸­ç¼ºå°‘ codex_session_pathï¼Œæ— æ³•ä½¿ç”¨ -C æ¢å¤")

        session_id = self.saved_session.get("codex_session_id")
        path_obj = Path(session_path).expanduser()
        if not path_obj.exists() or not session_id:
            self._refresh_codex_session(force=True)
            session_path = self.saved_session.get("codex_session_path")
            session_id = self.saved_session.get("codex_session_id")
            if not session_path or not session_id:
                raise RuntimeError("âŒ å†å² Codex ä¼šè¯ä¿¡æ¯ä¸å®Œæ•´ï¼Œæ— æ³•æ¢å¤")
            path_obj = Path(session_path).expanduser()
            if not path_obj.exists():
                raise RuntimeError("âŒ å†å² Codex ä¼šè¯æ—¥å¿—ä¸å­˜åœ¨ï¼Œå·²å°è¯•åˆ·æ–°ä½†ä»å¤±è´¥")

        self.codex_session = path_obj
        self.codex_session_id = session_id
        self.codex_start_cmd = f"codex resume {session_id}"

    def _refresh_codex_session(self, force: bool = False) -> None:
        latest = self._find_latest_codex_session()
        if not latest:
            if force:
                raise RuntimeError("âŒ æœªæ‰¾åˆ°ä»»ä½• Codex å®˜æ–¹æ—¥å¿—ï¼Œæ— æ³•åˆ·æ–°")
            return
        if not self.saved_session:
            self.saved_session = {}
        session_id = self._extract_session_id(latest)
        changed = self.saved_session.get("codex_session_path") != str(latest)
        self.saved_session["codex_session_path"] = str(latest)
        if session_id:
            self.saved_session["codex_session_id"] = session_id
            if self.saved_session.get("codex_start_cmd") != f"codex resume {session_id}":
                self.saved_session["codex_start_cmd"] = f"codex resume {session_id}"
                changed = True
            self.codex_session_id = session_id
        else:
            self.codex_session_id = None
        if changed or force:
            self._write_project_session(self.saved_session)

    @staticmethod
    def _find_latest_codex_session() -> Path | None:
        root = Path.home() / ".codex" / "sessions"
        if not root.exists():
            return None
        try:
            logs = sorted(
                root.rglob("*.jsonl"),
                key=lambda p: (p.stat().st_mtime, p.stat().st_size),
            )
        except Exception:
            return None
        return logs[-1] if logs else None

    @staticmethod
    def _extract_session_id(log_path: Path) -> str | None:
        try:
            stem = log_path.stem
        except Exception:
            return None
        parts = stem.split("-")
        if len(parts) >= 5:
            candidate = "-".join(parts[-5:])
            if len(candidate) == 36 and candidate.count("-") == 4:
                return candidate
        try:
            with log_path.open("r", encoding="utf-8") as handle:
                first_line = handle.readline()
        except OSError:
            return None
        try:
            entry = json.loads(first_line)
            payload = entry.get("payload", {})
            session_meta_id = payload.get("id")
            if isinstance(session_meta_id, str):
                return session_meta_id
        except Exception:
            return None
        return None
    
    def _write_project_session(self, data: dict) -> None:
        tmp_file = self.project_session_file.with_suffix(".tmp")
        try:
            with tmp_file.open("w", encoding="utf-8") as handle:
                json.dump(data, handle, ensure_ascii=False, indent=2)
            os.replace(tmp_file, self.project_session_file)
        except Exception:
            if tmp_file.exists():
                tmp_file.unlink(missing_ok=True)
        else:
            self.saved_session = data

    def _sanitize_saved_session(self) -> None:
        if not self.saved_session:
            return
        updated = False
        path_value = self.saved_session.get("codex_session_path")
        session_id = self.saved_session.get("codex_session_id")
        if path_value and not session_id:
            new_id = self._extract_session_id(Path(path_value))
            if new_id:
                self.saved_session["codex_session_id"] = new_id
                session_id = new_id
                updated = True
        if session_id:
            desired_cmd = f"codex resume {session_id}"
            if self.saved_session.get("codex_start_cmd") != desired_cmd:
                self.saved_session["codex_start_cmd"] = desired_cmd
                updated = True
            self.codex_session_id = session_id
        else:
            self.codex_session_id = None
        if updated:
            self._write_project_session(self.saved_session)

    def _reset_codex_defaults(self, write_back: bool = True) -> None:
        self.codex_session = None
        self.codex_session_id = None
        self.codex_start_cmd = "codex"
        if not self.saved_session:
            self.saved_session = {}
        changed = False
        if self.saved_session.pop("codex_session_path", None) is not None:
            changed = True
        if self.saved_session.pop("codex_session_id", None) is not None:
            changed = True
        if self.saved_session.get("codex_start_cmd") != self.codex_start_cmd:
            self.saved_session["codex_start_cmd"] = self.codex_start_cmd
            changed = True
        if write_back and changed:
            self._write_project_session(self.saved_session)

    def detect_terminal(self):
        """æ£€æµ‹å¯ç”¨çš„ç»ˆç«¯å·¥å…·"""
        env_terminal = os.environ.get("TERMINAL")
        if env_terminal and shutil.which(env_terminal):
            print(f"âœ… ä½¿ç”¨ç»ˆç«¯: {env_terminal}")
            return env_terminal

        terminals = [
            "gnome-terminal",
            "konsole",
            "alacritty",
            "xterm",
            "xfce4-terminal"
        ]

        for term in terminals:
            if subprocess.run(["which", term], capture_output=True).returncode == 0:
                print(f"âœ… æ£€æµ‹åˆ°ç»ˆç«¯: {term}")
                return term

        print("âš ï¸ æœªæ£€æµ‹åˆ°å›¾å½¢ç»ˆç«¯ï¼Œä½¿ç”¨ tmux")
        return "tmux"

    def create_fifos(self):
        """åˆ›å»ºFIFOç®¡é“"""
        print("ğŸ”§ åˆ›å»ºé€šä¿¡ç®¡é“...")

        try:
            # åˆ›å»ºè¾“å…¥ç®¡é“ (Claude â†’ Codex)
            if not self.input_fifo.exists():
                os.mkfifo(self.input_fifo)
            os.chmod(self.input_fifo, 0o600)  # åªå…è®¸æ‰€æœ‰è€…è¯»å†™

            # åˆ›å»ºè¾“å‡ºç®¡é“ (Codex â†’ Claude ç›‘æ§)
            if not self.output_fifo.exists():
                os.mkfifo(self.output_fifo)
            os.chmod(self.output_fifo, 0o644)  # å…è®¸æ‰€æœ‰è€…è¯»å†™ï¼Œå…¶ä»–ç”¨æˆ·åªè¯»

            print(f"âœ… ç®¡é“åˆ›å»ºå®Œæˆ:")
            print(f"   è¾“å…¥: {self.input_fifo}")
            print(f"   è¾“å‡º: {self.output_fifo}")
            return True

        except Exception as e:
            print(f"âŒ åˆ›å»ºç®¡é“å¤±è´¥: {e}")
            return False

    def start_codex_window(self):
        """å¯åŠ¨Codexçª—å£"""
        print("ğŸš€ å¯åŠ¨Codexçª—å£...")

        self.terminal_type = self.detect_terminal()

        python_bin = sys.executable
        bridge_script = self.script_dir / "codex_dual_bridge.py"

        # åˆ›å»ºCodexå¯åŠ¨è„šæœ¬
        codex_wrapper_script = f'''
#!/bin/bash
# Codexçª—å£å¯åŠ¨è„šæœ¬

 SESSION_ID="{self.session_id}"
 RUNTIME_DIR="/tmp/codex-{getpass.getuser()}/$SESSION_ID"
 INPUT_FIFO="$RUNTIME_DIR/input.fifo"
 OUTPUT_FIFO="$RUNTIME_DIR/output.fifo"
 PID_FILE="$RUNTIME_DIR/codex.pid"
 TMUX_SESSION="{self.tmux_session}"
 TMUX_LOG_FILE="$RUNTIME_DIR/bridge_output.log"
 BRIDGE_SCRIPT="{bridge_script}"
 PYTHON_BIN="{python_bin}"
 SCRIPT_DIR="{self.script_dir}"
 SOCKET_PATH="{self.daemon_socket}"
 DAEMON_PID="{self.daemon_pid_file}"
CLIENT_ID="{self.client_id}"
CODEX_START_CMD={json.dumps(self.codex_start_cmd, ensure_ascii=False)}
BRIDGE_PID_FILE="$RUNTIME_DIR/bridge.pid"
BRIDGE_LOG="$RUNTIME_DIR/bridge.log"

# å†™å…¥PID
echo $$ > "$PID_FILE"

 echo "ğŸ¤– Codexä¼šè¯å¯åŠ¨: $SESSION_ID"
 echo "ğŸ“ è¿è¡Œç›®å½•: $RUNTIME_DIR"
 echo "ğŸ”§ è¾“å…¥ç®¡é“: $INPUT_FIFO"
 echo "ğŸ”§ è¾“å‡ºç®¡é“: $OUTPUT_FIFO"
 echo "ğŸ–¥ï¸  tmuxä¼šè¯: $TMUX_SESSION"

 # ç­‰å¾…è¾“å…¥ç®¡é“å¯ç”¨
 while [ ! -p "$INPUT_FIFO" ]; do
     echo "â³ ç­‰å¾…è¾“å…¥ç®¡é“..."
     sleep 0.1
done

echo "âœ… ç®¡é“è¿æ¥å»ºç«‹"

# æ£€æŸ¥æ¡¥æ¥è„šæœ¬å’ŒPythonç¯å¢ƒ
if [ ! -f "$BRIDGE_SCRIPT" ]; then
    echo "âŒ æ‰¾ä¸åˆ°æ¡¥æ¥è„šæœ¬: $BRIDGE_SCRIPT"
    sleep 5
    exit 1
fi

if [ ! -x "$PYTHON_BIN" ]; then
    echo "âŒ æ— æ³•æ‰§è¡ŒPythonè§£é‡Šå™¨: $PYTHON_BIN"
    sleep 5
    exit 1
fi

echo "ğŸ”§ å‡†å¤‡å¯åŠ¨Codexæ¡¥æ¥å™¨..."
export PYTHONPATH="$SCRIPT_DIR:${{PYTHONPATH:-}}"
export CODEX_SESSION_ID="$SESSION_ID"
export CODEX_RUNTIME_DIR="$RUNTIME_DIR"
export CODEX_DAEMON_SOCKET="$SOCKET_PATH"
 export CODEX_DAEMON_PID="$DAEMON_PID"
 export CODEX_CLIENT_ID="$CLIENT_ID"
 export CODEX_INPUT_FIFO="$INPUT_FIFO"
 export CODEX_OUTPUT_FIFO="$OUTPUT_FIFO"
 export CODEX_TMUX_SESSION="$TMUX_SESSION"
 export CODEX_TMUX_LOG="$TMUX_LOG_FILE"

# å¯åŠ¨æˆ–å‡†å¤‡tmuxä¼šè¯
if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    START_CMD="${{CODEX_START_CMD:-codex}}"
    tmux new-session -d -s "$TMUX_SESSION" bash -lc "$START_CMD"
    sleep 1
fi
tmux pipe-pane -o -t "$TMUX_SESSION" "cat >> '$TMUX_LOG_FILE'"

# å¯åŠ¨æ¡¥æ¥å™¨ï¼ˆåå°è¿è¡Œï¼‰
"$PYTHON_BIN" "$BRIDGE_SCRIPT" --runtime-dir "$RUNTIME_DIR" --session-id "$SESSION_ID" >>"$BRIDGE_LOG" 2>&1 &
BRIDGE_PID=$!
echo $BRIDGE_PID > "$BRIDGE_PID_FILE"
echo "ğŸª„ æ¡¥æ¥å™¨å·²å¯åŠ¨ (PID: $BRIDGE_PID)"
echo "ğŸ“„ æ—¥å¿—è¾“å‡º: $BRIDGE_LOG"

cleanup() {{
    if [ -n "$BRIDGE_PID" ]; then
        kill -TERM "$BRIDGE_PID" 2>/dev/null
        wait "$BRIDGE_PID" 2>/dev/null
    fi
}}
trap cleanup EXIT

# é™„åŠ åˆ°tmuxä¼šè¯ä¾›ç”¨æˆ·ä½¿ç”¨
exec tmux attach -t "$TMUX_SESSION"
'''

        try:
            # å°†è„šæœ¬å†™å…¥ä¸´æ—¶æ–‡ä»¶
            script_file = self.runtime_dir / "codex_wrapper.sh"
            with open(script_file, 'w') as f:
                f.write(codex_wrapper_script)
            os.chmod(script_file, 0o755)

            if self.terminal_type == "tmux":
                # ä½¿ç”¨tmuxåˆ›å»ºæ–°ä¼šè¯
                cmd = [
                    "tmux", "new-session", "-d", "-s", f"codex-{self.session_id[:8]}",
                    str(script_file)
                ]
                subprocess.run(cmd, check=True)

                # é™„åŠ åˆ°tmuxä¼šè¯
                subprocess.run([
                    "tmux", "attach-session", "-t", f"codex-{self.session_id[:8]}"
                ])

            elif self.terminal_type == "tilix":
                cmd = [
                    "tilix", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type in ["gnome-terminal", "xfce4-terminal"]:
                cmd = [
                    self.terminal_type, "--title", f"Codex ({self.session_id[:8]})",
                    "--", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "konsole":
                cmd = [
                    "konsole", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "alacritty":
                cmd = [
                    "alacritty", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            else:  # xterm æˆ–å…¶ä»–
                cmd = [
                    self.terminal_type, "-title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            print(f"âœ… Codexçª—å£å·²å¯åŠ¨ (PID: {self.codex_process.pid if self.codex_process else 'tmux'})")
            return True

        except Exception as e:
            print(f"âŒ å¯åŠ¨Codexçª—å£å¤±è´¥: {e}")
            return False

    def start_claude_window(self):
        """å¯åŠ¨Claudeçª—å£"""
        print("ğŸš€ å¯åŠ¨Claudeçª—å£...")

        # ä¿å­˜ä¼šè¯ä¿¡æ¯åˆ°é¡¹ç›®ç›®å½•
        try:
            session_info = {
                "session_id": self.session_id,
                "runtime_dir": str(self.runtime_dir),
                "input_fifo": str(self.input_fifo),
                "output_fifo": str(self.output_fifo),
                "tmux_session": self.tmux_session,
                "tmux_log": str(self.tmux_log_file),
                "daemon_socket": str(self.daemon_socket),
                "daemon_pid_file": str(self.daemon_pid_file),
                "bridge_pid_file": str(self.bridge_pid_file),
                "bridge_log": str(self.runtime_dir / "bridge.log"),
                "client_id": self.client_id,
                "codex_start_cmd": self.codex_start_cmd,
                "started_at": time.strftime('%Y-%m-%d %H:%M:%S'),
                "active": True,
            }
            if self.codex_session:
                session_info["codex_session_path"] = str(self.codex_session)
            elif self.saved_session and self.saved_session.get("codex_session_path"):
                session_info["codex_session_path"] = self.saved_session["codex_session_path"]

            if self.codex_session_id:
                session_info["codex_session_id"] = self.codex_session_id
            elif self.saved_session and self.saved_session.get("codex_session_id"):
                session_info["codex_session_id"] = self.saved_session["codex_session_id"]

            self._write_project_session(session_info)
            self.saved_session = session_info
            print(f"âœ… ä¼šè¯ä¿¡æ¯å·²ä¿å­˜: {self.project_session_file}")
        except Exception as e:
            print(f"âš ï¸ ä¿å­˜ä¼šè¯ä¿¡æ¯å¤±è´¥: {e}")

        # è®¾ç½®ç¯å¢ƒå˜é‡
        env = os.environ.copy()
        env["CODEX_SESSION_ID"] = self.session_id
        env["CODEX_RUNTIME_DIR"] = str(self.runtime_dir)
        env["CODEX_INPUT_FIFO"] = str(self.input_fifo)
        env["CODEX_OUTPUT_FIFO"] = str(self.output_fifo)
        env["CODEX_CLIENT_ID"] = self.client_id
        env["CODEX_DAEMON_SOCKET"] = str(self.daemon_socket)
        env["CODEX_DAEMON_PID"] = str(self.daemon_pid_file)
        env["CODEX_TMUX_SESSION"] = self.tmux_session
        env["CODEX_TMUX_LOG"] = str(self.tmux_log_file)

        # å†™å…¥Claude PID
        with open(self.claude_pid_file, 'w') as f:
            f.write(str(os.getpid()))

        # æ›´æ–°çŠ¶æ€
        with open(self.status_file, 'w') as f:
            f.write("running")

        print(f"ğŸ“‹ ä¼šè¯ID: {self.session_id}")
        print(f"ğŸ“ è¿è¡Œç›®å½•: {self.runtime_dir}")
        print("âœ… Claudeçª—å£å°±ç»ª")
        print()
        print("ğŸ¯ å¯ç”¨å‘½ä»¤:")
        print("   /cask <é—®é¢˜>              - å¼‚æ­¥å‘é€é—®é¢˜")
        print("   /cask-w <é—®é¢˜>           - åŒæ­¥ç­‰å¾…å›å¤")
        print("   /codex-status                  - æŸ¥çœ‹è¿æ¥çŠ¶æ€")
        print("   /codex-ping                    - æµ‹è¯•è¿é€šæ€§")
        print()

        # å¯åŠ¨Claude Code
        try:
            cmd = ["claude"] + self.claude_args
            print(f"æ‰§è¡Œ: {' '.join(cmd)}")

            return subprocess.run(
                cmd,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                env=env
            ).returncode

        except KeyboardInterrupt:
            print("\\nâš ï¸ ç”¨æˆ·ä¸­æ–­")
            return 130
        except Exception as e:
            print(f"âŒ å¯åŠ¨Claudeå¤±è´¥: {e}")
            return 1

    def cleanup(self):
        """æ¸…ç†èµ„æº"""
        print("\\nğŸ§¹ æ¸…ç†ä¼šè¯èµ„æº...")

        try:
            # åœæ­¢Codexè¿›ç¨‹
            if self.codex_process and self.codex_process.poll() is None:
                self.codex_process.terminate()
                try:
                    self.codex_process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.codex_process.kill()

            # åœæ­¢æ¡¥æ¥å™¨
            if self.bridge_pid_file.exists():
                try:
                    bridge_pid = int(self.bridge_pid_file.read_text().strip())
                    os.kill(bridge_pid, signal.SIGTERM)
                except Exception:
                    pass
                try:
                    self.bridge_pid_file.unlink()
                except Exception:
                    pass

            # å¦‚æœæ˜¯tmuxä¼šè¯ï¼Œæ€æ‰tmux
            if self.terminal_type == "tmux":
                subprocess.run([
                    "tmux", "kill-session", "-t", f"codex-{self.session_id[:8]}"
                ], stderr=subprocess.DEVNULL)
            else:
                subprocess.run([
                    "tmux", "kill-session", "-t", self.tmux_session
                ], stderr=subprocess.DEVNULL)

            # åˆ é™¤è¿è¡Œæ—¶ç›®å½•
            import shutil
            if self.runtime_dir.exists() and not os.environ.get("CODEX_KEEP_RUNTIME"):
                shutil.rmtree(self.runtime_dir)

            # æ ‡è®°é¡¹ç›®ä¼šè¯æ–‡ä»¶ä¸ºéæ´»è·ƒ
            self._mark_session_inactive()

            print("âœ… æ¸…ç†å®Œæˆ")

        except Exception as e:
            print(f"âš ï¸ æ¸…ç†æ—¶å‡ºç°é”™è¯¯: {e}")

    def run(self):
        """ä¸»è¿è¡Œæµç¨‹"""
        print(f"ğŸš€ Claude-Codex åŒçª—å£æ¨¡å¼")
        print(f"ğŸ“… å¯åŠ¨æ—¶é—´: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"ğŸ†” ä¼šè¯ID: {self.session_id}")
        print("=" * 50)

        # æ³¨å†Œæ¸…ç†å‡½æ•°
        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, lambda s, f: (self.cleanup(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (self.cleanup(), sys.exit(0)))

        # åˆ›å»ºç®¡é“
        if not self.create_fifos():
            return 1

        # å¯åŠ¨Codexçª—å£
        if not self.start_codex_window():
            return 1

        # ç­‰å¾…Codexå¯åŠ¨
        time.sleep(2)

        # å¯åŠ¨Claudeçª—å£
        try:
            return self.start_claude_window()
        finally:
            self.cleanup()

    def _mark_session_inactive(self) -> None:
        if not self.project_session_file.exists():
            return
        try:
            with self.project_session_file.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
        except Exception:
            return

        data["active"] = False
        data["stopped_at"] = time.strftime("%Y-%m-%d %H:%M:%S")

        tmp_file = self.project_session_file.with_suffix(".tmp")
        try:
            with tmp_file.open("w", encoding="utf-8") as handle:
                json.dump(data, handle, ensure_ascii=False, indent=2)
            os.replace(tmp_file, self.project_session_file)
        except Exception:
            if tmp_file.exists():
                tmp_file.unlink(missing_ok=True)

def show_help():
    """æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"""
    help_text = """
claude_codex - Claude-Codex åŒçª—å£æ¨¡å¼å¯åŠ¨å™¨

ç”¨æ³•:
    claude_codex [OPTIONS] [COMMAND] [ARGS]...

åŠŸèƒ½:
    ğŸš€ åŒæ—¶å¯åŠ¨Claudeå’ŒCodexä¸¤ä¸ªçª—å£
    ğŸ”— å»ºç«‹Claudeåˆ°Codexçš„å•å‘æ§åˆ¶é€šé“
    ğŸ’¾ è‡ªåŠ¨ä¿å­˜ä¼šè¯ä¿¡æ¯å’Œå†å²è®°å½•
    ğŸ”„ æ”¯æŒä¸­æ–­æ¢å¤å’Œé”™è¯¯å¤„ç†

é€‰é¡¹:
    --resume              æ¢å¤ä¸Šæ¬¡çš„ä¼šè¯ï¼ˆç­‰ä»·äºåŒæ—¶å¯ç”¨ -Cï¼‰
    -C, --codex-resume    ä»…æ¢å¤ Codex çª—å£ï¼Œä½¿ç”¨é¦–æ¬¡å»ºç«‹çš„å®˜æ–¹æ—¥å¿—
    --help, -h            æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯

Claudeå‘½ä»¤ (åœ¨Claudeçª—å£ä¸­ä½¿ç”¨):
    /cask <é—®é¢˜>              - å¼‚æ­¥å‘é€é—®é¢˜åˆ°Codex
    /cask-w <é—®é¢˜>       - åŒæ­¥ç­‰å¾…Codexå›å¤
    /codex-status                  - æŸ¥çœ‹è¿æ¥çŠ¶æ€
    /codex-ping                    - æµ‹è¯•è¿é€šæ€§
    /codex-history [n]             - æŸ¥çœ‹æœ€è¿‘næ¡å¯¹è¯

ç¤ºä¾‹:
    claude_codex                           # å¯åŠ¨åŒçª—å£æ¨¡å¼
    claude_codex --resume                  # æ¢å¤ä¸Šæ¬¡ä¼šè¯
    claude_codex /path/to/project          # åœ¨é¡¹ç›®ç›®å½•å¯åŠ¨
"""
    print(help_text)

def main():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--resume', action='store_true', help='æ¢å¤ä¸Šæ¬¡çš„ä¼šè¯')
    parser.add_argument('-C', '--codex-resume', action='store_true', help='ä»å†å²è®°å½•æ¢å¤ Codex ä¼šè¯')
    parser.add_argument('--help', '-h', action='store_true', help='æ˜¾ç¤ºå¸®åŠ©')

    # è§£æå·²çŸ¥å‚æ•°ï¼Œå…¶ä½™ä¼ ç»™claude
    args, claude_args = parser.parse_known_args()

    if args.help:
        show_help()
        return 0

    codex_resume = args.codex_resume or args.resume
    dual = ClaudeCodexDual(
        resume=args.resume,
        claude_args=claude_args,
        codex_resume=codex_resume,
    )
    return dual.run()

if __name__ == "__main__":
    sys.exit(main())
