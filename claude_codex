#!/usr/bin/env python3
"""
claude_codex - Claude-Codex 双窗口模式启动器
同时启动Claude和Codex两个窗口，建立单向控制通道
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
import shlex
import shutil
from pathlib import Path

class ClaudeCodexDual:
    def __init__(self, resume=False, claude_args=None, codex_resume=False):
        self.resume = resume
        self.codex_resume = codex_resume
        self.claude_args = claude_args or []
        self.script_dir = Path(__file__).resolve().parent

        self.project_session_file = Path.cwd() / ".codex-session"
        self.saved_session = self._load_saved_session()
        self.codex_session_id = None
        if self.saved_session:
            self._sanitize_saved_session()
            self.codex_session_id = self.saved_session.get("codex_session_id")
        self.codex_session = None
        self.codex_start_cmd = "codex"

        if self.codex_resume:
            self._apply_saved_codex_session()
        else:
            self._reset_codex_defaults()

        # 会话管理
        self.session_id = f"dual-{int(time.time())}-{os.getpid()}"
        self.runtime_dir = Path("/tmp") / f"codex-{getpass.getuser()}" / self.session_id
        self.runtime_dir.mkdir(parents=True, exist_ok=True)

        # 文件路径
        self.input_fifo = self.runtime_dir / "input.fifo"
        self.output_fifo = self.runtime_dir / "output.fifo"
        self.codex_pid_file = self.runtime_dir / "codex.pid"
        self.claude_pid_file = self.runtime_dir / "claude.pid"
        self.status_file = self.runtime_dir / "status"
        self.lock_file = self.runtime_dir / "lock"
        self.bridge_pid_file = self.runtime_dir / "bridge.pid"
        self.tmux_session = f"codex-{self.session_id[:8]}"
        self.tmux_log_file = self.runtime_dir / "bridge_output.log"

        # 进程管理
        self.codex_process = None
        self.terminal_type = None
        self.daemon_socket = self.runtime_dir / "codex-daemon.sock"
        self.daemon_pid_file = self.runtime_dir / "codex-daemon.pid"
        self.client_id = f"codex-dual-{uuid.uuid4().hex[:8]}"

    def _load_saved_session(self) -> dict | None:
        if not self.project_session_file.exists():
            return None
        try:
            with open(self.project_session_file, "r", encoding="utf-8") as handle:
                return json.load(handle)
        except Exception as exc:
            print(f"⚠️ 无法读取历史会话信息: {exc}")
            return None

    def _apply_saved_codex_session(self) -> None:
        if not self.saved_session:
            raise RuntimeError("❌ 未找到历史 Codex 会话记录，请先运行 /cask 建立会话")

        session_path = self.saved_session.get("codex_session_path")
        if not session_path:
            self._refresh_codex_session(force=True)
            session_path = self.saved_session.get("codex_session_path")
            if not session_path:
                raise RuntimeError("❌ 历史记录中缺少 codex_session_path，无法使用 -C 恢复")

        session_id = self.saved_session.get("codex_session_id")
        path_obj = Path(session_path).expanduser()
        if not path_obj.exists() or not session_id:
            self._refresh_codex_session(force=True)
            session_path = self.saved_session.get("codex_session_path")
            session_id = self.saved_session.get("codex_session_id")
            if not session_path or not session_id:
                raise RuntimeError("❌ 历史 Codex 会话信息不完整，无法恢复")
            path_obj = Path(session_path).expanduser()
            if not path_obj.exists():
                raise RuntimeError("❌ 历史 Codex 会话日志不存在，已尝试刷新但仍失败")

        self.codex_session = path_obj
        self.codex_session_id = session_id
        self.codex_start_cmd = f"codex resume {session_id}"

    def _refresh_codex_session(self, force: bool = False) -> None:
        latest = self._find_latest_codex_session()
        if not latest:
            if force:
                raise RuntimeError("❌ 未找到任何 Codex 官方日志，无法刷新")
            return
        if not self.saved_session:
            self.saved_session = {}
        session_id = self._extract_session_id(latest)
        changed = self.saved_session.get("codex_session_path") != str(latest)
        self.saved_session["codex_session_path"] = str(latest)
        if session_id:
            self.saved_session["codex_session_id"] = session_id
            if self.saved_session.get("codex_start_cmd") != f"codex resume {session_id}":
                self.saved_session["codex_start_cmd"] = f"codex resume {session_id}"
                changed = True
            self.codex_session_id = session_id
        else:
            self.codex_session_id = None
        if changed or force:
            self._write_project_session(self.saved_session)

    @staticmethod
    def _find_latest_codex_session() -> Path | None:
        root = Path.home() / ".codex" / "sessions"
        if not root.exists():
            return None
        try:
            logs = sorted(
                root.rglob("*.jsonl"),
                key=lambda p: (p.stat().st_mtime, p.stat().st_size),
            )
        except Exception:
            return None
        return logs[-1] if logs else None

    @staticmethod
    def _extract_session_id(log_path: Path) -> str | None:
        try:
            stem = log_path.stem
        except Exception:
            return None
        parts = stem.split("-")
        if len(parts) >= 5:
            candidate = "-".join(parts[-5:])
            if len(candidate) == 36 and candidate.count("-") == 4:
                return candidate
        try:
            with log_path.open("r", encoding="utf-8") as handle:
                first_line = handle.readline()
        except OSError:
            return None
        try:
            entry = json.loads(first_line)
            payload = entry.get("payload", {})
            session_meta_id = payload.get("id")
            if isinstance(session_meta_id, str):
                return session_meta_id
        except Exception:
            return None
        return None
    
    def _write_project_session(self, data: dict) -> None:
        tmp_file = self.project_session_file.with_suffix(".tmp")
        try:
            with tmp_file.open("w", encoding="utf-8") as handle:
                json.dump(data, handle, ensure_ascii=False, indent=2)
            os.replace(tmp_file, self.project_session_file)
        except Exception:
            if tmp_file.exists():
                tmp_file.unlink(missing_ok=True)
        else:
            self.saved_session = data

    def _sanitize_saved_session(self) -> None:
        if not self.saved_session:
            return
        updated = False
        path_value = self.saved_session.get("codex_session_path")
        session_id = self.saved_session.get("codex_session_id")
        if path_value and not session_id:
            new_id = self._extract_session_id(Path(path_value))
            if new_id:
                self.saved_session["codex_session_id"] = new_id
                session_id = new_id
                updated = True
        if session_id:
            desired_cmd = f"codex resume {session_id}"
            if self.saved_session.get("codex_start_cmd") != desired_cmd:
                self.saved_session["codex_start_cmd"] = desired_cmd
                updated = True
            self.codex_session_id = session_id
        else:
            self.codex_session_id = None
        if updated:
            self._write_project_session(self.saved_session)

    def _reset_codex_defaults(self, write_back: bool = True) -> None:
        self.codex_session = None
        self.codex_session_id = None
        self.codex_start_cmd = "codex"
        if not self.saved_session:
            self.saved_session = {}
        changed = False
        if self.saved_session.pop("codex_session_path", None) is not None:
            changed = True
        if self.saved_session.pop("codex_session_id", None) is not None:
            changed = True
        if self.saved_session.get("codex_start_cmd") != self.codex_start_cmd:
            self.saved_session["codex_start_cmd"] = self.codex_start_cmd
            changed = True
        if write_back and changed:
            self._write_project_session(self.saved_session)

    def detect_terminal(self):
        """检测可用的终端工具"""
        env_terminal = os.environ.get("TERMINAL")
        if env_terminal and shutil.which(env_terminal):
            print(f"✅ 使用终端: {env_terminal}")
            return env_terminal

        terminals = [
            "gnome-terminal",
            "konsole",
            "alacritty",
            "xterm",
            "xfce4-terminal"
        ]

        for term in terminals:
            if subprocess.run(["which", term], capture_output=True).returncode == 0:
                print(f"✅ 检测到终端: {term}")
                return term

        print("⚠️ 未检测到图形终端，使用 tmux")
        return "tmux"

    def create_fifos(self):
        """创建FIFO管道"""
        print("🔧 创建通信管道...")

        try:
            # 创建输入管道 (Claude → Codex)
            if not self.input_fifo.exists():
                os.mkfifo(self.input_fifo)
            os.chmod(self.input_fifo, 0o600)  # 只允许所有者读写

            # 创建输出管道 (Codex → Claude 监控)
            if not self.output_fifo.exists():
                os.mkfifo(self.output_fifo)
            os.chmod(self.output_fifo, 0o644)  # 允许所有者读写，其他用户只读

            print(f"✅ 管道创建完成:")
            print(f"   输入: {self.input_fifo}")
            print(f"   输出: {self.output_fifo}")
            return True

        except Exception as e:
            print(f"❌ 创建管道失败: {e}")
            return False

    def start_codex_window(self):
        """启动Codex窗口"""
        print("🚀 启动Codex窗口...")

        self.terminal_type = self.detect_terminal()

        python_bin = sys.executable
        bridge_script = self.script_dir / "codex_dual_bridge.py"

        # 创建Codex启动脚本
        codex_wrapper_script = f'''
#!/bin/bash
# Codex窗口启动脚本

 SESSION_ID="{self.session_id}"
 RUNTIME_DIR="/tmp/codex-{getpass.getuser()}/$SESSION_ID"
 INPUT_FIFO="$RUNTIME_DIR/input.fifo"
 OUTPUT_FIFO="$RUNTIME_DIR/output.fifo"
 PID_FILE="$RUNTIME_DIR/codex.pid"
 TMUX_SESSION="{self.tmux_session}"
 TMUX_LOG_FILE="$RUNTIME_DIR/bridge_output.log"
 BRIDGE_SCRIPT="{bridge_script}"
 PYTHON_BIN="{python_bin}"
 SCRIPT_DIR="{self.script_dir}"
 SOCKET_PATH="{self.daemon_socket}"
 DAEMON_PID="{self.daemon_pid_file}"
CLIENT_ID="{self.client_id}"
CODEX_START_CMD={json.dumps(self.codex_start_cmd, ensure_ascii=False)}
BRIDGE_PID_FILE="$RUNTIME_DIR/bridge.pid"
BRIDGE_LOG="$RUNTIME_DIR/bridge.log"

# 写入PID
echo $$ > "$PID_FILE"

 echo "🤖 Codex会话启动: $SESSION_ID"
 echo "📁 运行目录: $RUNTIME_DIR"
 echo "🔧 输入管道: $INPUT_FIFO"
 echo "🔧 输出管道: $OUTPUT_FIFO"
 echo "🖥️  tmux会话: $TMUX_SESSION"

 # 等待输入管道可用
 while [ ! -p "$INPUT_FIFO" ]; do
     echo "⏳ 等待输入管道..."
     sleep 0.1
done

echo "✅ 管道连接建立"

# 检查桥接脚本和Python环境
if [ ! -f "$BRIDGE_SCRIPT" ]; then
    echo "❌ 找不到桥接脚本: $BRIDGE_SCRIPT"
    sleep 5
    exit 1
fi

if [ ! -x "$PYTHON_BIN" ]; then
    echo "❌ 无法执行Python解释器: $PYTHON_BIN"
    sleep 5
    exit 1
fi

echo "🔧 准备启动Codex桥接器..."
export PYTHONPATH="$SCRIPT_DIR:${{PYTHONPATH:-}}"
export CODEX_SESSION_ID="$SESSION_ID"
export CODEX_RUNTIME_DIR="$RUNTIME_DIR"
export CODEX_DAEMON_SOCKET="$SOCKET_PATH"
 export CODEX_DAEMON_PID="$DAEMON_PID"
 export CODEX_CLIENT_ID="$CLIENT_ID"
 export CODEX_INPUT_FIFO="$INPUT_FIFO"
 export CODEX_OUTPUT_FIFO="$OUTPUT_FIFO"
 export CODEX_TMUX_SESSION="$TMUX_SESSION"
 export CODEX_TMUX_LOG="$TMUX_LOG_FILE"

# 启动或准备tmux会话
if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    START_CMD="${{CODEX_START_CMD:-codex}}"
    tmux new-session -d -s "$TMUX_SESSION" bash -lc "$START_CMD"
    sleep 1
fi
tmux pipe-pane -o -t "$TMUX_SESSION" "cat >> '$TMUX_LOG_FILE'"

# 启动桥接器（后台运行）
"$PYTHON_BIN" "$BRIDGE_SCRIPT" --runtime-dir "$RUNTIME_DIR" --session-id "$SESSION_ID" >>"$BRIDGE_LOG" 2>&1 &
BRIDGE_PID=$!
echo $BRIDGE_PID > "$BRIDGE_PID_FILE"
echo "🪄 桥接器已启动 (PID: $BRIDGE_PID)"
echo "📄 日志输出: $BRIDGE_LOG"

cleanup() {{
    if [ -n "$BRIDGE_PID" ]; then
        kill -TERM "$BRIDGE_PID" 2>/dev/null
        wait "$BRIDGE_PID" 2>/dev/null
    fi
}}
trap cleanup EXIT

# 附加到tmux会话供用户使用
exec tmux attach -t "$TMUX_SESSION"
'''

        try:
            # 将脚本写入临时文件
            script_file = self.runtime_dir / "codex_wrapper.sh"
            with open(script_file, 'w') as f:
                f.write(codex_wrapper_script)
            os.chmod(script_file, 0o755)

            if self.terminal_type == "tmux":
                # 使用tmux创建新会话
                cmd = [
                    "tmux", "new-session", "-d", "-s", f"codex-{self.session_id[:8]}",
                    str(script_file)
                ]
                subprocess.run(cmd, check=True)

                # 附加到tmux会话
                subprocess.run([
                    "tmux", "attach-session", "-t", f"codex-{self.session_id[:8]}"
                ])

            elif self.terminal_type == "tilix":
                cmd = [
                    "tilix", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type in ["gnome-terminal", "xfce4-terminal"]:
                cmd = [
                    self.terminal_type, "--title", f"Codex ({self.session_id[:8]})",
                    "--", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "konsole":
                cmd = [
                    "konsole", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "alacritty":
                cmd = [
                    "alacritty", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            else:  # xterm 或其他
                cmd = [
                    self.terminal_type, "-title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            print(f"✅ Codex窗口已启动 (PID: {self.codex_process.pid if self.codex_process else 'tmux'})")
            return True

        except Exception as e:
            print(f"❌ 启动Codex窗口失败: {e}")
            return False

    def start_claude_window(self):
        """启动Claude窗口"""
        print("🚀 启动Claude窗口...")

        # 保存会话信息到项目目录
        try:
            session_info = {
                "session_id": self.session_id,
                "runtime_dir": str(self.runtime_dir),
                "input_fifo": str(self.input_fifo),
                "output_fifo": str(self.output_fifo),
                "tmux_session": self.tmux_session,
                "tmux_log": str(self.tmux_log_file),
                "daemon_socket": str(self.daemon_socket),
                "daemon_pid_file": str(self.daemon_pid_file),
                "bridge_pid_file": str(self.bridge_pid_file),
                "bridge_log": str(self.runtime_dir / "bridge.log"),
                "client_id": self.client_id,
                "codex_start_cmd": self.codex_start_cmd,
                "started_at": time.strftime('%Y-%m-%d %H:%M:%S'),
                "active": True,
            }
            if self.codex_session:
                session_info["codex_session_path"] = str(self.codex_session)
            elif self.saved_session and self.saved_session.get("codex_session_path"):
                session_info["codex_session_path"] = self.saved_session["codex_session_path"]

            if self.codex_session_id:
                session_info["codex_session_id"] = self.codex_session_id
            elif self.saved_session and self.saved_session.get("codex_session_id"):
                session_info["codex_session_id"] = self.saved_session["codex_session_id"]

            self._write_project_session(session_info)
            self.saved_session = session_info
            print(f"✅ 会话信息已保存: {self.project_session_file}")
        except Exception as e:
            print(f"⚠️ 保存会话信息失败: {e}")

        # 设置环境变量
        env = os.environ.copy()
        env["CODEX_SESSION_ID"] = self.session_id
        env["CODEX_RUNTIME_DIR"] = str(self.runtime_dir)
        env["CODEX_INPUT_FIFO"] = str(self.input_fifo)
        env["CODEX_OUTPUT_FIFO"] = str(self.output_fifo)
        env["CODEX_CLIENT_ID"] = self.client_id
        env["CODEX_DAEMON_SOCKET"] = str(self.daemon_socket)
        env["CODEX_DAEMON_PID"] = str(self.daemon_pid_file)
        env["CODEX_TMUX_SESSION"] = self.tmux_session
        env["CODEX_TMUX_LOG"] = str(self.tmux_log_file)

        # 写入Claude PID
        with open(self.claude_pid_file, 'w') as f:
            f.write(str(os.getpid()))

        # 更新状态
        with open(self.status_file, 'w') as f:
            f.write("running")

        print(f"📋 会话ID: {self.session_id}")
        print(f"📁 运行目录: {self.runtime_dir}")
        print("✅ Claude窗口就绪")
        print()
        print("🎯 可用命令:")
        print("   /cask <问题>              - 异步发送问题")
        print("   /cask-w <问题>           - 同步等待回复")
        print("   /codex-status                  - 查看连接状态")
        print("   /codex-ping                    - 测试连通性")
        print()

        # 启动Claude Code
        try:
            cmd = ["claude"] + self.claude_args
            print(f"执行: {' '.join(cmd)}")

            return subprocess.run(
                cmd,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                env=env
            ).returncode

        except KeyboardInterrupt:
            print("\\n⚠️ 用户中断")
            return 130
        except Exception as e:
            print(f"❌ 启动Claude失败: {e}")
            return 1

    def cleanup(self):
        """清理资源"""
        print("\\n🧹 清理会话资源...")

        try:
            # 停止Codex进程
            if self.codex_process and self.codex_process.poll() is None:
                self.codex_process.terminate()
                try:
                    self.codex_process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.codex_process.kill()

            # 停止桥接器
            if self.bridge_pid_file.exists():
                try:
                    bridge_pid = int(self.bridge_pid_file.read_text().strip())
                    os.kill(bridge_pid, signal.SIGTERM)
                except Exception:
                    pass
                try:
                    self.bridge_pid_file.unlink()
                except Exception:
                    pass

            # 如果是tmux会话，杀掉tmux
            if self.terminal_type == "tmux":
                subprocess.run([
                    "tmux", "kill-session", "-t", f"codex-{self.session_id[:8]}"
                ], stderr=subprocess.DEVNULL)
            else:
                subprocess.run([
                    "tmux", "kill-session", "-t", self.tmux_session
                ], stderr=subprocess.DEVNULL)

            # 删除运行时目录
            import shutil
            if self.runtime_dir.exists() and not os.environ.get("CODEX_KEEP_RUNTIME"):
                shutil.rmtree(self.runtime_dir)

            # 标记项目会话文件为非活跃
            self._mark_session_inactive()

            print("✅ 清理完成")

        except Exception as e:
            print(f"⚠️ 清理时出现错误: {e}")

    def run(self):
        """主运行流程"""
        print(f"🚀 Claude-Codex 双窗口模式")
        print(f"📅 启动时间: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"🆔 会话ID: {self.session_id}")
        print("=" * 50)

        # 注册清理函数
        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, lambda s, f: (self.cleanup(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (self.cleanup(), sys.exit(0)))

        # 创建管道
        if not self.create_fifos():
            return 1

        # 启动Codex窗口
        if not self.start_codex_window():
            return 1

        # 等待Codex启动
        time.sleep(2)

        # 启动Claude窗口
        try:
            return self.start_claude_window()
        finally:
            self.cleanup()

    def _mark_session_inactive(self) -> None:
        if not self.project_session_file.exists():
            return
        try:
            with self.project_session_file.open("r", encoding="utf-8") as handle:
                data = json.load(handle)
        except Exception:
            return

        data["active"] = False
        data["stopped_at"] = time.strftime("%Y-%m-%d %H:%M:%S")

        tmp_file = self.project_session_file.with_suffix(".tmp")
        try:
            with tmp_file.open("w", encoding="utf-8") as handle:
                json.dump(data, handle, ensure_ascii=False, indent=2)
            os.replace(tmp_file, self.project_session_file)
        except Exception:
            if tmp_file.exists():
                tmp_file.unlink(missing_ok=True)

def show_help():
    """显示帮助信息"""
    help_text = """
claude_codex - Claude-Codex 双窗口模式启动器

用法:
    claude_codex [OPTIONS] [COMMAND] [ARGS]...

功能:
    🚀 同时启动Claude和Codex两个窗口
    🔗 建立Claude到Codex的单向控制通道
    💾 自动保存会话信息和历史记录
    🔄 支持中断恢复和错误处理

选项:
    --resume              恢复上次的会话（等价于同时启用 -C）
    -C, --codex-resume    仅恢复 Codex 窗口，使用首次建立的官方日志
    --help, -h            显示帮助信息

Claude命令 (在Claude窗口中使用):
    /cask <问题>              - 异步发送问题到Codex
    /cask-w <问题>       - 同步等待Codex回复
    /codex-status                  - 查看连接状态
    /codex-ping                    - 测试连通性
    /codex-history [n]             - 查看最近n条对话

示例:
    claude_codex                           # 启动双窗口模式
    claude_codex --resume                  # 恢复上次会话
    claude_codex /path/to/project          # 在项目目录启动
"""
    print(help_text)

def main():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--resume', action='store_true', help='恢复上次的会话')
    parser.add_argument('-C', '--codex-resume', action='store_true', help='从历史记录恢复 Codex 会话')
    parser.add_argument('--help', '-h', action='store_true', help='显示帮助')

    # 解析已知参数，其余传给claude
    args, claude_args = parser.parse_known_args()

    if args.help:
        show_help()
        return 0

    codex_resume = args.codex_resume or args.resume
    dual = ClaudeCodexDual(
        resume=args.resume,
        claude_args=claude_args,
        codex_resume=codex_resume,
    )
    return dual.run()

if __name__ == "__main__":
    sys.exit(main())
