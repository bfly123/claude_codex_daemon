#!/usr/bin/env python3
"""
claude-codex-dual - Claude-Codex 双窗口模式启动器
同时启动Claude和Codex两个窗口，建立单向控制通道
"""

import sys
import os
import json
import time
import subprocess
import signal
import atexit
import argparse
import uuid
import getpass
from pathlib import Path

class ClaudeCodexDual:
    def __init__(self, resume=False, claude_args=None):
        self.resume = resume
        self.claude_args = claude_args or []
        self.script_dir = Path(__file__).resolve().parent

        # 会话管理
        self.session_id = f"dual-{int(time.time())}-{os.getpid()}"
        self.runtime_dir = Path("/tmp") / f"codex-{getpass.getuser()}" / self.session_id
        self.runtime_dir.mkdir(parents=True, exist_ok=True)

        # 文件路径
        self.input_fifo = self.runtime_dir / "input.fifo"
        self.output_fifo = self.runtime_dir / "output.fifo"
        self.codex_pid_file = self.runtime_dir / "codex.pid"
        self.claude_pid_file = self.runtime_dir / "claude.pid"
        self.status_file = self.runtime_dir / "status"
        self.lock_file = self.runtime_dir / "lock"
        self.project_session_file = Path.cwd() / ".codex-session"
        self.bridge_pid_file = self.runtime_dir / "bridge.pid"
        self.tmux_session = f"codex-{self.session_id[:8]}"
        self.tmux_log_file = self.runtime_dir / "bridge_output.log"

        # 进程管理
        self.codex_process = None
        self.terminal_type = None
        self.daemon_socket = self.runtime_dir / "codex-daemon.sock"
        self.daemon_pid_file = self.runtime_dir / "codex-daemon.pid"
        self.client_id = f"codex-dual-{uuid.uuid4().hex[:8]}"

    def detect_terminal(self):
        """检测可用的终端工具"""
        terminals = [
            "gnome-terminal",
            "konsole",
            "alacritty",
            "xterm",
            "xfce4-terminal"
        ]

        for term in terminals:
            if subprocess.run(["which", term], capture_output=True).returncode == 0:
                print(f"✅ 检测到终端: {term}")
                return term

        print("⚠️ 未检测到图形终端，使用 tmux")
        return "tmux"

    def create_fifos(self):
        """创建FIFO管道"""
        print("🔧 创建通信管道...")

        try:
            # 创建输入管道 (Claude → Codex)
            if not self.input_fifo.exists():
                os.mkfifo(self.input_fifo)
            os.chmod(self.input_fifo, 0o600)  # 只允许所有者读写

            # 创建输出管道 (Codex → Claude 监控)
            if not self.output_fifo.exists():
                os.mkfifo(self.output_fifo)
            os.chmod(self.output_fifo, 0o644)  # 允许所有者读写，其他用户只读

            print(f"✅ 管道创建完成:")
            print(f"   输入: {self.input_fifo}")
            print(f"   输出: {self.output_fifo}")
            return True

        except Exception as e:
            print(f"❌ 创建管道失败: {e}")
            return False

    def start_codex_window(self):
        """启动Codex窗口"""
        print("🚀 启动Codex窗口...")

        self.terminal_type = self.detect_terminal()

        python_bin = sys.executable
        bridge_script = self.script_dir / "codex_dual_bridge.py"

        # 创建Codex启动脚本
        codex_wrapper_script = f'''
#!/bin/bash
# Codex窗口启动脚本

 SESSION_ID="{self.session_id}"
 RUNTIME_DIR="/tmp/codex-{getpass.getuser()}/$SESSION_ID"
 INPUT_FIFO="$RUNTIME_DIR/input.fifo"
 OUTPUT_FIFO="$RUNTIME_DIR/output.fifo"
 PID_FILE="$RUNTIME_DIR/codex.pid"
 TMUX_SESSION="{self.tmux_session}"
 TMUX_LOG_FILE="$RUNTIME_DIR/bridge_output.log"
 BRIDGE_SCRIPT="{bridge_script}"
 PYTHON_BIN="{python_bin}"
 SCRIPT_DIR="{self.script_dir}"
 SOCKET_PATH="{self.daemon_socket}"
 DAEMON_PID="{self.daemon_pid_file}"
CLIENT_ID="{self.client_id}"
BRIDGE_PID_FILE="$RUNTIME_DIR/bridge.pid"
BRIDGE_LOG="$RUNTIME_DIR/bridge.log"

# 写入PID
echo $$ > "$PID_FILE"

 echo "🤖 Codex会话启动: $SESSION_ID"
 echo "📁 运行目录: $RUNTIME_DIR"
 echo "🔧 输入管道: $INPUT_FIFO"
 echo "🔧 输出管道: $OUTPUT_FIFO"
 echo "🖥️  tmux会话: $TMUX_SESSION"

 # 等待输入管道可用
 while [ ! -p "$INPUT_FIFO" ]; do
     echo "⏳ 等待输入管道..."
     sleep 0.1
done

echo "✅ 管道连接建立"

# 检查桥接脚本和Python环境
if [ ! -f "$BRIDGE_SCRIPT" ]; then
    echo "❌ 找不到桥接脚本: $BRIDGE_SCRIPT"
    sleep 5
    exit 1
fi

if [ ! -x "$PYTHON_BIN" ]; then
    echo "❌ 无法执行Python解释器: $PYTHON_BIN"
    sleep 5
    exit 1
fi

echo "🔧 准备启动Codex桥接器..."
export PYTHONPATH="$SCRIPT_DIR:${{PYTHONPATH:-}}"
export CODEX_SESSION_ID="$SESSION_ID"
export CODEX_RUNTIME_DIR="$RUNTIME_DIR"
export CODEX_DAEMON_SOCKET="$SOCKET_PATH"
 export CODEX_DAEMON_PID="$DAEMON_PID"
 export CODEX_CLIENT_ID="$CLIENT_ID"
 export CODEX_INPUT_FIFO="$INPUT_FIFO"
 export CODEX_OUTPUT_FIFO="$OUTPUT_FIFO"
 export CODEX_TMUX_SESSION="$TMUX_SESSION"
 export CODEX_TMUX_LOG="$TMUX_LOG_FILE"

# 启动或准备tmux会话
if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
    tmux new-session -d -s "$TMUX_SESSION" "codex"
    sleep 1
fi
tmux pipe-pane -o -t "$TMUX_SESSION" "cat >> '$TMUX_LOG_FILE'"

# 启动桥接器（后台运行）
"$PYTHON_BIN" "$BRIDGE_SCRIPT" --runtime-dir "$RUNTIME_DIR" --session-id "$SESSION_ID" >>"$BRIDGE_LOG" 2>&1 &
BRIDGE_PID=$!
echo $BRIDGE_PID > "$BRIDGE_PID_FILE"
echo "🪄 桥接器已启动 (PID: $BRIDGE_PID)"
echo "📄 日志输出: $BRIDGE_LOG"

cleanup() {{
    if [ -n "$BRIDGE_PID" ]; then
        kill -TERM "$BRIDGE_PID" 2>/dev/null
        wait "$BRIDGE_PID" 2>/dev/null
    fi
}}
trap cleanup EXIT

# 附加到tmux会话供用户使用
exec tmux attach -t "$TMUX_SESSION"
'''

        try:
            # 将脚本写入临时文件
            script_file = self.runtime_dir / "codex_wrapper.sh"
            with open(script_file, 'w') as f:
                f.write(codex_wrapper_script)
            os.chmod(script_file, 0o755)

            if self.terminal_type == "tmux":
                # 使用tmux创建新会话
                cmd = [
                    "tmux", "new-session", "-d", "-s", f"codex-{self.session_id[:8]}",
                    str(script_file)
                ]
                subprocess.run(cmd, check=True)

                # 附加到tmux会话
                subprocess.run([
                    "tmux", "attach-session", "-t", f"codex-{self.session_id[:8]}"
                ])

            elif self.terminal_type in ["gnome-terminal", "xfce4-terminal"]:
                cmd = [
                    self.terminal_type, "--title", f"Codex ({self.session_id[:8]})",
                    "--", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "konsole":
                cmd = [
                    "konsole", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            elif self.terminal_type == "alacritty":
                cmd = [
                    "alacritty", "--title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            else:  # xterm 或其他
                cmd = [
                    self.terminal_type, "-title", f"Codex ({self.session_id[:8]})",
                    "-e", str(script_file)
                ]
                self.codex_process = subprocess.Popen(cmd)

            print(f"✅ Codex窗口已启动 (PID: {self.codex_process.pid if self.codex_process else 'tmux'})")
            return True

        except Exception as e:
            print(f"❌ 启动Codex窗口失败: {e}")
            return False

    def start_claude_window(self):
        """启动Claude窗口"""
        print("🚀 启动Claude窗口...")

        # 保存会话信息到项目目录
        try:
            with open(self.project_session_file, 'w') as f:
                session_info = {
                    "session_id": self.session_id,
                    "runtime_dir": str(self.runtime_dir),
                    "input_fifo": str(self.input_fifo),
                    "output_fifo": str(self.output_fifo),
                    "tmux_session": self.tmux_session,
                    "tmux_log": str(self.tmux_log_file),
                    "daemon_socket": str(self.daemon_socket),
                    "daemon_pid_file": str(self.daemon_pid_file),
                    "bridge_pid_file": str(self.bridge_pid_file),
                    "bridge_log": str(self.runtime_dir / "bridge.log"),
                    "client_id": self.client_id,
                    "started_at": time.strftime('%Y-%m-%d %H:%M:%S')
                }
                json.dump(session_info, f, indent=2)
            print(f"✅ 会话信息已保存: {self.project_session_file}")
        except Exception as e:
            print(f"⚠️ 保存会话信息失败: {e}")

        # 设置环境变量
        env = os.environ.copy()
        env["CODEX_SESSION_ID"] = self.session_id
        env["CODEX_RUNTIME_DIR"] = str(self.runtime_dir)
        env["CODEX_INPUT_FIFO"] = str(self.input_fifo)
        env["CODEX_OUTPUT_FIFO"] = str(self.output_fifo)
        env["CODEX_CLIENT_ID"] = self.client_id
        env["CODEX_DAEMON_SOCKET"] = str(self.daemon_socket)
        env["CODEX_DAEMON_PID"] = str(self.daemon_pid_file)
        env["CODEX_TMUX_SESSION"] = self.tmux_session
        env["CODEX_TMUX_LOG"] = str(self.tmux_log_file)

        # 写入Claude PID
        with open(self.claude_pid_file, 'w') as f:
            f.write(str(os.getpid()))

        # 更新状态
        with open(self.status_file, 'w') as f:
            f.write("running")

        print(f"📋 会话ID: {self.session_id}")
        print(f"📁 运行目录: {self.runtime_dir}")
        print("✅ Claude窗口就绪")
        print()
        print("🎯 可用命令:")
        print("   /codex-ask <问题>              - 异步发送问题")
        print("   /codex-ask --wait <问题>       - 同步等待回复")
        print("   /codex-status                  - 查看连接状态")
        print("   /codex-ping                    - 测试连通性")
        print()

        # 启动Claude Code
        try:
            cmd = ["claude"] + self.claude_args
            print(f"执行: {' '.join(cmd)}")

            return subprocess.run(
                cmd,
                stdin=sys.stdin,
                stdout=sys.stdout,
                stderr=sys.stderr,
                env=env
            ).returncode

        except KeyboardInterrupt:
            print("\\n⚠️ 用户中断")
            return 130
        except Exception as e:
            print(f"❌ 启动Claude失败: {e}")
            return 1

    def cleanup(self):
        """清理资源"""
        print("\\n🧹 清理会话资源...")

        try:
            # 停止Codex进程
            if self.codex_process and self.codex_process.poll() is None:
                self.codex_process.terminate()
                try:
                    self.codex_process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    self.codex_process.kill()

            # 停止桥接器
            if self.bridge_pid_file.exists():
                try:
                    bridge_pid = int(self.bridge_pid_file.read_text().strip())
                    os.kill(bridge_pid, signal.SIGTERM)
                except Exception:
                    pass
                try:
                    self.bridge_pid_file.unlink()
                except Exception:
                    pass

            # 如果是tmux会话，杀掉tmux
            if self.terminal_type == "tmux":
                subprocess.run([
                    "tmux", "kill-session", "-t", f"codex-{self.session_id[:8]}"
                ], stderr=subprocess.DEVNULL)
            else:
                subprocess.run([
                    "tmux", "kill-session", "-t", self.tmux_session
                ], stderr=subprocess.DEVNULL)

            # 删除运行时目录
            import shutil
            if self.runtime_dir.exists():
                shutil.rmtree(self.runtime_dir)

            # 删除项目会话文件
            if self.project_session_file.exists():
                self.project_session_file.unlink()

            print("✅ 清理完成")

        except Exception as e:
            print(f"⚠️ 清理时出现错误: {e}")

    def run(self):
        """主运行流程"""
        print(f"🚀 Claude-Codex 双窗口模式")
        print(f"📅 启动时间: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"🆔 会话ID: {self.session_id}")
        print("=" * 50)

        # 注册清理函数
        atexit.register(self.cleanup)
        signal.signal(signal.SIGINT, lambda s, f: (self.cleanup(), sys.exit(0)))
        signal.signal(signal.SIGTERM, lambda s, f: (self.cleanup(), sys.exit(0)))

        # 创建管道
        if not self.create_fifos():
            return 1

        # 启动Codex窗口
        if not self.start_codex_window():
            return 1

        # 等待Codex启动
        time.sleep(2)

        # 启动Claude窗口
        try:
            return self.start_claude_window()
        finally:
            self.cleanup()

def show_help():
    """显示帮助信息"""
    help_text = """
claude-codex-dual - Claude-Codex 双窗口模式启动器

用法:
    claude-codex-dual [OPTIONS] [COMMAND] [ARGS]...

功能:
    🚀 同时启动Claude和Codex两个窗口
    🔗 建立Claude到Codex的单向控制通道
    💾 自动保存会话信息和历史记录
    🔄 支持中断恢复和错误处理

选项:
    --resume              恢复上次的会话
    --help, -h            显示帮助信息

Claude命令 (在Claude窗口中使用):
    /codex-ask <问题>              - 异步发送问题到Codex
    /codex-ask --wait <问题>       - 同步等待Codex回复
    /codex-status                  - 查看连接状态
    /codex-ping                    - 测试连通性
    /codex-history [n]             - 查看最近n条对话

示例:
    claude-codex-dual                           # 启动双窗口模式
    claude-codex-dual --resume                  # 恢复上次会话
    claude-codex-dual /path/to/project          # 在项目目录启动
"""
    print(help_text)

def main():
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument('--resume', action='store_true', help='恢复上次的会话')
    parser.add_argument('--help', '-h', action='store_true', help='显示帮助')

    # 解析已知参数，其余传给claude
    args, claude_args = parser.parse_known_args()

    if args.help:
        show_help()
        return 0

    dual = ClaudeCodexDual(resume=args.resume, claude_args=claude_args)
    return dual.run()

if __name__ == "__main__":
    sys.exit(main())
